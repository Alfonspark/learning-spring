<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="aop-api">
  <title>Spring AOP API</title>

  <section id="aop-api-introduction">
    <title>소개</title>

    <para>이전 장에서 @AspectJ와 스키마 기반의 관점 정의를 사용하는 AOP에 대한 스프링 2.0과 
    그 이후 버전의 지원에 대해서 설명했다. 이번 장에서는 저수준 스프링 AOP API와 스프링 1.2 
    어플리케이션에서 사용하는 AOP 지원에 대해서 설명한다. 새로운 어플리케이션에서는 이전 장에서 
    설명한 스프링 2.0이상의 AOP지원을 사용하기를 권장하지만 이미 존재하는 어플리케이션에서 작업하거나 
    책이나 글을 읽는 경우에 스프링 1.2 방식의 예제를 봐야할 것이다. 스프링 3.0은 스프링 1.2와 
    하위호환성을 자기도 있으며 이번 장에서 설명하는 내용은 모두 스프링 3.0에서도 완전히 지원한다.</para>
  </section>

  <section id="aop-api-pointcuts">
    <title>스프링의 포인트컷 API</title>

    <para>스프링이 포인트컷의 핵심 개념을 어떻게 다루는 지 보자.</para>

    <section id="aop-api-concepts">
      <title>개념</title>

      <para>스프링의 포인트컷 모델은 어드바이스 타입과 독립적으로 포인트컷을 재사용할 수 있다. 
      그래서 다른 대상 어드바이스에 같은 포인트컷을 사용할 수 있다.</para>

      <para><literal>org.springframework.aop.Pointcut</literal> 인터페이스가 특정 
      클래스와 메서드에 어드바이스를 적용하는데 사용하는 핵심 인터페이스이다. 전체 인터페이스는 
      다음에 나와있다.</para>

      <programlisting language="java">public interface Pointcut {

    ClassFilter getClassFilter();

    MethodMatcher getMethodMatcher();

}</programlisting>

      <para><interfacename>Pointcut</interfacename> 인터페이스를 두 부분으로 분리해서 
      클래스와 메서드 매칭 부분과 세밀한 구성 작업(다른 메서드 매처(matcher)와의 "결합" 
      작업같은)을 재사용할 수 있다.</para>

      <para><interfacename>ClassFilter</interfacename> 인터페이스는 포인트컷을 주어진 
      대상 클래스의 세트로 제한하는데 사용한다. <literal>matches()</literal> 메서드가 항상 
      true를 반환한다면 모든 대상 클래스가 매치될 것이다.</para>

      <programlisting language="java">public interface ClassFilter {

    boolean matches(Class clazz);
}</programlisting>

      <para>일반적으로는 <interfacename>MethodMatcher</interfacename> 인터페이스가 
      더 중요하다. 전체 인터페이스는 다음에 나와있다.</para>

      <programlisting language="java">public interface MethodMatcher {

    boolean matches(Method m, Class targetClass);

    boolean isRuntime();

    boolean matches(Method m, Class targetClass, Object[] args);
}</programlisting>

      <para><literal>matches(Method, Class) </literal> 메서드는 대상 클래스의 주어진 
      메서드가 매치될 것인지를 검사하는데 사용한다. 이 평가작업은 메서드를 호출할 때마다 검사하는 것을 
      피하기 위해서 AOP 프록시를 생성할 때 수행할 수 있다. 2개의 아규먼트로 매칭하는 메서드가 주어진 
      메서드에 대해서 true를 반환하고 MethodMatcher에 대해서 <literal>isRuntime()</literal> 
      메서드가 true를 반환하면 3개의 아규먼트로 매칭하는 메서드는 메서드가 호출될 때마다 실행될 것이다. 
      이는 대상 어드바이스가 실행되기 이전에 포인트컷이 메서드 호출에 전달된 아규먼트를 바로 볼 수 
      있도록 한다.</para>

      <para>대부분의 MethodMatcher는 static이다. 즉 MethodMatchers의 
      <literal>isRuntime()</literal> 메서드는 false를 반환한다. 이 경우에 3개의 
      아규먼트로 매칭하는 메서드는 실행되지 않을 것이다.</para>

      <tip>
        <para>AOP 프레임워크가 AOP 프록시를 생성할 때 포인트컷의 평가 결과를 캐시할 수 
        있도록 가능한한 포인트컷을 스태틱으로 만들어라.</para>
      </tip>
    </section>

    <section id="aop-api-pointcut-ops">
      <title>포인트컷 상에서의 연산작업</title>

      <para>스프링은 포인트컷의 연산작업을 지원한다. 특히 
      <emphasis>union</emphasis>과 <emphasis>intersection</emphasis>.</para>

      <itemizedlist>
        <listitem>
          <para>Union은 어떤 포인트컷이라도 매칭된 메서드를 의미한다.</para>
        </listitem>

        <listitem>
          <para>Intersection은 두 포인트컷이 모두 매칭된 메서드를
          의미한다.</para>
        </listitem>

        <listitem>
          <para>보통은 Union이 더 유용하다.</para>
        </listitem>

        <listitem>
          <para><emphasis>org.springframework.aop.support.Pointcuts</emphasis> 
          클래스의 정적 메서드나 같은 팩키지의 <emphasis>ComposablePointcut</emphasis> 
          클래스를 사용해서 포인트컷을 구성할 수 있다. 하지만 일반적으로는 AspectJ 포인트컷 
          현식이 더 간단하다.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="aop-api-pointcuts-aspectj">
      <title>AspectJ 표현식 포인트컷</title>

      <para>2.0부터 스프링이 사용하는 가장 중요한 포인트컷 타입은 
      <literal>org.springframework.aop.aspectj.AspectJExpressionPointcut</literal>이다. 
      이 포인트컷은 AspectJ 포인트컷 표현식 문자열을 파싱하기 위해 AspectJ가 제공하는 
      라이브러리를 사용한다.</para>

      <para>지원하는 AspectJ 포인트컷 프리미티브를 설명한 이전 장을 참고해라.</para>
    </section>

    <section id="aop-api-pointcuts-impls">
      <title>편리한 포인트컷 구현체</title>

      <para>스프링은 편리한 포인트컷 구현체를 다수 제공한다. 이 구현체 중 일부는 독창적으로 
      사용할 수 있다. 다른 구현체들은 어플리케이션에 한정적인 포인트컷의 하위 클래스가 
      되기 위해 만들어졌다.</para>

      <section id="aop-api-pointcuts-static">
        <title>정적(Static) 포인트컷</title>

        <para>정적 포인트컷은 메서드와 대상 클래스에 기반을 두고 있고 메서드의 아규먼트를 참조할 
        수 없다. 대부분의 용도에는 정적 포인트컷으로도 충분하다(<emphasis>가장 좋다</emphasis>). 
        스프링에서 정적 포인트컷은 최초 메서드가 호출될 때 딱 한번만 평가할 수 있고 그 이후의 메서드 
        호출마다 포인트컷을 다시 평가할 필요는 없다.</para>

        <para>스프링에 포함된 몇가지 정적 포인트컷 구현체를 살펴보자.</para>

        <section id="aop-api-pointcuts-regex">
          <title>정규 표현식 포인트컷</title>

          <para>정적 포인트컷을 지정하는 확실한 방법 중 하나는 정규표현식을 사용하는 것이다. 
          스프링을 포함한 다수의 AOP 프레임워크는 정규표현식을 사용하는 것이 가능하다. 
          <literal>org.springframework.aop.support.JdkRegexpMethodPointcut</literal>이 
          JDK 1.4이상에서 지원하는 정규표현식을 사용하는 일반적인 정규표현식 
          포인트컷이다.</para>

          <para><literal>JdkRegexpMethodPointcut</literal> 클래스를 사용해서 패턴 
          문자열의 목록을 제공할 수 있다. 제공한 패턴 문자열 중에 일치하는 것이 있다면 포인트컷을 
          true라고 평가할 것이다. (그래서 효율적으로 이러한 포인트컷을 결합(union)한 
          결과가 된다.)</para>

          <para>다음에서 사용방법을 보여준다.</para>

          <para><programlisting language="xml">&lt;bean id="settersAndAbsquatulatePointcut" 
    class="org.springframework.aop.support.JdkRegexpMethodPointcut"&gt;
    &lt;property name="patterns"&gt;
        &lt;list&gt;
            &lt;value&gt;.*set.*&lt;/value&gt;
            &lt;value&gt;.*absquatulate&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

          <para>스프링은 Advice(Advice는 인터셉터, before advice, throws advice등이 
          될 수 있다는 점을 기억해라.)도 참조할 수 있도록 
          <literal>RegexpMethodPointcutAdvisor</literal>라는 편리한 클래스를 제공한다.
          스프링은 내부에서 <literal>JdkRegexpMethodPointcut</literal>를 사용할 것이다. 
          다음 예제처럼 <literal>RegexpMethodPointcutAdvisor</literal>을 사용해서 
          간단하게 연결(wiring)할 수 있다.(하나의 빈이 포인트컷과 어드바이스를 모두 
          은닉화한다.)</para>

          <para><programlisting language="xml">&lt;bean id="settersAndAbsquatulateAdvisor" 
    class="org.springframework.aop.support.RegexpMethodPointcutAdvisor"&gt;
    &lt;property name="advice"&gt;
        &lt;ref local="beanNameOfAopAllianceInterceptor"/&gt;
    &lt;/property&gt;
    &lt;property name="patterns"&gt;
        &lt;list&gt;
            &lt;value&gt;.*set.*&lt;/value&gt;
            &lt;value&gt;.*absquatulate&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

          <para><emphasis>RegexpMethodPointcutAdvisor</emphasis>는 어떤 타입의 
          Advice에도 사용할 수 있다.</para>
        </section>

        <section id="aop-api-pointcuts-attribute-driven">
          <title>속성 주도(Attribute-driven) 포인트컷</title>

          <para><emphasis>metadata-driven</emphasis> 포인트컷은 중요한 정적 포인트컷 
          타입이다. 이 포인트컷은 메타데이터 속성의 값을 사용한다. 일반적으로는 소스레벨의 
          메타데이터를 사용한다.</para>
        </section>
      </section>

      <section id="aop-api-pointcuts-dynamic">
        <title>동적(Dynamic) 포인트컷</title>

        <para>동적 포인트컷은 정적 포인트컷보다 평가하는데 비용이 더 많이 든다. 동적 포인트컷은 
        정적 정보와 마찬가지로 메서드의 <emphasis>arguments</emphasis>를 참조한다. 즉 
        동적 포인트컷은 메서드 호출시마다 매번 평가되어야 한다. 아규먼트가 달라질 것이므로 평가 
        결과는 캐싱할 수 없다.</para>

        <para>주요한 예제는 <literal>흐름 제어(control flow)</literal> 
        포인트컷이다.</para>

        <section id="aop-api-pointcuts-cflow">
          <title>흐름 제어(Control flow) 포인트컷</title>

          <para>스프링의 흐름제어 포인트컷은 개념적으로 AspectJ의 <emphasis>cflow</emphasis> 
          포인트컷과 비슷하지만 기능을 더 적다. (현재는 다른 포인트컷이 매칭한 조인 포인트하에서 포인트컷을 
          실행하도록 지정할 수 있는 방법이 없다.) 흐름 제어 포인트컷은 현재 호출스택(call stack)을 
          매칭한다. 예를 들어 <literal>com.mycompany.web</literal> 패키지의 메서드나 
          <literal>SomeCaller</literal> 클래스가 조인 포인트를 호출한 경우 발생(fire)할 것이다. 
          흐름 제어 포인트컷은 <literal>org.springframework.aop.support.ControlFlowPointcut
          </literal> 클래스를 사용해서 지정한다.<note>
              <para>흐름제어 포인트컷은 동적 포인트컷보다도 런타임에서 평가하는 비용이 약간 더 비싸다. 
              자바 1.4에서는 다른 동적 포인트컷보다 비용이 약 5배정도 크다.</para>
            </note></para>
        </section>
      </section>
    </section>

    <section id="aop-api-pointcuts-superclasses">
      <title>포인트컷 슈퍼클래스</title>

      <para>스프링은 자신만의 포인트컷을 구현할 수 있도록 유용한 포인트컷 슈퍼클래스들을
      제공한다.</para>

      <para>정적 포인트컷이 가장 유용하기 때문에 다음과 같이 StaticMethodMatcherPointcut의 
      하위클래스를 만들 것이다. 이 하위클래스는 딱 하나의 추상 메서드를 구현해야 한다.(동작을 바꾸기 
      위해 다른 메서드를 오버라이드하는 것도 가능하다.)</para>

      <para><programlisting language="java">class TestStaticPointcut extends StaticMethodMatcherPointcut {

    public boolean matches(Method m, Class targetClass) {
        // 커스텀 크리테리아가 일치하면 true를 반환한다
    }
}</programlisting>동적 포인트컷에 대한 슈퍼클래스들도 존재한다.</para>

      <para>스프링 1.0 RC2 이상의 버전에서는 어떤 타입의 어드바이스로도 커스텀 포인트컷을 
      사용할 수 있다.</para>
    </section>

    <section id="aop-api-pointcuts-custom">
      <title>커스텀 포인트컷</title>

      <para>스프링 AOP에서 포인트컷은 언어의 기능(AspectJ처럼)이 아니라 자바 클래스이기 때문에 
      정적이든 동적이든 커스텀 포인트컷을 선언할 수 있다. 스프링의 커스텀 포인트컷은 상황에 따라 
      복잡해 질 수 있다. 하지만 가능하다면 AspectJ 포인트컷 표현식 언어를 사용하기를 
      추천한다.</para>

      <note>
        <para>스프링의 차기 버전에서는 JAC가 제안한 것과 같은 "시맨틱(semantic) 포인트컷"을 
        지원할 것이다. 예를 들면 "대상 클래스에서 인스턴스 변수를 변경하는 모든 메서드"같은 
        것이다.</para>
      </note>
    </section>
  </section>

  <section id="aop-api-advice">
    <title>스프링의 Advice API</title>

    <para>이제 스프링 AOP가 어떻게 어드바이스를 다루는지 살펴보자.</para>

    <section id="aop-api-advice-lifecycle">
      <title>어드바이스 생명주기</title>

      <para>각각의 어드바이스는 스프링 빈이다. 어드바이스 인스턴스는 어드바이즈된 모든 객체사이에서 
      공유되거나 어드바이즈된 각 객체에 유일하게 공유될 수 있다. 각각 
      <emphasis>per-class</emphasis> 어드바이스와 
      <emphasis>per-instance</emphasis> 어드바이스다.</para>

      <para>Per-class 어드바이스를 가장 자주 사용한다. Per-class 어드바이스는 트랜잭션 
      어드바이저같은 일반적인 어드바이스에 적절하다. 이 어드바이스는 프록시된 객체의 상태에 의존하거나 
      새로운 상태를 추가하지 말아야 한다. 이 어드바이스는 주로 메서드와 아규먼트에서 
      동작한다.</para>

      <para>Per-instance 어드바이스는 믹스인을 사용하기 위한 인트로덕션에 적합하다. 
      이러한 경우 어드바이스가 프록시된 객체에 상태를 추가한다.</para>

      <para>같은 AOP 프록시에서 공유된 per-instance 어드바이스를 섞어서 사용할 수 
      있다.</para>
    </section>

    <section id="aop-api-advice-types">
      <title>스프링의 어드바이스 타입</title>

      <para>스프링은 여러 가지 독창적인 어드바이스 타입을 제공하고 임의의 어드바이스 타입을 
      지원하기 위해 확장할 수 있다. 표준 어드바이스 타입과 기본적인 개념을 살펴보자.</para>

      <section id="aop-api-advice-around">
        <title>Interception around advice</title>

        <para><emphasis>interception around advice</emphasis>가 
        스프링에서 가장 기본적인 어드바이스 타입이다.</para>

        <para>스프링은 메서드 가로채기(interception)를 사용하는 around advice에 AOP 
        Alliance 인터페이스를 따른다. around advice를 구현하는 MethodInterceptor는 
        다음의 인터페이스를 구현해야 한다.</para>

        <programlisting language="java">public interface MethodInterceptor extends Interceptor {
  
    Object invoke(MethodInvocation invocation) throws Throwable;
}</programlisting>

        <para><methodname>invoke()</methodname> 메서드의 
        <classname>MethodInvocation</classname> 아규먼트는 호출되는 메서드, 대상 
        조인포인트, AOP 프록시, 메서드의 아규먼트를 노출한다. 
        <methodname>invoke()</methodname> 메서드는 반드시 호출결과인 조인포인트의 
        반환값을 반환해야 한다.</para>

        <para>간단한 <classname>MethodInterceptor</classname> 구현체는 다음과 
        같다.</para>

        <programlisting language="java">public class DebugInterceptor implements MethodInterceptor {

    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println("Before: invocation=[" + invocation + "]");
        Object rval = invocation.proceed();
        System.out.println("Invocation returned");
        return rval;
    }
}</programlisting>

        <para>MethodInvocation의 <methodname>proceed()</methodname> 메서드를 
        호출한다. 이는 조인포인트쪽으로 인터셉터 체인을 따라 진행된다. 대부분의 인터셉터는 이 
        메서드를 호출하고 그 결과값을 반환할 것이다. 하지만 다른 around advice처럼 
        MethodInterceptor도 다른 값을 반환하거나 proceed 메서드를 호출하지 않고 예외를 
        던질 수 있다. 하지만 합당한 이유가 없이는 이렇게 되기를 바라지 않을 것이다!</para>

        <note>
          <para>MethodInterceptor는 다른 AOP Alliance 호환 AOP 구현체와의 
          상호운용성(interoperability)을 제공한다. 이번 섹션의 남은 부분에서 얘기하는 다른 
          어드바이스 타입들은 일반적인 AOP 개념을 구현했지만 스프링식으로 구현했다. 가장 구체적인 
          어드바이스 타입을 사용할 때의 장점이 있지만 다른 AOP 프레임워크에서 관점을 실행하고 싶다면 
          MethodInterceptor around advice을 사용해라. 현재 포인트컷은 프레임워크간에 
          상호운용성이 없고 AOP Alliance는 포인트컷 인터페이스를 정의하고 있지 
          않다.</para>
        </note>
      </section>

      <section id="aop-api-advice-before">
        <title>Before advice</title>

        <para>더 간단한 어드바이스 타입은 <emphasis role="bold">before
        advice</emphasis>이다. 이 어드바이스는 메서드에 진입하기 전에만 호출될 것이므로 
        <literal>MethodInvocation</literal> 객체가 필요하지 않다.</para>

        <para>before advice의 가장 큰 장점은 <literal>proceed() </literal> 메서드를 
        호출할 필요가 없으므로 인터셉터 체인을 따라 진행되는데 우연히라도 실패할 가능성이 
        없다는 것이다.</para>

        <para><literal>MethodBeforeAdvice</literal> 인터페이스는 다음에 나와있다. 
        (일반적인 객체를 필드 인터셉션에 적용하고 스프링이 이를 구현할 것 같지도 않지만 스프링의 
        API 디자인은 어드바이즈 이전의 필드를 허용할 것이다.)</para>

        <programlisting language="java">public interface MethodBeforeAdvice extends BeforeAdvice {

    void before(Method m, Object[] args, Object target) throws Throwable;
}</programlisting>

        <para>반환 타입은 <literal>void</literal>이다. before advice는 조인 포인트를 
        실행하기 전에 임의의 동작을 추가할 수 있지만 반환값을 바꿀 수는 없다. before advice가 
        예외를 던지면 인터셉터 체인의 이어진 실행을 중단할 것이다. 예외는 인터셉터 체인으로 전파된다. 
        예외가 언체크드(unchecked)이면(또는 호출된 메서드의 시그니쳐상에서) 클라이언트에 직접 
        예외가 전달된다. 예외가 언체크드가 아니라면 AOP 프록시가 언체크드 익셉션으로 감쌀 
        것이다.</para>

        <para>다음은 모든 메서드 호출 횟수를 세는 스프링의 before advice의 
        예제다.</para>

        <programlisting language="java">public class CountingBeforeAdvice implements MethodBeforeAdvice {

    private int count;

    public void before(Method m, Object[] args, Object target) throws Throwable {
        ++count;
    }

    public int getCount() { 
        return count; 
    }
}</programlisting>

        <tip>
          <para>Before advice는 어떤 포인트컷과도 사용할 수 있다.</para>
        </tip>
      </section>

      <section id="aop-api-advice-throws">
        <title>Throws advice</title>

        <para><emphasis role="bold">Throws advice</emphasis>는 조인포인트가 예외를 
        던진 경우 조인포인트가 반환된 후에 호출된다. 즉 
        <literal>org.springframework.aop.ThrowsAdvice</literal> 인터페이스는 어떤 
        메서드도 가지고 있지 않다. 이 인터페이스는 하나 이상의 throws advice 메서드를 구현한 
        주어진 객체를 식별하는 tag 인터페이스이다. 이는 다음 형태가 되어야 한다.</para>

        <programlisting language="java">afterThrowing([Method, args, target], subclassOfThrowable) </programlisting>

        <para>마지막 아규먼트만 필수 아규먼트다. 메서드 시그니처는 어드바이스 메서드가 메서드와 
        아규먼트에 관계되었는 지에 따라 한개나 네개의 아규먼트를 가질 것이다. 다음 클래스들은 
        throws advice의 예제들이다.</para>

        <para>다음의 어드바이스는 <exceptionname>RemoteException</exceptionname>가 
        던져질 때(서브클래스 포함) 호출된다.</para>

        <programlisting language="java">public class RemoteThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(RemoteException ex) throws Throwable {
        <lineannotation>// 원격 예외로 무언가를 한다</lineannotation>
    }
}</programlisting>

        <para><exceptionname>ServletException</exceptionname>가 던져졌을 때 
        다음의 어드바이스가 호출된다. 위의 어드바이스와는 달리 호출된 메서드, 메서드 아규먼트, 
        대상 객체에 접근하기 위해서 4개의 아규먼트를 선언한다.</para>

        <programlisting language="java">public class ServletThrowsAdviceWithArguments implements ThrowsAdvice {

    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        <lineannotation>// Do something with all arguments</lineannotation>
    }
}</programlisting>

        <para>마지막 예제는 하나의 클래스에서 <literal>RemoteException</literal>과 
        <literal>ServletException</literal>을 다루는 두 메서드를 어떻게 사용할 수 
        있는지를 설명한다. 하나의 클래스에서 throws advice 메서드를 몇개든 
        조합할 수 있다.</para>

        <programlisting language="java">public static class CombinedThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(RemoteException ex) throws Throwable {
        // 원격 예외로 무언가를 한다
    }
 
    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        // 모든 아규먼트로 무언가를 한다
    }
}</programlisting>

        <para><emphasis>Note:</emphasis> throws-advice 메서드 자체가 예외를 던지면 
        원래의 예외를 오버라이드할 것이다.(예시: 사용자에게 던져진 예외를 변경한다) 오버라이딩된 
        예외는 일반적으로 RuntimeException이 될 것이다. 이는 어떤 메서드 시그니처와도 호환성을 
        가진다. 하지만 throws-advice 메서드가 체크드 익셉션을 던지면 대상 메서드에서 선언된 
        예외와 일치해야 하므로 특성 대상 메서드 시그니처와 약간 커플링이 생긴다. <emphasis>대상 
        메서드의 시그니처와 맞지 않는 선언되지 않은 체크드 익셉션을 
        던지지 마라!</emphasis></para>

        <tip>
          <para>Throws advice는 어떤 포인트컷과도 사용할 수 있다.</para>
        </tip>
      </section>

      <section id="aop-api-advice-after-returning">
        <title>After Returning advice</title>

        <para>스프링에서 after returning advice는 다음과 같이 
        <emphasis>org.springframework.aop.AfterReturningAdvice</emphasis> 
        인터페이스를 반드시 구현해야 한다.</para>

        <programlisting language="java">public interface AfterReturningAdvice extends Advice {

    void afterReturning(Object returnValue, Method m, Object[] args, Object target) 
            throws Throwable;
}</programlisting>

        <para>after returning advice는 반환값(수정불가), 호출된 메서드, 메서드의 
        아규먼트, 대상객체에 접근한다.</para>

        <para>다음의 after returning advice는 예외를 던지지 않고 성공적으로 
        호출된 모든 메서드의 수를 센다.</para>

        <programlisting language="java">public class CountingAfterReturningAdvice implements AfterReturningAdvice {

    private int count;

    public void afterReturning(Object returnValue, Method m, Object[] args, Object target)
            throws Throwable {
        ++count;
    }

    public int getCount() {
        return count;
    }
}</programlisting>

        <para>이 어드바이스는 실행 경로를 변경하지 않는다. 예외를 던질 경우에는 반환값을 반환하지 
        않고 예외를 인터셉터 체인에 던진다.</para>

        <tip>
          <para>After returning advice는 어떤 포인트컷과도 사용할 수 있다.</para>
        </tip>
      </section>

      <section id="aop-api-advice-introduction">
         

        <title>Introduction advice</title>

         

        <para>스프링은 인트로덕션 어드바이스를 인터셉션(interception) 어드바이스의 
        특별한 종류처럼 다룬다.</para>

         

        <para>인트로덕션은 다음의 인터페이스를 구현한<literal>IntroductionAdvisor</literal>와 
        <literal>IntroductionInterceptor</literal>를 필요로 한다.</para>

         

        <programlisting language="java">public interface IntroductionInterceptor extends MethodInterceptor {

    boolean implementsInterface(Class intf);
}</programlisting>

         

        <para>AOP Alliance <literal>MethodInterceptor</literal> 인터페이스에서 
        상속받은 <literal>invoke() </literal> 메서드는 인트로덕션을 구현해야 한다. 즉, 
        인트로덕션이 된 인터페이스(introduced interface)에서 메서드가 호출되면 인트로덕션 
        인터셉터가 메서드 호출을 다루는 책임을 담당한다. 이는 <literal>proceed()</literal>를 
        호출할 수 없다.</para>

         

        <para>인트로덕션 어드바이스는 메서드가 아닌 클래스에만 적용되기 때문에 모든 포인트컷과 
        사용할 수 없다. 인트로덕션 어드바이스는 다음의 메서드를 가진 
        <literal>IntroductionAdvisor</literal>과 함께만 사용할 수 있다.</para>

         

        <programlisting language="java">public interface IntroductionAdvisor extends Advisor, IntroductionInfo {

	ClassFilter getClassFilter();

	void validateInterfaces() throws IllegalArgumentException;
}

public interface IntroductionInfo {

	Class[] getInterfaces();
}</programlisting>

         

        <para>인트로덕션 어드바이스와 연관된 <interfacename>MethodMatcher</interfacename>는 
        존재하지 않는다.(그러므로 <interfacename>Pointcut</interfacename>도 없다.) 
        클래스 필터링만이 적합하다.</para>

         

        <para><literal>getInterfaces()</literal> 메서드는 이 어드바이저가 
        인트로덕션한 인터페이스를 반환한다.</para>

        <literal>validateInterfaces()</literal>
        설정된 <literal>IntroductionInterceptor</literal>로 인트로덕션이 된 인터페이스를 구현할 수 있는지를 확인하기 위해서 <literal>validateInterfaces()</literal> 메서드를 내부적으로 사용한다


         . 

        <para>스프링 테스트슈트에 있는 간단한 예제를 보자. 다음의 인터페이스를 하나이상의 객체에 
        인트로덕션하기를 원한다고 가정하자.</para>

         

        <para>
          <programlisting language="java">public interface Lockable {
    void lock();
    void unlock();
    boolean locked();
}</programlisting>
        </para>

         

        <para>이 예제는 <emphasis role="bold">믹스인(mixin)</emphasis>을 설명해 준다. 
        어드바이즈된 객체의 타입이 무엇이든간에 Lockable로 캐스팅 할 수 있고 lock, unlock 메서드를 
        호출할 수 있기를 원한다. lock() 메서드를 호출하면 모든 setter 메서드가 
        <literal>LockedException</literal>를 던져야 한다. 그러므로 객체에 대한 정보가 없이도 
        객체를 불변(immutable)하게 만들 수 있는 관점을 추가할 수 있다. 이는 AOP의 좋은 
        예이다.</para>

         

        <para>첫째로 힘든 일을 수행하는 <literal>IntroductionInterceptor</literal>가 
        필요하다. 이 경우에는 편리한 
        <literal>org.springframework.aop.support.DelegatingIntroductionInterceptor</literal> 
        클래스를 확장한다. 직접 IntroductionInterceptor를 구현할 수도 있지만 대부분의 경우에 
        <literal>DelegatingIntroductionInterceptor</literal>를 사용하는 것도 
        최선이다.</para>

         

        <para><literal>DelegatingIntroductionInterceptor</literal>는 인트로덕션은 
        인트로덕션된 인터페이스의 실제 구현체로 위임하도록 설계되었고 인터페이스는 이 작업을 하는 
        인터셉션의 사용을 감추고 있다. 위임은 생성자 아규먼트를 사용해서 어떤 객체에든 설정할 수 있다. 
        기본 위임은(아규먼트가 없는 생성자를 사용하는 경우) 다음과 같다. 그러므로 아래 예제에서 위임은 
        <literal>DelegatingIntroductionInterceptor</literal>의 하위클래스 
        <literal>LockMixin</literal>가 된다. 제공된 위임인(기본값이다) 
        <literal>DelegatingIntroductionInterceptor</literal> 인스턴스는 
        위임(IntroductionInterceptor를 제외한)이 구현한 모든 인스턴스를 찾고 찾아낸 인스턴스에 
        인트로덕션을 지원할 것이다. 이는 노출되지 않아야 하는 차단된(suppress) 인터페이스에 
        <literal>suppressInterface(Class intf) </literal> 메서드를 호출하는 
        <literal>LockMixin</literal>같은 하위클래스에도 가능하다. 하지만 얼마나 많은 인터페이스가 
        지원하기 위해 <literal>IntroductionInterceptor</literal>를 준비하고 
        <literal>IntroductionAdvisor</literal>를 사용한 얼마나 많은 인터페이스가 실제로 
        노출할 인터페이스를 제어하는 지는 중요하지 않다. 인트로덕션이 된 인터페이스는 대상객체로 같은 
        인터페이스의 모든 구현체를 감출 것이다.</para>

         

        <para>그러므로 LockMixin는 <literal>DelegatingIntroductionInterceptor</literal>의 
        하위클래스가 되고 Lockable 자체를 구현한다. 인트로덕션에 Lockable이 지원할 수 있는 
        슈퍼클래스를 자동적으로 선택하기 때문에 슈퍼클래스를 지정할 필요는 없다. 이 방법으로 
        인터페이스를 몇개든지 도입(introduce)할 수 있다.</para>

         

        <para><literal>locked</literal> 인스턴스 변수의 사용에 주목해라. 이는 대상객체가 
        가지는 부가적인 상태를 효과적으로 추가한다.</para>

         

        <para>
          <programlisting language="java">public class LockMixin extends DelegatingIntroductionInterceptor 
    implements Lockable {

    private boolean locked;

    public void lock() {
        this.locked = true;
    }

    public void unlock() {
        this.locked = false;
    }

    public boolean locked() {
        return this.locked;
    }

    public Object invoke(MethodInvocation invocation) throws Throwable {
        if (locked() &amp;&amp; invocation.getMethod().getName().indexOf("set") == 0)
            throw new LockedException();
        return super.invoke(invocation);
    }

}</programlisting>
        </para>

         

        <para>때로는 <literal>invoke()</literal> 메서드를 오버라이드할 필요가 없다. 
        <literal>DelegatingIntroductionInterceptor</literal> 구현체(메서드가 
        인트로덕션되었을 때 delegate 메서드를 호출하고 그렇지 않으면 조인포인트로 진행된다)로도 
        보통은 충분하다. 현시점에서는 locked 모드인 경우 호출될 수 있는 setter 메서드가 
        없는지 확인할 필요가 있다.</para>

         

        <para>인트로덕션 어드바이저에 필요한 것은 간단하다. 개별적인 
        <literal>LockMixin</literal> 인스턴스를 가지고 인트로덕션이 되는 인터페이스를 지정하는 
        것이 해야하는 작업의 전부이다. 이 예제의 경우에는 <literal>Lockable</literal> 뿐이다. 
        더 복잡한 예제에서는 인트로덕션 인터셉터(프로토타입으로 정의되었을 것이다)에 대한 참조를 받을 
        것이다. 이 경우에 <literal>LockMixin</literal>에 절적한 설정이 없기 때문에 
        <literal>new</literal>로 생성한다.</para>

         

        <para>
          <programlisting language="java">public class LockMixinAdvisor extends DefaultIntroductionAdvisor {

    public LockMixinAdvisor() {
        super(new LockMixin(), Lockable.class);
    }
}</programlisting>
        </para>

         

        <para>이 어드바이저를 아주 간단하게 적용할 수 있다. 이 어드바이저는 설정이 필요없다.
        (하지만 어드바이저는 필수적<emphasis>이다</emphasis>. 
        <emphasis>IntroductionAdvisor</emphasis>없이는 
        <literal>IntroductionInterceptor</literal>를 사용할 수 없다.) 어드바이저가 
        상태를 가지기(stateful) 때문에 인트로덕션과 사용할 때는 언제나 어드바이저는 per-instance가 
        되어야 한다. 어드바이즈된 각각의 객체마다 개별적인 <literal>LockMixinAdvisor</literal> 
        인스턴스(그리고 <literal>LockMixin</literal>)가 필요하다. 어드바이저는 어드바이즈된 
        객체의 상태의 일부분으로 구성된다.</para>

         

        <para>다른 어드바이저처럼 <literal>Advised.addAdvisor() </literal> 메서드를 
        사용하거나 XML설정(추천하는 방법이다)을 사용해서 이 어드바이저를 프로그래밍적으로 적용할 
        수도 있다. "auto proxy creators"를 포함해서 아래에서 설명하는 모든 프록시 생성 
        선택권들(proxy creation choices은 인트로덕션과 상태를 가진(stateful) 믹스인을 
        제대로 다룬다.</para>

         
      </section>
    </section>
  </section>

  <section id="aop-api-advisor">
    <title>스프링의 어드바이저(Advisor) API</title>

    <para>스프링에서 어드바이저는 포인트컷 표현식과 연결된 하나의 어드바이스 객체를 가진 
    관점이다.</para>

    <para>인트로덕션의 특수한 경우를 제외한 모든 어드바이저는 모든 어드바이스와 함게 사용할 수 있다. 
    <literal>org.springframework.aop.support.DefaultPointcutAdvisor</literal>가 
    가장 일반적으로 사용하는 어드바이저 클래스다. 예를 들어 이 클래스를 
    <literal>MethodInterceptor</literal>, <literal>BeforeAdvice</literal>, 
    <literal>ThrowsAdvice</literal>와 함께 사용할 수 있다.</para>

    <para>스프링에서 어드바이저 타입과 어드바이스 타입을 같은 AOP프록시안에 섞을 수 있다. 예를 들어 
    하나의 프록시 설정안에서 interception around advice, throws advice, before advice를 
    사용할 수 있다. 스프링은 자동적으로 필수적인 인터셉터 체임을 생성할 것이다.</para>
  </section>

  <section id="aop-pfb">
    <title>AOP 프록시 생성에 ProxyFactoryBean 사용하기</title>

    <para>비즈니스 객체에 스프링 IoC 컨테이너(ApplicationContext나 BeanFactory)를 
    사용한다면(꼭 사용해야 한다!) 스프링의 AOP FactoryBean중의 하나를 사용하고자 할 것이다. 
    (팩토리빈은 간접계층(layer of indirection)을 도입해서 다른 타입의 객체들을 생성할 수 
    있도록 한다는 점을 기억해라.)</para>

    <note>
      <para>스프링 2.0 AOP 지원도 팩토리빈을 사용한다.</para>
    </note>

    <para>스프링에서 AOP 프록시를 생성하는 기본적인 방법은 
    <emphasis>org.springframework.aop.framework.ProxyFactoryBean</emphasis>를 
    사용하는 것이다. 이 방법으로 적용할 포인트컷과 어드바이스와 이들의 순서를 완전히 제어할 수 있다. 
    하지만 이러한 제어가 필요하지 않다면 적절한 더 간단한 옵션이 있다.</para>

    <section id="aop-pfb-1">
      <title>기초</title>

      <para>다른 스프링 <literal>FactoryBean</literal> 구현체처럼 
      <literal>ProxyFactoryBean</literal>은 간접 수준(level of indirection)을 
      도입한다. <literal>foo</literal>라는 이름으로 <literal>ProxyFactoryBean</literal>를 
      정의했다면 <literal>foo</literal>를 참조하는 객체들이 보는 것은 
      <literal>ProxyFactoryBean</literal> 인스턴스 자체가 아니라 
      <literal>getObject() </literal> 메서드의 <literal>ProxyFactoryBean</literal> 
      구현체가 생성한 객체다. 이 메서드는 대상 객체를 감싸는 AOP 프록시를 생성할 것이다.</para>

      <para>AOP 프록시를 생성하는데 <literal>ProxyFactoryBean</literal>을 사용하거나 
      다른 IoC와 관련된 클래스를 사용할 때 IoC가 어드바이스와 포인트컷도 관리할 수 있다는 것이 가장 
      큰 장점이다. 다른 AOP 프레임워크와 함께 구성하는 여러운 접근을 가능하게 하는 것은 강력한 기능이다. 
      예를 들어 의존성 주입이 제공하는 플러거블(pluggability) 기능에서 얻은 이점으로 어드바이스 자체가 
      어플리케이션 객체를 참조할 것이다.(모든 AOP 프레임워크에서 사용가능해야 하는 대상객체이외에)</para>
    </section>

    <section id="aop-pfb-2">
      <title>JavaBean 프로퍼티</title>

      <para>스프링이 제공하는 대부분의 <interfacename>FactoryBean</interfacename> 
      구현체와 마찬가지로 <classname>ProxyFactoryBean</classname> 클래스 자체가 
      JavaBean이다. 이 클래스의 프로퍼티들은 다음을 할 수 있다.</para>

      <itemizedlist>
        <listitem>
          <para>프록시할 대상을 지정한다.</para>
        </listitem>

        <listitem>
          <para>CGLIB을 사용할 지를 지정한다.(아래의 내용과 
          <xref linkend="aop-pfb-proxy-types" />를 참고해라.)</para>
        </listitem>
      </itemizedlist>

      <para>몇몇 핵심 프로퍼티는 
      <classname>org.springframework.aop.framework.ProxyConfig</classname>에서 
      상속받는다. (스프링에서 모든 AOP 프록시 팩토리들의 수퍼클래스다.) 이 핵심 
      프로퍼티들은 다음과 같다.</para>

      <itemizedlist>
        <listitem>
          <para><literal>proxyTargetClass</literal>: 대상 클래스의 인터페이스가 아니라 
          대상 클래스가 프록시되었다면 <literal>true</literal>이다. 이 프로퍼티 값이 
          <literal>true</literal>이라면 CGLIB 프록시가 생성될 것이다.(하지만 
          <xref linkend="aop-pfb-proxy-types" />도 참고해라.)</para>
        </listitem>

        <listitem>
          <para><literal>optimize</literal>: <emphasis>CGLIB으로 생성된 
          프록시</emphasis>에 적극적인 최적화를 적용할 것인지를 제어한다. 적절한 AOP 
          프록시가 어떻게 최적화를 다루는 지를 완전히 이해하지 못한채로 이 설정을 그냥 사용하지는 
          말아야 한다. 이 설정은 현재 CGLIB 프록시에만 사용되고 JDK 동적 프록시에서는 아무런 
          영향이 없다.</para>
        </listitem>

        <listitem>
          <para><literal>frozen</literal>: 프록시설정이 <literal>frozen</literal>되면 
          더이상 설정을 변경할 수 없다. 이 설정은 사소한 최적화와 프록시가 생성된 후에 콜러(caller)가
          프록시(<interfacename>Advised</interfacename> 인터페이스를 통해서)를 조작할 수 
          없게 하는 경우에 유용한다. 이 프로퍼티의 기본값은 <literal>false</literal>이므로 
          부가적인 어드바이스를 추가하는 것같은 변경작업이 가능하다.</para>
        </listitem>

        <listitem>
          <para><literal>exposeProxy</literal>: 대상객체가 현재의 프록시에 접근할 수 있도록 
          현재 프록시를 <classname>ThreadLocal</classname>에 노출해야 하는지를 결정한다. 
          대상객체가 프록시를 획득해야 하고 <literal>exposeProxy</literal> 프로퍼티가 
          <literal>true</literal>로 설정되었다면 대상객체는 
          <methodname>AopContext.currentProxy()</methodname> 메서드를 
          사용할 수 있다.</para>
        </listitem>
      </itemizedlist>

      <para><classname>ProxyFactoryBean</classname>에 지정하는 
      다른 프로퍼티들은 다음과 같다.</para>

      <itemizedlist>
        <listitem>
          <para><literal>proxyInterfaces</literal>: 문자열 인터페이스 이름의 배열. 
          이 프로퍼티가 제공되지 않는다면 대상 클래스에 대한 CGLIB 프록시가 사용될 것이다.(하지만 
          <xref linkend="aop-pfb-proxy-types" />도 참고해라.)</para>
        </listitem>

        <listitem>
          <para><literal>interceptorNames</literal>: 적용할 
          <interfacename>Advisor</interfacename>나 인터셉터, 다른 어드바이스 이름의 
          문자열 배열. 순서가 중요하므로 처음 나온 것이 먼저 적용된다. 즉, 리스트의 첫 인터셉터가 
          가장 먼저 호출을 가로챌 수 있다.</para>

          <para>이름들은 조상 팩토리의 빈 이름을 포함해서 현재 팩토리의 빈 이름들이다. 여기서 
          빈 참조를 없는데 그렇게 할 경우 어드바이스의 싱글톤 설정을 무시하는 
          <classname>ProxyFactoryBean</classname>가 되기 때문이다.</para>

          <para>인터셉터 이름을 별표(<literal>*</literal>)로도 추가할 수 있다. 이는 
          어플리케이션에서 별표 앞부분으로 시작하는 이름을 가진 모든 어드바이저 빈을 적용하게 된다. 
          이 기능을 사용하는 예제를 <xref linkend="aop-global-advisors" />에서 
          볼 수 있다.</para>
        </listitem>

        <listitem>
          <para>singleton: <literal>getObject()</literal> 메서드를 얼마나 많이 
          호출했는가에 상관없이 팩토리가 하나의 객체를 반환해야 하는지를 결정한다. 다수의 
          <interfacename>FactoryBean</interfacename> 구현체가 이러한 메서드를 제공한다. 
          기본값은 <literal>true</literal>다. 상태를 가진(stateful) 어드바이스를 사용하고자 
          한다면(예를 들면 상태를 가진 믹스인) singleton 값을 <literal>false</literal>로 
          하고 프로토타입 어드바이스를 사용해라.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="aop-pfb-proxy-types">
      <title>JDK기반과 CGLIB기반의 프록시</title>

      <para>이번 섹션에서는 특정 대상객체(프록시 되어야 하는 객체)에 대해서 JDK 기반의 프록시와 
      CGLIB 기반의 프록시 중 어느 프록시를 생성할 지 <classname>ProxyFactoryBean</classname>가 
      어떻게 선택하는지에 대한 완전한 문서를 제공한다.</para>

      <note>
        <para>JDK기반과 CGLIB기반 프록시를 생성하는 것과 관련된 
        <classname>ProxyFactoryBean</classname>의 동작은 스프링 버전 1.2.x와 2.0에서 
        달라졌다. <classname>ProxyFactoryBean</classname>는 이제 
        <classname>TransactionProxyFactoryBean</classname> 클래스등처럼 자동탐지되는 
        인터페이스과 관련된 의미와 유사하다.</para>
      </note>

      <para>프록시될 대상 객체의 클래스(이후에는 대상 클래스라고 부른다.)가 어떤 인터페이스도 구현하지 
      않았다면 CGLIB 기반의 프록시가 생성될 것이다. 이는 JDK 프록시가 인터페이스 기반이라서 인터페이스가 
      없다는 것은 JDK 프록시를 적용할 수 없다는 의미이므로 가장 쉬운 시나리오다. 다른 시나리오는 대상 
      객체에 연결하고(plug) <literal>interceptorNames</literal> 프로퍼티로 인터셉터 리스트를 
      지정하는 것이다. <classname>ProxyFactoryBean</classname>의 
      <literal>proxyTargetClass</literal> 프로퍼티가 <literal>false</literal>로 
      설정되었을 때도 CGLIB 기반 프록시가 생성될 것이다. (분명히 이는 말이 안되지만 이것이 중복을 
      가장 줄여주로 혼란이 적기 때문에 빈 정의에서 제거하는 것이 가장 좋다.)</para>

      <para>대상 클래스가 하나이상의 인터페이스를 구현했다면 생성되는 프록시의 타입은 
      <classname>ProxyFactoryBean</classname> 설정에 달려있다.</para>

      <para><classname>ProxyFactoryBean</classname>의 
      <literal>proxyTargetClass</literal> 프로퍼티가 <literal>true</literal>이면 
      CGLIB기반 프록시가 생성될 것이다. 이는 논리적이고 최소놀람의 원칙(principle of least 
      surprise)을 유지한다. <classname>ProxyFactoryBean</classname>의 
      <literal>proxyInterfaces</literal> 프로퍼티가 하나이상의 정규화된 인터페이스 
      이름으로 설정되고 <literal>proxyTargetClass</literal>가 <literal>true</literal>로 
      설정되었을 때 조차도 CGLIB 기반의 프록시가 적용될 <emphasis>것이다</emphasis>.</para>

      <para><classname>ProxyFactoryBean</classname>의 
      <literal>proxyInterfaces</literal> 프로퍼티가 하나 이상의 정규화된 인터페이스 이름으로 
      지정되면 JDK기반 프록시가 생성될 것이다. 생성된 프록시는 <literal>proxyInterfaces</literal> 
      프로퍼티에 지정된 모든 인터페이스를 구현할 것이다. 대상 클래스가 
      <literal>proxyInterfaces</literal>에 지정된 것보다 훨씬 더 많은 인터페이스를 구현했다면 
      문제는 없지만 이러한 부가적인 인터페이스들은 반환되는 프록시는 구현하지 않을 것이다.</para>

      <para><classname>ProxyFactoryBean</classname>의 
      <literal>proxyInterfaces</literal> 프로퍼티를 설정하지 <emphasis>않았지만</emphasis> 
      대상 클래스가 <emphasis>하나 이상의</emphasis> 인터페이스를 구현했다면 
      <classname>ProxyFactoryBean</classname>는 대상 클래스가 실제로 최소 하나의 인터페이스를 
      구현했는지를 자동탐지해서 JDK기반 프록시를 생성할 것이다. 실제로 프록시되는 인터페이스는 대상 
      클래스가 구현한 <emphasis>모든</emphasis> 인터페이스이다. 이는 사실상 대상 클래스가 구현하는 
      각각의 인터페이스 리스트를 <literal>proxyInterfaces</literal> 프로퍼티에 제공한 것과 
      같다. 하지만 이는 현지히 적게 동작하고 오타가 날 확률이 적다.</para>
    </section>

    <section id="aop-api-proxying-intf">
      <title>프록시 인터페이스</title>

      <para>동작하는 <classname>ProxyFactoryBean</classname>의 간단한 예제를 
      보자. 이 예제는 다음을 포함하고 있다.</para>

      <itemizedlist>
        <listitem>
          <para>프록시될 <emphasis>대상 빈</emphasis>. 이 빈은 아래 예제에서 
          "personTarget" 빈 정의이다.</para>
        </listitem>

        <listitem>
          <para>어드바이스를 제공하는데 사용한 어드바이저와 인터셉터</para>
        </listitem>

        <listitem>
          <para>대상 객체(personTarget 빈)을 지정하는 AOP 프록시 빈 정의와 프록시하는 
          인터페이스와 적용할 어드바이스.</para>
        </listitem>
      </itemizedlist>

      <para><programlisting language="xml">&lt;bean id="personTarget" class="com.mycompany.PersonImpl"&gt;
    &lt;property name="name" value="Tony"/&gt;
    &lt;property name="age" value="51"/&gt;
&lt;/bean&gt;

&lt;bean id="myAdvisor" class="com.mycompany.MyAdvisor"&gt;
    &lt;property name="someProperty" value="Custom string property value"/&gt;
&lt;/bean&gt;

&lt;bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"&gt;
&lt;/bean&gt;

&lt;bean id="person" 
    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="proxyInterfaces" value="com.mycompany.Person"/&gt;

    &lt;property name="target" ref="personTarget"/&gt;
    &lt;property name="interceptorNames"&gt;
        &lt;list&gt;
            &lt;value&gt;myAdvisor&lt;/value&gt;
            &lt;value&gt;debugInterceptor&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

      <para><literal>interceptorNames</literal> 프로퍼티는 문자열의 리스트를 받는다. 
      이 리스트는 현재 팩토리의 인터셉터와 어드바이저의 빈 이름들이다. 어드바이저, 인터셉터, 
      before advice, after returning advice, throws advice 객체를 사용할 수 있다. 
      어드바이저의 순서는 중요하다.</para>

      <note>
        <para>아마도 왜 리스트가 빈 참조를 가지지 않는지 궁금할 것이다. 그 이유는 
        ProxyFactoryBean의 싱글톤 프로퍼티가 false로 설정되어있드면 개별적인 프록시 인스턴스를 
        리턴할 수 있어야 하기 때문이다. 어드바이저 중에 그 프로토타입이 있다면 개별적인 인스턴스는 
        리턴되어야 하므로 팩토리에서 프로토타입의 인스턴스를 반드시 획득할 수 있어야 한다. 레퍼런스를 
        가지고 있다면 이를 만족시키지 못한다.</para>
      </note>

      <para>위의 "person" 빈 정의를 다음과 같이 Person 구현체 대신에 
      사용할 수 있다.</para>

      <programlisting language="java">Person person = (Person) factory.getBean("person");</programlisting>

      <para>같은 IoC 컨텍스트내의 다른 빈들은 보통의 자바 객체처럼 강타입의 의존성을 빈에 
      나타낼 수 있다.</para>

      <para><programlisting language="xml">&lt;bean id="personUser" class="com.mycompany.PersonUser"&gt;
  &lt;property name="person"&gt;&lt;ref local="person"/&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

      <para>이 예제에서 <literal>PersonUser</literal> 클래스는 Person 타입의 프로퍼티를 
      노출할 것이다. 이에 관한한 AOP 프록시를 "실제" person 구현체대신에 투명하게 사용할 수 있다. 
      하지만 AOP 프록시의 클래스는 동적 프록시 클래스가 될 것이다. 이 클래스는 
      <literal>Advised</literal> 인터페이스(아래에서 설명한다)로 캐스팅 될 수 있다.</para>

      <para>다음과 같은 익명 <emphasis>내부 빈(inner bean)</emphasis>을 사용해서 
      대상객체와 프록시사이의 구별을 감출 수 있다. <literal>ProxyFactoryBean</literal> 
      정의만이 다르다. 완전함을 위해서 어드바이스만이 포함된다.</para>

      <para><programlisting language="xml">&lt;bean id="myAdvisor" class="com.mycompany.MyAdvisor"&gt;
  &lt;property name="someProperty" value="Custom string property value"/&gt;
&lt;/bean&gt;

&lt;bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"/&gt;

&lt;bean id="person" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
  &lt;property name="proxyInterfaces" value="com.mycompany.Person"/&gt;
  &lt;!-- 대상에 대한 로컬 참조말고 내부 빈을 사용해라 --&gt;
  &lt;property name="target"&gt;
    &lt;bean class="com.mycompany.PersonImpl"&gt;
      &lt;property name="name" value="Tony"/&gt;
      &lt;property name="age" value="51"/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
  &lt;property name="interceptorNames"&gt;
    &lt;list&gt;
      &lt;value&gt;myAdvisor&lt;/value&gt;
      &lt;value&gt;debugInterceptor&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

      <para>여기에는 <literal>Person</literal> 타입의 객체가 딱 하나만 존재한다는 장점이 있다. 
      어플리케이션 컨텍스트의 사용자가 어드바이즈되지 않은 객체에 대한 참조를 획득하는 것을 막거나 
      스프링 IoC의 <emphasis>자동연결(autowiring)</emphasis>의 애매모호함을 피해야할 필요가 
      있을 경우 유용하다. ProxyFactoryBean 정의가 독립적인데서 오는 확실한 장점도 있다. 하지만 
      팩토리에서 어드바이즈되지 않은 대상을 획득할 수 있는 것이 실제로 <emphasis>장점</emphasis>이 
      될 수 있는 경우가 많이 있다. 예를 들면 몇몇 테스트 시나리오가 이러한 경우이다.</para>
    </section>

    <section id="aop-api-proxying-class">
      <title>프록시 클래스</title>

      <para>하나 이상의 인터페이스가 아니라 클래스를 프록시해야 한다면?</para>

      <para>위의 예제를 생각해 보자. 이 예제에는 <literal>Person</literal> 인터페이스가 없다. 
      그래서 어떤 비즈니스 인터페이스도 구현하지 않은 <literal>Person</literal> 클래스를 
      어드바이즈해야 한다. 이 경우에 스프링이 동적 프록시 대신 CGLIB 프록시를 사용하도록 설정할 수 
      있다. 위의 ProxyFactoryBean에서 <literal>proxyTargetClass</literal> 프로퍼티를 
      true로 설정해라. 클래스보다는 인터페이스를 사용하는 것이 좋지만 인터페이스를 구현하지 않은 
      클래스를 어드바이스할 수 있는 능력은 레가시코드를 사용해야 하는 경우에 유용할 수 있다. (보통 
      스프링은 규범적이지 않다. 스프링은 좋은 사례를 적용하기 쉽게 만들면서 특정 접근을 강제하지 
      않는다.)</para>

      <para>인터페이스를 가진 경우에도 필요하다면 모든 경우에 CGLIB을 사용하도록 강제할 수 
      있다.</para>

      <para>CGLIB 프록시는 런타임시에 대상 클래스의 하위클래스를 생성해서 동작한다. 스프링은 원래 
      대상에 메서드 호출을 위임하려고 생성한 이 하위클래스를 설정한다. 하위클래스는 어드바이스에서 
      위빙을 하는 <emphasis>데코레이터</emphasis> 패턴을 구현하는데 사용한다.</para>

      <para>CGLIB 프록시는 보통 사용자에게 투명해야 한다. 하지만 고려해야할 이슈가 
      몇가지 있다.</para>

      <itemizedlist>
        <listitem>
          <para><literal>Final</literal> 메서드는 오버라이드할 수 없는 것처럼 
          어드바이즈할 수도 없다.</para>
        </listitem>

        <listitem>
          <para>클래스패스에 CGLIB 2 바이너리가 필요할 것이다. 동적 프록시는 JDK에서 
          사용할 수 있다.</para>
        </listitem>
      </itemizedlist>

      <para>CGLIB 프록시와 동적 프록시 사이에는 약간의 성능차이가 있다. 스프링 1.0에서는 동적 
      프록시가 약간 더 빠르다. 하지만 차후에는 달라질 것이다. 이 경우에 성능은 결정적인 고려사항은 
      아니어야 한다.</para>
    </section>

    <section id="aop-global-advisors">
      <title>'전역' 어드바이저 사용하기</title>

      <para>인터셉터 이름에 별표를 추가하면 별표앞의 부분과 일치하는 빈 이름을 가진 모든 어드바이저를 
      어드바이저 체인에 추가할 것이다. 이는 '전역' 어드바이저의 표준 세트에 추가해야하는 경우 쓸모가 
      있을 수 있다. <programlisting language="xml">
&lt;bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
  &lt;property name="target" ref="service"/&gt;
  &lt;property name="interceptorNames"&gt;
    &lt;list&gt;
      &lt;value&gt;global*&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="global_debug" class="org.springframework.aop.interceptor.DebugInterceptor"/&gt;
&lt;bean id="global_performance" class="org.springframework.aop.interceptor.PerformanceMonitorInterceptor"/&gt;
</programlisting></para>
    </section>
  </section>

  <section id="aop-concise-proxy">
    <title>간결한 프록시 정의</title>

    <para>특히 트랜잭션 프록시를 정의하는 경우에 유사한 프록시 정의를 많이 사용할 것이다. 내부 빈 
    정의와 함께 부모 빈 정의와 자식 빈 정의를 사용하면 프록시 정의를 더 깨끗하고 간결하게 
    만들 수 있다.</para>

    <para>먼저 부모, <emphasis>템플릿</emphasis>, 빈 정의를 프록시에 대해서 
    생성한다.</para>

    <para><programlisting language="xml">&lt;bean id="txProxyTemplate" abstract="true"
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
  &lt;property name="transactionManager" ref="transactionManager"/&gt;
  &lt;property name="transactionAttributes"&gt;
    &lt;props&gt;
      &lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

    <para>이는 스스로 인스턴스화 되지 않을 것이므로 사실 불완전하다. 대상은 어떻게든 고유하게 
    사용되지는 않을 것이므로 그 다음 생성되어야 하는 각 프록시는 내부 빈 정의로 프록시의 대상을 감싸는 
    자식 빈 정의이다.<programlisting language="xml">&lt;bean id="myService" parent="txProxyTemplate"&gt;
  &lt;property name="target"&gt;
    &lt;bean class="org.springframework.samples.MyServiceImpl"&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

    <para>물론 이번 경우처럼 부모 템플릿의 프로퍼티인 트랜잭션 전파(transaction 
    propagation) 설정을 오버라이드할 수 
    있다.<programlisting language="xml">&lt;bean id="mySpecialService" parent="txProxyTemplate"&gt;
  &lt;property name="target"&gt;
    &lt;bean class="org.springframework.samples.MySpecialServiceImpl"&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
  &lt;property name="transactionAttributes"&gt;
    &lt;props&gt;
      &lt;prop key="get*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
      &lt;prop key="find*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
      &lt;prop key="load*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
      &lt;prop key="store*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

    <para>위의 예제에서 <link linkend="beans-child-bean-definitions">앞에서</link> 
    설명했던 <emphasis>abstract</emphasis> 속성을 사용해서 부모 빈 정의를 명시적으로 
    <emphasis>abstract</emphasis>로 표시했다. 그러므로 이 빈 정의는 실제로는 인스턴스화 
    되지 않는다. 어플리케이션 컨텍스트(하지만 단순한 빈 팩토리는 아니다)는 기본적으로 미리 
    인스턴스화되어서 모두 싱글톤이다. 그러므로 탬플릿으로만 사용하려는 (부모) 빈 정의가 있다면(그리고 
    이 정의는 클래스를 지정한다.) <emphasis>abstract</emphasis> 속성을 
    <emphasis>true</emphasis>로 설정해야하고 그렇지 않으면 어플리케이션 컨텍스트가 실제로 
    이 빈을 미리 인스턴스화 하려고 시도한다는 점은 중요하다.(최소한 싱글톤 빈에 대해서는)</para>
  </section>

  <section id="aop-prog">
    <title>ProxyFactory로 AOP 프록시를 프로그래밍적으로 생성하기</title>

    <para>스프링에서 AOP 프록시를 프로그래밍적으로 생성하는 것은 쉽다. 이는 스프링 IoC에 대한 
    의존성없이 스프링 AOP를 사용할 수 있게 한다.</para>

    <para>다음의 리스트는 하나의 인터셉터와 하나의 어드바이저를 가진 대상 객체에 대한 프록시 생성을 
    보여준다. 대상객체가 구현한 인터페이스는 자동적으로 프록시될 것이다.</para>

    <para><programlisting language="java">ProxyFactory factory = new ProxyFactory(myBusinessInterfaceImpl);
factory.addAdvice(myMethodInterceptor);
factory.addAdvisor(myAdvisor);
MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();</programlisting></para>

    <para>첫 단계는 <literal>org.springframework.aop.framework.ProxyFactory</literal> 
    타입의 객체를 생성하는 것이다. 위의 예제처럼 대상객체와 함께 이를 생성하거나 대체 생성자(alternate 
    constructor)에서 프록시되는 인터페이스를 지정할 수 있다.</para>

    <para>어드바이스(어드바이스의 특수한 종류인 인터셉터와 함께)와 어드바이저를 추가할 수 있고 
    ProxyFactory가 살아있는 동안 이들을 조작할 수 있다. 
    IntroductionInterceptionAroundAdvisor를 추가했다면 프록시가 부가적인 인터페이스를 
    구현하도록 할 수 있다.</para>

    <para>ProxyFactory(<classname>AdvisedSupport</classname>에서 상속받은)에는 
    before advice와 throws advice같은 다른 어드바이스 타입을 추가하도록 하는 편리한 
    메서드도 존재한다. AdvisedSupport는 ProxyFactory와 ProxyFactoryBean의 
    수퍼클래스이다.</para>

    <tip>
      <para>AOP 프록시 생성과 IoC 프레임워크를 통합하는 것은 대부분의 어플리케이션에서 
      좋은 사용사례이다. 일반적으로 AOP를 가진 자바코드에서 설정을 분리해내는 것을 
      권장한다.</para>
    </tip>
  </section>

  <section id="aop-api-advised">
    <title>어드바이즈된 객체 조작하기</title>

    <para>AOP 프록시를 생성했더라도 
    <literal>org.springframework.aop.framework.Advised</literal> 인터페이스를 
    사용해서 프록시를 조작할 수 있다. 다른 인터페이스가 이 인터페이스를 구현했더라도 모든 AOP프록시는 
    이 인터페이스로 캐스트할 수 있다. 이 인터페이스는 다음 메서드를 포함하고 있다.</para>

    <programlisting language="java">Advisor[] getAdvisors();

void addAdvice(Advice advice) throws AopConfigException;

void addAdvice(int pos, Advice advice) 
        throws AopConfigException;

void addAdvisor(Advisor advisor) throws AopConfigException;

void addAdvisor(int pos, Advisor advisor) throws AopConfigException;

int indexOf(Advisor advisor);

boolean removeAdvisor(Advisor advisor) throws AopConfigException;

void removeAdvisor(int index) throws AopConfigException;

boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException;

boolean isFrozen();</programlisting>

    <para><literal>getAdvisors()</literal> 메서드는 팩토리에 추가된 모든 어드바이저, 
    인터셉터, 다른 어드바이스 타입에 대해서 Advisor를 반환할 것이다. Advisor를 추가했다면 이 
    위치에서 반환된 어드바이저는 추가한 객체가 될 것이다. 인터셉터나 다른 어드바이스 타입을 추가했다면 
    스프링은 항상 true를 반환하는 포인트컷을 가진 어드바이저에서 이를 감쌀것이다. 그러므로 
    <literal>MethodInterceptor</literal>를 추가했다면 이 위치에서 반환된 어드바이저는 
    <literal>MethodInterceptor</literal>와 모든 클래스와 메서드와 일치하는 포인트컷을 
    반환하는 <literal>DefaultPointcutAdvisor</literal>가 될 것이다.</para>

    <para><literal>addAdvisor()</literal> 메서드는 어떤 Advisor라도 추가하는데 사용할 
    수 있다. 보통은 포인트컷과 어드바이스를 가진 어드바이저는 어떤 어드바이스나 포인트컷(하지만 
    인트로덕션과는 아니다)과도 사용할 수 있는 일반적인 
    <literal>DefaultPointcutAdvisor</literal>가 될 것이다.</para>

    <para>기본적으로 일단 프록시가 생성된 후에도 어드바이저나 인터셉터를 추가하거나 제거할 수 있다. 
    유일한 제약사항은 팩토리에 존재하는 프록시가 인터페이스 변경을 보지 못하는 것처럼 인트로덕션 
    어드바이저를 추가하거나 제거할 수 없다. (이 문제를 피하기 위해서 팩토리에서 새로운 프록시를 
    획득할 수 있다.)</para>

    <para>다음은 AOP 프록시를 <literal>Advised</literal> 인터페이스로 캐스팅하고 
    그 어드바이스를 검사하고 조작하는 간단한 예제이다.</para>

    <para><programlisting language="java">Advised advised = (Advised) myObject;
Advisor[] advisors = advised.getAdvisors();
int oldAdvisorCount = advisors.length;
System.out.println(oldAdvisorCount + " advisors");

// 포인트컷없이 인터셉터처럼 어드바이스를 추가해라
// 프록시된 모든 메서드를 매칭할 것이다
// 인터셉터, before advice, after returning advice, throws advice에 대해 사용할 수 있다
advised.addAdvice(new DebugInterceptor());

// 포인트컷을 사용해서 선택적으로 어드바이스를 추가한다
advised.addAdvisor(new DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));

assertEquals("Added two advisors",
     oldAdvisorCount + 2, advised.getAdvisors().length);</programlisting></para>

    <note>
      <para>분명히 정당한 사용이라고 하더라도 프로덕션단계에서 비즈니스 객체의 어드바이스를 수정하는 
      것이 합당한가에 대해서 의문이 있을 수 있다. 하지만 개발단계에서는 아주 유용할 수 있다. 예를 
      들면 테스트의 경우이다. 테스트하려는 메서드 호출내부에서 얻은 인터셉터나 다른 어드바이스의 
      형식으로 테스트 코드를 추가할 수 있다는 것이 아주 유용하다는 것을 종종 발견한다. (예를 들어 
      어드바이스가 해당 메서드에 대해 생성된 트랜잭션안으로 들어갈 수 있다. 또는 트랜잭션을 롤백하기 
      이전에 데이터베이스가 제대로 갱신되었는지 검사하는 SQL을 실행할 수 있다.)</para>
    </note>

    <para>어떻게 프록시를 생성했는가에 따라 <literal>frozen</literal> 플래그를 보통 설정할 
    수 있다. <literal>frozen</literal> 플래그를 설정한 경우 <literal>Advised</literal> 
    <literal>isFrozen()</literal> 메서드는 항상 true를 반환할 것이다. 추가나 제거로 어드바이스를 
    수정하려는 어떤 시도도 <literal>AopConfigException</literal>가 발생할 것이다. 어드바이즈된 
    객체의 상태를 고정시키는 이 기능은 몇몇 경우에 유용하다. 예를 들면 보안 인터셉터를 제거하는 코드의 
    호출을 차단할 수 있다. 알려진 런타입 어드바이스 수정이 필요하지 하지 않은 경우 적극적인 최적화를 
    위해서 스프링 1.1에서도 사용할 수 있다.</para>
  </section>

  <section id="aop-autoproxy">
    <title>"autoproxy" 기능 사용하기</title>

    <para>지금까지 <literal>ProxyFactoryBean</literal>나 유사한 팩토리빈을 사용해서 
    명시적으로 프록시를 생성하는 방법을 살펴보았다.</para>

    <para>스프링도 선택한 빈 정의를 자동으로 프록시할 수 있는 "autoproxy" 빈정의를 사용할 수 
    있게 한다. 이 기능은 컨테이너 로딩처럼 모든 빈 정의를 수정할 수 있는 스프링의 
    "bean post processor" 인프라에 기반을 두고 있다.</para>

    <para>이 모델에서 자동 프록시 인프라스트럭처를 설정하려고 XML 빈 정의 파일에 몇가지 특수한 빈 
    정의를 설정했다. 이는 자동프록시에 알맞는 대상을 선언할 수 있게 한다. 
    <literal>ProxyFactoryBean</literal>를 사용할 필요가 없다.</para>

    <para>이것을 하는 두가지 방법이 있다.</para>

    <itemizedlist>
      <listitem>
        <para>현재 컨텍스트에서 특정 빈을 참조하는 autoproxy creator의 사용.</para>
      </listitem>

      <listitem>
        <para>별도로 생각할 수 있는 자동프록시 생성의 특수한 경우. 자동프록시 생성은 
        소스수준의 메타데이터 속성으로 만들어진다.</para>
      </listitem>
    </itemizedlist>

    <section id="aop-autoproxy-choices">
      <title>자동프록시 빈 정의</title>

      <para><literal>org.springframework.aop.framework.autoproxy</literal> 
      패키지는 다음의 표준 자동프록시 생성자(creator)를 제공한다.</para>

      <section id="aop-api-autoproxy">
        <title>BeanNameAutoProxyCreator</title>

        <para><literal>BeanNameAutoProxyCreator</literal> 클래스는 리터럴 값이나 
        와일드카드와 일치하는 이름을 가진 빈에 대한 AOP 프록시를 자동으로 생성하는 
        <literal>BeanPostProcessor</literal>이다.</para>

        <para><programlisting language="xml">&lt;bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt;
  &lt;property name="beanNames" value="jdk*,onlyJdk"/&gt;
  &lt;property name="interceptorNames"&gt;
    &lt;list&gt;
      &lt;value&gt;myInterceptor&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

        <para><literal>ProxyFactoryBean</literal>가 그렇듯이 프로토타입 어드바이저에 
        올바른 행위를 하도록 하는 인터셉터의 리스트 대신 <literal>interceptorNames</literal> 
        프로퍼티가 있다. 지명된 "interceptors"는 어드바이저나 어떤 어드바이스 타입이라도 
        될 수 있다.</para>

        <para>보통 자동 프록시가 그렇듯이 <literal>BeanNameAutoProxyCreator</literal>를 
        사용하는 핵심관점은 최소한의 설정으로 여러 객체에 하나의 설정을 일관성있게 적용하려는 것이다. 
        이는 여러 객체에 선언적 트랜잭선을 적용할 때 선호하는 선택이다.</para>

        <para>위의 예제에서 "jdkMyBean"와 "onlyJdk"처럼 이름이 일치한 빈 정의는 대상클래스의 
        평범한 빈 정의(plain old bean definition)이다. 
        <literal>BeanNameAutoProxyCreator</literal>가 자동적으로 AOP 프록시를 생성할 
        것이다. 같은 어드바이스가 매칭된 모든 빈에 적용될 것이다. 어드바이저를 사용했다면(위의 예제에서 
        인터셉터 대신에) 포인트컷은 다른 빈에 다르게 적용될 것이다.</para>
      </section>

      <section id="aop-api-autoproxy-default">
        <title>DefaultAdvisorAutoProxyCreator</title>

        <para><literal>DefaultAdvisorAutoProxyCreator</literal>는 더 일반적이고 
        아주 강력한 자동 프록시 생성자이다. 이 생성자는 자동프록시 어드바이저의 빈 정의에서 특정 
        빈 이름을 포함하지 않고도 현재 컨텍스트에서 적합한 어드바이저를 마법처럼(automagically) 
        적용할 것이다. 이는 일관성있는 설정과 <literal>BeanNameAutoProxyCreator</literal>같은 
        중복제거의 이점과 같은 이점을 제공한다.</para>

        <para>이 메카니즘을 사용하는 것은 다음을 포함한다.</para>

        <itemizedlist>
          <listitem>
            <para><literal>DefaultAdvisorAutoProxyCreator</literal> 
            빈 정의를 지정함.</para>
          </listitem>

          <listitem>
            <para>같은 컨텍스트 혹은 관계된 컨텍스트에 다수의 Advisor를 지정함. 이들은 인터셉터나 
            다른 어드바이스가 아닌 <emphasis>반드시</emphasis> Advisor여야 한다. 후보 빈 
            정의에 대한 각 어드바이스의 자격을 검사하기 위해 평가할 포인트컷이 있어야 하기 때문에 
            이 어드바이저는 필수적이다.</para>
          </listitem>
        </itemizedlist>

        <para><literal>DefaultAdvisorAutoProxyCreator</literal>는 각 비즈니스 
        객체(예제의 "businessObject1"와 "businessObject2"같은)에 어떤 어브다이스를
        (존재한다면) 적용해야 하는지 알기 위해 각 어드바이저에 있는 포인트컷을 자동적으로 
        평가할 것이다.</para>

        <para>이는 자동으로 각 비즈니스 객체에 다수의 어드바이저를 적용할 수 있다는 말이다. 
        어느 어드바이저의 포인트컷도 비즈니스 객체의 매서드와 일치하는 것이 없다면 객체는 프록시되지 
        않을 것이다. 새로운 비즈니스 객체에 빈 정의를 추가했을 때 필요하다면 자동으로 프록시 
        될 것이다.</para>

        <para>보통 자동프록시는 호출자(caller)나 의존성이 어드바이즈되지 않은 객체를 획득할 수 
        없게 하는 장점이 있다. 이 ApplicationContext에서 getBean("businessObject1")을 
        호출하면 대상 비즈니스 객체가 아니라 AOP 프록시를 반환할 것이다.(앞에서 나온 
        "내부 빈(inner bean)"도 이 장점을 제공한다.)</para>

        <para><programlisting language="xml">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt;

&lt;bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
  &lt;property name="transactionInterceptor" ref="transactionInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="customAdvisor" class="com.mycompany.MyAdvisor"/&gt;

&lt;bean id="businessObject1" class="com.mycompany.BusinessObject1"&gt;
  &lt;!-- Properties omitted --&gt;
&lt;/bean&gt;

&lt;bean id="businessObject2" class="com.mycompany.BusinessObject2"/&gt;
</programlisting></para>

        <para>많은 비즈니스 객체에 같은 어드바이스를 일관성있게 적용하려는 경우 
        <literal>DefaultAdvisorAutoProxyCreator</literal>가 아주 유용하다. 일단 
        인프라스트럭처 정의가 제 위치에 있다면 구체적인 프록시 설정을 포함하지 않고도 새로운 비즈니스 
        객체를 쉽게 추가할 수 있다. 부가적인 관점도 설정을 최소한으로 변경하면서 아주 쉽게 추가할 
        수 있다.(예를 들면 추적하거나 성능을 모니터링하느 관점)</para>

        <para>DefaultAdvisorAutoProxyCreator는 필터링과 정렬을 지원한다. (같은 팩토리의 
        AdvisorAutoProxyCreator의 특정 어드바이저들만 평가하고 여러 용도로 사용하고 다르게 
        설정하기 위해 작명 관례를 사용해서) 이슈가 있는 경우에 정렬을 제대로 하기 위해 어드바이저가 
        <literal>org.springframework.core.Ordered</literal>를 구현할 수 있다. 위의 
        예제에서 사용한 TransactionAttributeSourceAdvisor에는 설정할 수 있는 order값이 
        있다. 기본 설정은 정렬하지 않는 것이다.</para>
      </section>

      <section id="aop-api-autoproxy-abstract">
        <title>AbstractAdvisorAutoProxyCreator</title>

        <para>DefaultAdvisorAutoProxyCreator의 수퍼클래스다. 어드바이저 정의가 프레임워크의 
        동작을 충분하게 커스터마이징하지 못할 때 이 
        <literal>DefaultAdvisorAutoProxyCreator</literal> 클래스의 하위클래스를 
        만들어서 자신만의 오토프록시 생성자(creator)를 만들 수 있다.</para>
      </section>
    </section>

    <section id="aop-autoproxy-metadata">
      <title>메타데이터 주도 오토프록시 사용하기</title>

      <para>오토프록시의 특히 중요한 타입은 메타데이터에 주도된다. 이는 .NET 
      <literal>ServicedComponents</literal>과 유사한 프로그래밍 모델을 만든다. 
      EJB에서 처럼 XML 배포 디스크립터를 사용하는 대신에 소스수준의 속성으로 트랜잭션 관리와 
      다른 엔터프라이즈 서비스에 대한 설정을 유지한다.</para>

      <para>이 경우에 메타데이터 속성을 이해하는 어드바이저와 결합해서 
      <literal>DefaultAdvisorAutoProxyCreator</literal>를 사용한다. 메타데이터를 
      오토프록시 생성 클래스 자체가 가지는 대신 후보 어드바이저들의 포인트컷 부분이 메타데이터를 
      가진다.</para>

      <para>이는 실제로 <literal>DefaultAdvisorAutoProxyCreator</literal>의 특수한 
      경우이지만 독립적으로 고려할 만 하다.(메타데이터 친화적인 코드는 AOP 프레임워크 자체가 
      아니라 어드바이저들의 포인트컷이 담고 있다.)</para>

      <para>JPetStore 샘플 어플리케이션의 <literal>/attributes</literal> 디렉토리는 
      속성주도 오토프록시의 사용방법을 보여준다. 이 경우에는 
      <literal>TransactionProxyFactoryBean</literal>를 사용할 필요가 없다. 메타데이터 
      친화적인 포인트컷을 사용하기 때문에 비즈니스 객체에서 transactional 속성을 정의하는 것만으로도 
      충분하다. <literal>/WEB-INF/declarativeServices.xml</literal>의 빈 정의는 다음의 
      코드를 포함하고 있다. 이는 일반적이고 JPetStore 외부에서도 사용할 수 있다.</para>

      <para><programlisting language="xml">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt;

&lt;bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
  &lt;property name="transactionInterceptor" ref="transactionInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionInterceptor"
    class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;
  &lt;property name="transactionManager" ref="transactionManager"/&gt;
  &lt;property name="transactionAttributeSource"&gt;
    &lt;bean class="org.springframework.transaction.interceptor.AttributesTransactionAttributeSource"&gt;
      &lt;property name="attributes" ref="attributes"/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="attributes" class="org.springframework.metadata.commons.CommonsAttributes"/&gt;</programlisting></para>

      <para><literal>DefaultAdvisorAutoProxyCreator</literal> 빈 정의(이름은 중요하지 
      않으므로 생략할 수도 있다)는 현재 어플리케이션 컨텍스트에서 적절한 포인트컷을 모두 선택할 것이다. 
      이 경우에 <literal>TransactionAttributeSourceAdvisor</literal> 타입의 
      "transactionAdvisor" 빈 정의를 transaction 속성을 가진 클래스나 메서드에 적용할 것이다. 
      TransactionAttributeSourceAdvisor는 생성자 의존성을 통해서 TransactionInterceptor에 
      의존한다. 예제는 자동연결(autowiring)로 이 문제를 해결한다. 
      <literal>AttributesTransactionAttributeSource</literal>는 
      <literal>org.springframework.metadata.Attributes</literal> 인터페이스의 
      구현체에 의존한다. 이 부분에서 "attributes" 빈은 속성 정보를 얻기 위해 Jakarta Commons 
      Attributes API를 사용해서 이를 만족시킨다. (어플리케이션 코드는 반드시 Commons Attributes 
      컴파일 작업을 사용해서 컴파일되어야 한다.)</para>

      <para>JPetStore 샘플 어플리케이션의 <literal>/annotation</literal> 디렉토리에는 
      JDK 1.5+ 어노테이션을 사용한 오토프록시와 유사한 예제가 있다. 다음 설정은 스프링의 
      <literal>Transactional</literal> 어노테이션을 자동으로 탐지할 수 있게 해서 해당 
      어노테이션이 붙은 빈을 암묵적으로 프록시하게 된다.</para>

      <para><programlisting language="xml">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt;

&lt;bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
  &lt;property name="transactionInterceptor" ref="transactionInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionInterceptor"
    class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;
  &lt;property name="transactionManager" ref="transactionManager"/&gt;
  &lt;property name="transactionAttributeSource"&gt;
    &lt;bean class="org.springframework.transaction.annotation.AnnotationTransactionAttributeSource"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

      <para>여기서 정의한 <literal>TransactionInterceptor</literal>는 
      <literal>PlatformTransactionManager</literal> 정의에 의존하고 있다. 
      <literal>PlatformTransactionManager</literal>는 어플리케이션의 트랜잭션 
      요구사항(일반적으로는 이 예제처럼 JTA이고 그 외 Hibernate, JDO, JDBC이다.)에 지정될 
      것이므로 이 일반적인 파일에는 포함되어 있지 않다.(가능하기는 하지만)</para>

      <programlisting language="xml">&lt;bean id="transactionManager" 
    class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;</programlisting>

      <tip>
        <para>선언적인 트랜잭션 관리만 필요한 경우 이러한 일반적인 XML 정의를 사용하면 스프링이 
        transaction 속성이 있는 모든 클래스와 메서드를 자동으로 프록시할 것이다. AOP로 직접 
        작업할 필요가 없고 프로그래밍 모델은 .NET ServicedComponents의 프로그래밍 모델과 
        유사하다.</para>
      </tip>

      <para>이 메카니즘은 확장할 수 있다. 커스텀 속성에 기반해서 오토프록시를 할 수 있다. 
      이렇게 하려면 다음의 과정이 필요한다.</para>

      <itemizedlist>
        <listitem>
          <para>커스텀 속성을 정의해라.</para>
        </listitem>

        <listitem>
          <para>클래스나 메서드에 커스텀 속성이 있어서 발생하는 포임트컷을 포함해서 필수 
          어드바이스를 가진 Advisor를 지정해라. 커스텀 속성을 선택하는 정적 포인트컷을 구현한 
          이미 존재하는 어드바이스를 사용할 수도 있다.</para>
        </listitem>
      </itemizedlist>

      <para>이러한 어드바이저들이 각각의 어드바이즈된 클래스에 유일하도록 할 수 있다.(예를 들면 믹스인) 
      이 어드바이저들은 싱글톤 대신 프로토타입 빈 정의로 정의되어야 한다. 예를 들어 앞에서 나왔던 스프링 
      테스트 슈트의 <literal>LockMixin</literal> 인트로덕션 인터셉터를 여기서 보여주듯 믹스인할 
      속성주도 포인트컷과 결합하는데 사용할 수 있다. JavaBean 프로퍼티로 설정한 일반적인 
      <literal>DefaultPointcutAdvisor</literal>를 사용한다.</para>

      <para><programlisting language="xml">&lt;bean id="lockMixin" class="org.springframework.aop.LockMixin"
    scope="prototype"/&gt;

&lt;bean id="lockableAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor"
    scope="prototype"&gt;
  &lt;property name="pointcut" ref="myAttributeAwarePointcut"/&gt;
  &lt;property name="advice" ref="lockMixin"/&gt;
&lt;/bean&gt;

&lt;bean id="anyBean" class="anyclass" ...</programlisting></para>

      <para>속성을 이해하는 포인트컷이 <literal>anyBean</literal>이나 다른 빈 정의의 어떤 
      메서드와 일치한다면 믹스인이 적용될 것이다. <literal>lockMixin</literal>와 
      <literal>lockableAdvisor</literal>는 둘다 프로토타입이다. 
      <literal>myAttributeAwarePointcut</literal> 포인트컷은 어드바이즈된 개별 객체가 
      상태를 유지하지 않기 때문에 싱글톤 정의가 될 수 있다.</para>
    </section>
  </section>

  <section id="aop-targetsource">
    <title>TargetSources 사용하기</title>

    <para>스프링은 <literal>org.springframework.aop.TargetSource</literal>에 나타난 
    <emphasis>TargetSource</emphasis>의 개념을 제공한다. 이 인터페이스는 조인포인트를 구현한 
    "대상 객체"를 반환하는 역할을 한다. <literal>TargetSource</literal> 구현체는 AOP 
    프록시가 메서드 호출을 다룰 때마다 대상 인스턴스를 요청한다.</para>

    <para>스프링 AOP를 사용하는 개발자들이 TargetSource를 직접 다룰 필요는 보통 없지만 풀링, 
    핫 스왓, 다른 세련된 대상등을 지원하는 강력한 기능을 제공한다. 예를 들어 풀링 TargetSource는 
    인스턴스를 관리하는 풀(pool)을 사용해서 호출시마다 다른 대상 인스턴스를 반환할 수 있다.</para>

    <para>TargetSource를 지정하지 않으면 지역(local) 객체를 감싸는 기본 구현체를 사용한다. 
    각 호출시마다(기대하는 대로) 같은 객체를 반환한다.</para>

    <para>스프링이 제공하는 표준 대상 소스(target source)를 살펴보고 어떻게 사용할 수 있는지 
    알아보자.</para>

    <tip>
      <para>커스텀 대상 소스를 사용하는 경우 대상은 보통 싱글톤 빈 정의가 아니라 
      프로토타입 빈 정의가 되어야 할 것이다. 이는 요청했을 때 스프링이 새로운 대상 
      인스턴스를 생성할 수 있게 한다.</para>
    </tip>

    <section id="aop-ts-swap">
      <title>핫 스왑이 가능한 대상 소스</title>

      <para>호출자(caller)가 AOP 프록시의 대상에 대한 참조를 유지하는 동안 AOP 프록시의 대상을 
      교체할 수 있도록 
      <literal>org.springframework.aop.target.HotSwappableTargetSource</literal>가 
      존재한다.</para>

      <para>대상 소스의 대상을 변경한 효과는 즉각적으로 일어난다. 
      <literal>HotSwappableTargetSource</literal>는 쓰레드세이프하다.</para>

      <para>다음과 같이 HotSwappableTargetSource의 <literal>swap()</literal>
      메서드로 대상을 변경할 수 있다.</para>

      <para><programlisting language="java">HotSwappableTargetSource swapper = 
    (HotSwappableTargetSource) beanFactory.getBean("swapper");
Object oldTarget = swapper.swap(newTarget);</programlisting></para>

      <para>필요한 XML 정의는 다음과 같다.</para>

      <para><programlisting language="xml">&lt;bean id="initialTarget" class="mycompany.OldTarget"/&gt;

&lt;bean id="swapper" class="org.springframework.aop.target.HotSwappableTargetSource"&gt;
  &lt;constructor-arg ref="initialTarget"/&gt;
&lt;/bean&gt;

&lt;bean id="swappable" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
  &lt;property name="targetSource" ref="swapper"/&gt;
&lt;/bean&gt;</programlisting></para>

      <para>위의 <literal>swap()</literal> 호출은 스왑가능한 빈의 대상을 변경한다. 
      이 빈에 대한 참조를 가진 클라이언트들은 변경을 알아차리지 못하지만 즉시 새로운 대상을 
      만날 것이다.</para>

      <para>이 예제에서는 어떤 어드바이스도 추가하지 않았지만(<literal>TargetSource</literal>를 
      사용하는데 어드바이스를 추가해야 할 필요는 없다.) 당연히 모든 
      <literal>TargetSource</literal>는 임의의 어드바이스와 결합해서 사용할 수 있다.</para>
    </section>

    <section id="aop-ts-pool">
      <title>대상 소스 풀링</title>

      <para>대상 소스의 풀링을 사용하면 상태가 없는 세션 EJB와 유사한 프로그래밍 모델을 제공한다. 
      이 프로그래밍 모델은 동일한 인스턴스의 풀을 유지하고 메서드 호출로 풀에서 객체를 가져온다.</para>

      <para>스프링 풀링과 SLSB 풀링사이의 결정적인 차이점은 스프링 풀링은 어떤 POJO라도 적용할 수 
      있다는 것이다. 보통 스프링이 하듯이 이는 비 침략적인 방법을 적용할 수 있다.</para>

      <para>스프링은 상당히 능률적인 풀링 구현체를 제공하는 Jakarta Commons Pool 1.3을 지원한다. 
      이 기능을 사용하려면 어플리케이션의 클래스패스에 commons-pool Jar가 필요하다. 다른 풀링 API를 
      지원하기 위해서 
      <literal>org.springframework.aop.target.AbstractPoolingTargetSource</literal>의 
      하위클래스를 만드는 것도 가능하다.</para>

      <para>다음은 설정 예시이다.</para>

      <para><programlisting language="xml">&lt;bean id="businessObjectTarget" class="com.mycompany.MyBusinessObject" 
    scope="prototype"&gt;
  ... properties omitted
&lt;/bean&gt;

&lt;bean id="poolTargetSource" class="org.springframework.aop.target.CommonsPoolTargetSource"&gt;
  &lt;property name="targetBeanName" value="businessObjectTarget"/&gt;
  &lt;property name="maxSize" value="25"/&gt;
&lt;/bean&gt;

&lt;bean id="businessObject" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
  &lt;property name="targetSource" ref="poolTargetSource"/&gt;
  &lt;property name="interceptorNames" value="myInterceptor"/&gt;
&lt;/bean&gt;</programlisting></para>

      <para>대상 객체(이 예제에서는 "businessObjectTarget")는 <emphasis>반드시</emphasis> 
      프로토타입이어야 한다. 이는 <literal>PoolingTargetSource</literal> 구현체가 필요에 
      따라 풀의 크기를 조절하기 위해서 대상의 새로운 인스턴스를 생성할 수 있도록 한다. 
      <literal>AbstractPoolingTargetSource</literal>의 프로퍼티에 대한 정보는 
      <literal>AbstractPoolingTargetSource</literal> javadoc과 구현된 하위클래스를 
      참고해라. 프로피티 중 "maxSize"가 가장 기본적인 프로퍼티이고 항상 존재한다는 것을 
      보장한다.</para>

      <para>이 경우에 "myInterceptor"는 같은 IoC 컨텍스트에서 정의되어야 하는 인터셉터의 이름이다. 
      하지만 풀링을 사용하려고 인터셉터를 지정할 필요는 없다. 다른 어드바이스는 필요없고 풀링만을 
      사용하고자 한다면 interceptorNames 프로퍼티를 아예 설정하지 말아라.</para>

      <para>풀에 있는 어떤 객체라도 
      <literal>org.springframework.aop.target.PoolingConfig</literal> 인터페이스로 
      캐스팅할 수 있도록 스프링을 설정할 수 있다. 이 인터페이스는 인트로덕션을 통해서 설정과 현재 풀의 
      크기에 대한 정보를 노출한다. 다음과 같이 어드바이저를 정의해야 한다.</para>

      <para><programlisting language="xml">&lt;bean id="poolConfigAdvisor" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="targetObject" ref="poolTargetSource"/&gt;
  &lt;property name="targetMethod" value="getPoolingConfigMixin"/&gt;
&lt;/bean&gt;</programlisting></para>

      <para><literal>AbstractPoolingTargetSource</literal> 클래스의 편리한 메서드를 
      호출해서 즉, MethodInvokingFactoryBean를 사용해서 이 어드바이저를 얻어올 수 있다. 
      이 어드바이저의 이름은(여기서는 "poolConfigAdvisor") 풀에 있는 객체를 노출하는 
      ProxyFactoryBean의 인터셉터 이름 목록에 있어야 한다.</para>

      <para>캐스팅은 다음과 같을 것이다.</para>

      <programlisting language="java">PoolingConfig conf = (PoolingConfig) beanFactory.getBean("businessObject");
System.out.println("Max pool size is " + conf.getMaxSize());</programlisting>

      <note>
        <para>보통 상태가 없는 서비스 객체들을 풀링할 필요는 없다. 상태를 갖지 않는 대부분의 객체들은 
        자연히 쓰레드세이프하기 때문에 풀링하는 것이 기본적인 선택이어야 한다고 생각하지 않고 리소스가 
        캐싱되는 경우 인스턴스 풀링은 문제의 소지가 있다.</para>
      </note>

      <para>자동프록시를 사용해서 더 간단한 풀링을 사용할 수 있다. 자동프록시 생성자(autoproxy 
      creator)가 사용하는 TargetSources를 설정할 수 있다.</para>
    </section>

    <section id="aop-ts-prototype">
      <title>프로토타입 대상 소스</title>

      <para>"prototype" 대상소스를 설정하는 것은 TargetSource를 풀링하는 것과 비슷하다. 
      이 경우에 메서드 호출시마다 대상의 새로운 인스턴스를 생성할 것이다. 최신(modern) JVM에서는 
      새로운 객체를 생성하는 비용이 크지 않지만 새로운 객체를 연결하는 비용은(객체의 IoC 의존성을 
      만족시키는) 아마 좀 더 비쌀 것이다. 그러므로 타당한 이유가 없다면 이 접근을 사용하지 
      말아야 한다.</para>

      <para>프로토타입 대상 소스를 설정하기 위해서 위에 나온 <literal>poolTargetSource</literal> 
      정의를 다음과 같이 수정할 수 있다.(명확함을 위해서 이름도 변경했다.)</para>

      <programlisting language="xml">&lt;bean id="prototypeTargetSource" class="org.springframework.aop.target.PrototypeTargetSource"&gt;
  &lt;property name="targetBeanName" ref="businessObjectTarget"/&gt;
&lt;/bean&gt;</programlisting>

      <para>여기에는 대상 빈의 이름을 위한 딱 하나의 프로퍼티만 존재한다. 일관성 있는 작명을 
      보장하기 위해서 TargetSource 구현체는 상속을 사용한다. 대상 소스를 풀링하는 것처럼 
      대상 빈은 프로토타입 빈 정의여야 한다.</para>
    </section>

    <section id="aop-ts-threadlocal">
      <title><classname>ThreadLocal</classname> 대상 소스</title>

      <para>요청이 들어올때마다 객체를 생성해야할 때(쓰레드마다) 
      <classname>ThreadLocal</classname> 대상 소스가 유용하다. 
      <classname>ThreadLocal</classname>의 개념은 쓰레드에 투명하게 리소스를 저장하는 JDK 
      범위의 기능을 제공한다. <classname>ThreadLocalTargetSource</classname>을 설정하는 
      방법은 다른 타입의 대상소스에서 설명한 것과 거의 같다.</para>

      <programlisting language="xml">&lt;bean id="threadlocalTargetSource" class="org.springframework.aop.target.ThreadLocalTargetSource"&gt;
  &lt;property name="targetBeanName" value="businessObjectTarget"/&gt;
&lt;/bean&gt;</programlisting>

      <note>
        <para>멀티쓰레드 환경이나 멀티-클래스로더 환경에서 ThreadLocal을 잘못 사용할 때 심각한 
        이슈가 있다.(잠재적으로 메모리 누수가 있을 수 있다.) 항상 다른 클래스에 쓰레드로컬을 감싸고 
        <classname>ThreadLocal</classname> 자체를 직접 사용하는 않는 것을 고려해야 한다.
        (물론 랩퍼(wrapper) 클래스는 제외하고) 그리고 쓰레드에 리소스로컬을 제대로 설정하고 
        설정해제해야 한다.(설정해제는 <literal>ThreadLocal.set(null)</literal>를 호출하는 
        것을 말한다) 설정해제를 사지 않으면 문제의 소지가 있는 동작이 일어날 수 있으므로 설정해제는 
        항상 해주어야 한다. 스프링의 ThreadLocal 지원은 개발자를 위해서 이것을 해주고 달리 코드를 
        적절하게 다루지 않도로 ThreadLocal을 사용하는 것은 항상 생각해야한다.</para>
      </note>
    </section>
  </section>

  <section id="aop-extensibility">
    <title>새로운 <interfacename>Advice</interfacename> 타입 정의하기</title>

    <para>스프링 AOP는 확장할 수 있도록 설계되었다. 내부적으로 인터셉션 구현체 전략(interception 
    implementation strategy)을 사용하고 있기 때문에 interception around advice, 
    before advice, throws advice, after returning advice에 추가로 임의의 어드바이스 
    타입을 지원하는 것이 가능하다.</para>

    <para><literal>org.springframework.aop.framework.adapter</literal> 패키지는 
    코어 프레임워크를 수정하지 않고 새로운 커스텀 어드바이스 타입을 추가할 수 있도록 하는 SPI 패키지이다. 
    커스텀 <interfacename>Advice</interfacename> 타입의 유일한 제약사항은 
    <interfacename>org.aopalliance.aop.Advice</interfacename> 태그 인터페이스를 반드시 
    구현해야 한다는 것 뿐이다.</para>

    <para>더 자세한 정보는 <literal>org.springframework.aop.framework.adapter</literal> 
    패키지의 javadoc을 참고해라.</para>
  </section>

  <section id="aop-api-resources">
    <title>추가적인 리소스</title>

    <para>스프링 AOP의 더 많은 예제를 보려면 스프링 샘플 어플리케이션을 참고해라.</para>

    <itemizedlist>
      <listitem>
        <para>JPetStore의 기본 설정은 선언적인 트랜잭션 관리를 위한 
        <classname>TransactionProxyFactoryBean</classname>의 사용방법을 설명한다.</para>
      </listitem>

      <listitem>
        <para>JPetStore의 <literal>/attributes</literal> 디렉토리는 속성주도 선언적인 
        트랜잭션 관리의 사용방법을 설명한다.</para>
      </listitem>
    </itemizedlist>
  </section>
</chapter>
