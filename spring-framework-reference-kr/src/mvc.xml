<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="mvc">
  <title>웹 MVC 프레임워크</title>

  <section id="mvc-introduction">
    <title>스프링 웹 MVC 프레임워크 소개</title>

    <para>스프링 웹 모델-뷰-컨트롤러 (MVC) 프레임워크는 핸들러 매핑, 뷰 처리, 파일 업로드같은
    로케일과 테마처리로 요청을 핸들러로 디스패치하는 <classname>DispatcherServlet</classname>을
    중심으로 설계되었다. 기본 핸들러는 넓은 범위로 유연한 처리(handling) 메서드를 제공하는
    <interfacename>@Controller</interfacename>와
    <interfacename>@RequestMapping</interfacename> 어노테이션에 기반한다. 스프링 3.0부터는
    <interfacename>@Controller</interfacename> 메카니즘도
    <interfacename>@PathVariable</interfacename> 어노테이션과 다른 기능들을 통해서 RESTful
    웹사이트와 어플리케이션을 생성할 수 있게 한다.</para>

    <sidebar id="mvc-open-for-extension">
      <title><quote>확장에는 열려있다...</quote></title>

      <para>스프링 웹 MVC와 스프링의 일반적인 핵심 설계원리는 <quote><emphasis>확장에는 열려있고
      수정에는 닫혀있다(Open for extension, closed for modification)</emphasis></quote>
      원리이다.</para>

      <para>스프링 웹 MVC 핵심 클래스의 일부 메서드들은 <literal>final</literal>이다.
      개발자들은 자신만의 동작을 위해서 이러한 메서드들을 오버라이드할 수 없다. 이는 임의로
      할 수 없지만 특히 원리를 명심해 두어야 한다.</para>

      <para>이 원리에 대해서 알고 싶다면 Seth Ladd등이 쓴 <emphasis>Expert
      Spring Web MVC and Web Flow</emphasis>를 참고해라. 특히 첫번째 에디션의 117
      페이지에 있는 "A Look At Design" 부분을 살펴봐라. 아니면 다음을 참고해라.</para>

      <orderedlist>
        <listitem>
          <para><ulink
          url="http://www.objectmentor.com/resources/articles/ocp.pdf">Bob
          Martin, The Open-Closed Principle (PDF)</ulink></para>
        </listitem>
      </orderedlist>

      <para>스프링 MVC를 사용할 때 final 메서드에는 어드바이스를 추가할 수 없다. 예를 들어
      <literal>AbstractController.setSynchronizeOnSession()</literal> 메서드에는
      어드바이스를 추가할 수 없다. AOP 프록시와 왜 final 메서드에는 어드바이스를 추가할 수 없는지는
      <xref linkend="aop-understanding-aop-proxies" />를 참고해라.</para>
    </sidebar>

    <para>스프링 웹 MVC에서 커맨드 객체나 폼을 바인딩하기 위한 객체(form-backing object)에
    어떤 객체라도 사용할 수 있다. 프레임워크에 특화된 인터페이스나 기반 클래스를 구현할 필요가 없다.
    스프링의 데이터 바인딩은 아주 유연하다. 예를 들어 스프링의 데이터 바인딩은 타입 불일치를 시스템
    오류가 아니라 어플리케이션이 평가할 수 있는 유효성검사 오류(validation errors)로 다룬다.
    그러므로 폼객체가 유효하지 않은 제출을 처리하고 문자열을 적절하게 변환하려고 타임이 없는 문자열로
    비즈니스 객체의 프로피티들을 복사할 필요가 없다. 대신에 때로는 비즈니스 객체로 직접 바인딩하는
    것을 더 선호한다.</para>

    <para>스프링의 뷰 처리(view resolution)는 엄청나게 유연하다.
    <interfacename>Controller</interfacename>가 보통 데이터를 가진 모델
    <classname>Map</classname>을 준비하고 뷰 이름을 선택하는 담당을 하지만
    <interfacename>Controller</interfacename> 응답 스트림에 직접 작성하고 요청을 완료할 수도
    있다. 뷰 이름 처리는 빈 이름, 프로퍼티 파일이나 커스텀 <interfacename>ViewResolver</interfacename>
    구현체로 파일의 확장자나 Accept 헤더의 내용협상(content type negotiation)을 통해서 설정할 수
    있다. 모델(MVC에서 M)은 뷰 기술을 완전히 추상화할 수 있도록 <interfacename>Map</interfacename>
    인터페이스이다. JSP, Velocity, Freemarker같은 템플릿 기반의 렌더링 기술과 직접 통합하거나 XML,
    JSON, Atom과 다른 타입의 컨텐츠들을 직접 생성할 수 있다. 모델
    <interfacename>Map</interfacename>은 JSP 요청 속성, Velocity 템플릿 모델처럼
    적절한 형식으로 변환된다.</para>

    <section id="mvc-features">
      <title>스프링 웹 MVC의 기능<!--I moved Features of Spring Web MVC before Pluggability of other MVC implementations. You want to highlight your own imp. first.--></title>

      <!--Second line of sidebar refers to JSF; don't you mean JSP? Other refs in this context are to JSP. Also note, sidebar is read-only.-->

      <xi:include href="swf-sidebar.xml"
                  xmlns:xi="http://www.w3.org/2001/XInclude" />

      <para>스프링의 웹 모듈은 웹을 지원하는 많은 독특한 기능들을 포함한다.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>역할의 깔끔한 분리</emphasis>. 컨트롤러,
          밸리데이터(validator), 커맨드 객체, 폼 객체, 모델 객체,
          <classname>DispatcherServlet</classname>, 핸들러 매핑, 뷰 리졸버등과 같은
          각 역할들인 전용 객체들로 실행될 수 있다.</para>
        </listitem>

        <listitem>
          <para><emphasis>JavaBean처럼 프레임워크 클래스와 어플리케이션 클래스의 강력하고
          직관적인 설정</emphasis>. 이 설정 기능은 웹 컨트롤러에서 비즈닌스객체와 밸리데이터에
          대한 참조같은 컨텍스트를 건너서 쉽게 참조할 수 있는 기능을 포함한다.</para>
        </listitem>

        <listitem>
          <para><emphasis>적응성(Adaptability), 비침투성,
          유연성(flexibility)</emphasis> 해당 시나리오에 필요한 모든 컨트롤러 메서드
          시그니처(파라미너 어노테이션(@RequestParam, @RequestHeader, @PathVariable 등등)
          중 하나를 사용할 수도 있는)를 정의해라.</para>
        </listitem>

        <listitem>
          <para><emphasis>중복없이 재사용가능한 비즈니스 코드</emphasis>. 특정 프레임워크
          기반 클래스를 확장하려고 해당 클래스를 복제하는 대신에 존재하는 비지니스 객체를 커맨드
          객체나 폼 객체로 사용해라.</para>
        </listitem>

        <listitem>
          <para><emphasis>커스터마이징할 수 있는 바인딩과 유효성검사(validation)</emphasis>.
          수동으로 파싱해서 비즈니스 객체로 변환하는 문자열만 사용가능한 폼 객체 대신에 문제가 있는 값을
          유지하는 어플리케이션 수준의 유효성 검사 오류인 타입 불일치, 로컬라이징된 날짜나
          숫자를 바인딩 등등.</para>
        </listitem>

        <listitem>
          <para><emphasis>커스터마이징할 수 있는 핸들러 매핑과 뷰 처리(view
          resolution)</emphasis>. 핸들러 매핑과 뷰 처리전략은 간단한 URL 기반의 설정부터
          정교하고 목적에 맞는 처리 전략까지의 범위를 포함한다. 스프링은 특정 기술에 위임하는
          웹 MVC 프레임워크보다 더 유연하다.</para>
        </listitem>

        <listitem>
          <para><emphasis>유연한 모델 전환자(transfer)</emphasis>. 이름/값
          <interfacename>Map</interfacename>으로 된 모델 전환자는 어떤 뷰 기술과도
          쉽게 통합할 수 있도록 지원한다.</para>
        </listitem>

        <listitem>
          <para><emphasis>커스터마이징할 수 있는 로케일과 테마 처리. 스프링 태그라이브러리를
          쓰던 안쓰던 JSP를 지원하고 JSTL을 지원하고 별도의 중계 등이 필요없이 Velocity를
          지원한다.</emphasis></para>
        </listitem>

        <listitem>
          <para><emphasis>소위 스프링 태그 라이브러리로 알려진 간단하고 강력한 JSP 태그
          라이브러리는 데이터 바인딩과 테마같은 기능을 지원한다</emphasis>. 커스텀 태그는
          마크업 코드에서 최대한의 유연성을 제공한다. 태그 라이브러리 디스크립터에 대한 정보는
          <xref linkend="spring.tld" /> 부록을 참고해라.</para>
        </listitem>

        <listitem>
          <para><emphasis>스프링 2.0에 추가된 JSP 폼태그 라이브러리는 JSP 페이지에서 폼을
          훨씬 쉽게 작성할 수 있게 한다.</emphasis> 태그 라이브러리 디스크립터에 대한 정보는
          <xref linkend="spring-form.tld" /> 부록을 참고해라.</para>
        </listitem>

        <listitem>
          <para><emphasis>빈의 생명주기는 현재의 HTTP 요청이나 HTTP
          <interfacename>Session</interfacename>의 범위가 된다.</emphasis> 이는
          스프링 MVC의 기능이 아닌 스프링 MVC가 사용하는
          <interfacename>WebApplicationContext</interfacename> 컨테이너의 독특한
          기능이다. 이러한 빈의 범위는 <xref linkend="beans-factory-scopes-other" />에
          나와있다.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="mvc-introduction-pluggability">
      <title>다른 MVC 구현체의 플러그인 기능(Pluggability)</title>

      <para>어떤 프로젝트에서는 스프링이 아닌 MVC 구현체를 더 선호한다. 많은 팀은 기술과 도구에
      대해서 기존에 연구했던 것을 사용할 수 있기를 원한다. Struts 프레임워크에 대한 많은 양의
      지식과 경험이 이미 존재한다. Struts의 아키텍처적인 결점을 견딜수 있다면 Struts를 웹 계층으로
      선택할 수 있고 동일하게 WebWork나 다른 웹 MVC 프레임워크에도 적용된다.</para>

      <para>스프링의 웹 MVC를 사용하지는 않지만 스프링이 제공하는 다른 해결책들은 사용하고자 한다면
      선택한 웹 MVC 프레임워크와 스프링을 쉽게 통합할 수 있다. 스프링의
      <classname>ContextLoaderListener</classname>로 스프링 루트 어플리케이션 컨텍스트를
      구동하고 Struts나 WebWorc 액션내에서 <interfacename>ServletContext</interfacename>
      속성(또는 스프링 각각의 헬퍼 메서드)을 통해 루트 어플리케이션
      컨텍스트<!--Identify *its*. do you mean root application context's?-->
      에 접근해라. "플러그인"이 없으므로 전용 통합도 필요없다. 웹계층의 뷰에서 진입점인 루트
      어플리케이션 컨텍스트 인스턴스로 스프링을 그냥 라이브러리처럼 사용할 수 있다. </para>

      <para>등록한 빈과 스프링의 서비스는 스프링 웹 MVC가 없어도 사용할 수 있다. 이러한 시나리오에서
      스프링은 Struts나 WebWork와 경쟁하지 않는다. 스프링은 빈 설정부터 데이터 접근과 트랜잭션
      처리까지 순수한 웹 MVC 프레임워크가 처리하지 않은 많은 영역을 처리할 뿐이다. 그러므로 단지
      JDBC나 하이버네이트로 트랜잭션 추상화를 사용하고자 할때도 스프링 중간계층이나 데이터접근 계층으로
      어플리케이션을 풍부하게 할 수 있다.</para>
    </section>
  </section>

  <section id="mvc-servlet">
    <title><classname>DispatcherServlet</classname></title>

    <para>많은 웹 MVC 프레임워크처럼 스프링의 웹 MVC 프레임워크는 요청 중심(request-driven)이고
    요청을 컨트롤러로 디스패치하는 중앙 서블릿을 중심으로 설계되었고 웹 어플리케이션을 개발에 대한 기능들을
    제공한다. 하지만 스프링의 <classname>DispatcherServlet</classname>은 앞에서 얘기한 것
    이상은 하지 않는다. <classname>DispatcherServlet</classname>는 스프링 IoC 컨테이너와
    완전히 통합되어 있어서 스프링이 가진 모든 다른 기능을 사용할 수 있게 한다.</para>

    <para>스프링 웹 MVC <classname>DispatcherServlet</classname>의 요청 처리 흐름은
    다음 다이어그램에 설명되어 있다. 패턴에 대해서 작 알고 있는 사람은
    <classname>DispatcherServlet</classname>가 <quote>Front Controller</quote>
    디자인 패턴(이는 스프링 웹 MVC와 인기있는 다수의 웹 프레임워크가 사용하는 패턴이다)의 표현이라는
    것을 알 수 있을 것이다.</para>

    <para><mediaobject>
        <imageobject role="fo">
          <imagedata align="center" fileref="images/mvc.png" format="PNG" />
        </imageobject>

        <imageobject role="html">
          <imagedata align="center" fileref="images/mvc.png" format="PNG" />
        </imageobject>

        <caption><para>스프링 웹 MVC에서 요청의 처리 흐름(고수준)</para></caption>
      </mediaobject></para>

    <para><classname>DispatcherServlet</classname>는 실제로
    <interfacename>Servlet</interfacename>이고(<classname>HttpServlet</classname>
    기반 클래스를 상속받는다) 웹 어플리케이션의 <literal>web.xml</literal>에 선언되어 있다.
    <classname>DispatcherServlet</classname>이 처리하게 하고 싶은 요청을
    <literal>web.xml</literal> 파일에서 URL 매핑을 사용해서 매핑해야 한다. 이는 표준 Java EE
    서블릿 설정이다. 다음 예제는 이러한 <classname>DispatcherServlet</classname> 선언과 매핑을
    보여준다.</para>

    <programlisting language="xml">&lt;web-app&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;example&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;example&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/example/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</programlisting>

    <para>앞의 예제에서 <literal>/example</literal>로 시작하는 모든
    요청을 <literal>example</literal>라는 이름의
    <classname>DispatcherServlet</classname> 인스턴스가 처리할 것이다. 이는 스프링
    웹 MVC를 설정하는 첫번째 과정일 뿐이다. <!--The discussion below is a little vague about what you're doing, when you do it, and what you're accomplishing. --><!-- Is the next step shown in the next example screen?-->
    이제 스프링 웹 MVC 프레임워크(위의 <classname>DispatcherServlet</classname>가)가
    사용하는 다양한 빈을 설정해야 한다.<!--See previous sentence. Add info to indicate where you find info that tells you how to configure beans for MVC framework. --><!--Next paragraph, so what are you telling them to *do* here? --></para>

    <para><xref linkend="context-introduction" />에서 설명했듯이 스프링의
    <interfacename>ApplicationContext</interfacename> 인스턴스는 범위를 가질 수 있다.
    웹 MVC 프레임워크에서 각 <classname>DispatcherServlet</classname>는 루트
    <interfacename>WebApplicationContext</interfacename>에서 이미 정의된 모든 빈을
    상속받은 자신만의 <interfacename>WebApplicationContext</interfacename>를 가진다.
    이 상속받은 빈들은 서블릿에 특화된 범위를 덮어쓸 수 있고 주어진 서블릿 인스턴의 빈에 새로운
    범위의 빈을 정의할 수 있다.</para>

    <para><mediaobject>
        <imageobject role="fo">
          <imagedata align="center" fileref="images/mvc-contexts.gif"
                     format="GIF" />
        </imageobject>

        <imageobject role="html">
          <imagedata align="center" fileref="images/mvc-contexts.gif"
                     format="GIF" />
        </imageobject>

        <caption>스프링 웹 MVC의 컨텍스트 계층</caption>
      </mediaobject></para>

    <para><classname>DispatcherServlet</classname>을 초기화하면서 스프링 MVC는
    웹 어플리케이션의 <literal>WEB-INF</literal> 디렉토리에서 <emphasis>
    <literal>[servlet-name]-servlet.xml</literal></emphasis>라는 이름의 파일을
    검색하고 거기에 정의된 빈을 생성하고 전역 범위에 같은 이름으로 정의된 모든 빈 정의를
    덮어쓴다.</para>

    <para>다음의 <classname>DispatcherServlet</classname> 서블릿
    설정(<literal>web.xml</literal> 파일에 있다)을 보자.</para>

    <programlisting language="xml">&lt;web-app&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;<emphasis role="bold">golfing</emphasis>&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;<emphasis role="bold">golfing</emphasis>&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/golfing/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</programlisting>

    <para>위의 서블릿 설정에서 <!--Is this something you need to do (in above example)? -->
    어플리케이션에 <literal>/WEB-INF/</literal><emphasis
    role="bold">golfing</emphasis><literal>-servlet.xml</literal>라는 파일이 있어야
    할 것이다. 이 파일은 스프링 웹 MVC에 특화된 컴포넌트(빈)을 모두 담고 있을 것이다. 서블릿 초기화
    파라미터로 이 설정 파일의 정확한 위치를 변경할 수 있다.(자세한 내용은 아래를 보아라.)</para>

    <!--See *where* for details? Give x-ref to section talks about how to change the location of the file through servlet init. param.-->

    <para><interfacename>WebApplicationContext</interfacename>는 웹 어플리케이션이
    필요로 하는 추가 기능들을 가진 보통의 <interfacename>ApplicationContext</interfacename>의
    확장이다. <interfacename>WebApplicationContext</interfacename>는 테마를 처리하는
    기능(<xref linkend="mvc-themeresolver" /> 참고)과 서블릿이 연결되어 있다는 것을 인지하고
    있다는 점(<interfacename>ServletContext</interfacename>에 대한 링크를 가지고 있다)에서
    일반적인 <interfacename>ApplicationContext</interfacename>와는 다르다.
    <interfacename>WebApplicationContext</interfacename>는
    <interfacename>ServletContext</interfacename>에 바인딩되어 있다.
    <interfacename>WebApplicationContext</interfacename>에 접근해야 한다면
    <classname>RequestContextUtils</classname> 클래스의 정적 메서드를 사용해서 항상
    <interfacename>WebApplicationContext</interfacename>를 검색할 수 있다.</para>

	<section id="mvc-servlet-special-bean-types">
		<title><interfacename>WebApplicationContext</interfacename>의 전용 빈 타입</title>

	    <para>스프링 <classname>DispatcherServlet</classname>는 요청을 처리하고 적절한
      뷰를 렌더링하도록 전문화된 빈을 사용한다. 이러한 빈은 스프링 MVC의 일부이다.
      <interfacename>WebApplicationContext</interfacename>에서 이러한 빈을 하나 이상
      설정해서 사용할 전용 빈을 선택할 수 있다. 하지만 아무것도 설정하지 않는다면 스프링 MVC가 기본
      빈의 목록을 유지하므로 처음에는 설정하지 말아야 한다. 자세한 내용은 다음 섹션에서 설명한다.
      우선은 아래의 표에 나온 <classname>DispatcherServlet</classname>가 의존하는
      전용 빈 타입의 목록을 보자.</para>

	    <table id="mvc-webappctx-special-beans-tbl">
	      <title><interfacename>WebApplicationContext</interfacename>의
        전용 빈 타입</title>

	      <tgroup cols="2">
	        <colspec colname="c1" colwidth="1*" />

	        <colspec colname="c2" colwidth="4*" />

	        <thead>
	          <row>
	            <entry>빈(Bean) 타입</entry>

	            <entry>설명</entry>
	          </row>
	        </thead>

	        <tbody>
	          <row>
	            <entry><link linkend="mvc-handlermapping">HandlerMapping</link></entry>

	            <entry>들어오는 요청을 <interfacename>HandlerMapping</interfacename>
              구현체가 다양하게 만든 크리테리아에 기반한 전처리자(pre-processors)와
              후처리자(post-processors)(핸들러 인터셉터)의 목록에 매핑한다. 대부분의 인기있는
              구현체는 어노테이션이 붙은 컨트롤러를 지원하지만 그렇지 않은 구현체들도 존재한다.</entry>
	          </row>

	          <row>
	            <entry>HandlerAdapter</entry>

	            <entry>핸들러가 실제로 호출되었는지 여부에 상관없이
              <interfacename>DispatcherServlet</interfacename>이 요청에 매핑된 핸들러를
              호출하도록 돕는다. 예를 들어 어노테이션이 붙은 컨트롤러를 호출하려면 다양한 어노테이션을
              처리해야 한다. 그러므로 <interfacename>HandlerAdapter</interfacename>의 주요
              목적은 이러한 세부내용에서 <classname>DispatcherServlet</classname>을 보호하는
              것이다.</entry>
	          </row>

	          <row>
	            <entry><link linkend="mvc-exceptionhandlers">HandlerExceptionResolver</link></entry>

	            <entry>예외를 뷰에 매핑하고 더 복잡한 예외 처리 코드도
              사용할 수 있다.</entry>
	          </row>

	          <row>
	            <entry><link linkend="mvc-viewresolver">ViewResolver</link></entry>

	            <entry>논리적인 스프링 기반의 뷰 이름을 실제 <interface>View</interface>
              타입으로 처리한다.</entry>
	          </row>

	          <row>
	            <entry><link linkend="mvc-localeresolver">LocaleResolver</link></entry>

	            <entry>국제화된 뷰화면을 제공할 수 있도록 클라이언트가 사용하는
              로케일을 처리한다.</entry>
	          </row>

	          <row>
	            <entry><link linkend="mvc-themeresolver">ThemeResolver</link></entry>

	            <entry>개인화된 레이아웃을 제공하는 것처럼 웹 어플리케이션이
              사용할 수 있는 테마를 처리한다.</entry>
	          </row>

	          <row>
	            <entry><link linkend="mvc-multipart">MultipartResolver</link></entry>

	            <entry>HTML 폼에서 업로드하는 파일을 처리하는 등의 멀티파트(multi-part)
              요청을 파싱한다.</entry>
	          </row>

	          <row>
	            <entry><link linkend="mvc-flash-attributes">FlashMapManager</link></entry>

	            <entry>한 요청에서 다른 요청으로 속성을 전달하는데(보통은 리다이렉트사이에서)
              사용할 수 있도록 "입력" <classname>FlashMap</classname>과 "출력"
              <classname>FlashMap</classname>을 저장하고 획득한다.</entry>
	          </row>
	        </tbody>
	      </tgroup>
	    </table>

	</section>

	<section id="mvc-servlet-config">
		<title>기본 DispatcherServlet 설정</title>

		<para>이전 섹션에서 얘기했듣이 각 전문화된 빈에 대해서
    <classname>DispatcherServlet</classname>는 기본적으로 사용할 구현체의 목록을
    유지하고 있다. 이 정보는
    <classname>org.springframework.web.servlet</classname> 패키지의
    <filename>DispatcherServlet.properties</filename> 파일에 존재한다.
    </para>

		<para>모든 전용 빈은 자신만의 합리적인 기본값을 가진다. 하지만 조만간 이러한
    빈이 제공하는 프로퍼티들을 커스터마이징해야 할 것이다. 예를 들어
    <classname>InternalResourceViewResolver</classname> 설정의
    <literal>prefix</literal> 프로퍼티에 뷰 파일의 부모위치를 설정하는
    것은 아주 일반적이다.</para>

		<para>세부내용과는 관계없이 <classname>WebApplicationContext</classname>에
    <classname>InternalResourceViewResolver</classname>같은 전용
    빈을 일단 설정하면 사용할 기본 구현체의 목록을 효과적으로 오버라이드하고 설정하지
    않았다면 전용 빈 타입을 사용한다는 것이 여기서 이해야할 중요한 개념이다.
    예를 들어 <classname>InternalResourceViewResolver</classname>를
    설정하면 <interfacename>ViewResolver</interfacename> 구현체의
    기본 목록은 무시된다.
    </para>

		<para><xref linkend="mvc-config"/>에서는 MVC 자바설정과 MVC XML
    네임스페이스를 포함해서 스프링 MVC를 설정하는 다른 선택사항들을 배울 것이다.
    이는 간단한 시적점이 되고 스프링 MVC가 어떻게 동작하는지에 대해 어느 정도 지식이
    있다고 가정한다. 어플리케이션을 설정하는데 어떤 방법을 선택했는지에 상관없이
    이번 섹션에서 설명한 기본적인 개념은 도움이 될 것이다.
    </para>

	</section>

	<section id="mvc-servlet-sequence">
		<title>DispatcherServlet 처리 순서</title>

	    <para><classname>DispatcherServlet</classname>을 설정한 뒤 요청이 해당
      <classname>DispatcherServlet</classname>에 들어오면
      <classname>DispatcherServlet</classname>는 요청을 다음과 같이 처리하기
      시작한다.</para>

	    <orderedlist>
	      <listitem>
	        <para><interfacename>WebApplicationContext</interfacename>는
          요청을 검색해서 처리과정중에 컨트로러와 다른 요소들이 사용할 수 있는 속성처럼 요청을
          바인딩한다. <!--Use to do *what*? Also revise to indicate *what* searches for the WebApplicationContext -->이는 기본적으로
          <literal>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</literal>
          키에 바인딩된다.</para>
	      </listitem>

	      <listitem>
	        <para>로케일 리졸버는 요청을 처리할 때(뷰를 렌더링하고 데이터를 준비하는 등) 진행중인
          요소들이 사용할 로케일을 처리할 수 있도록 요청에 바인딩된다. 로케일 처리가 필요없다면
          로케일 리졸버는 필요없다.</para>

	        <!--Reword 'if you don't need local resolving, you don't need to use it '. Are you saying locale resolving is optional? If you don't configure it, will this step occur?-->
	      </listitem>

	      <listitem>
	        <para>테마 리졸버는 뷰같은 요소들이 어느 테마를 사용할지 결정하도록 요청에 바인딩된다.
          테마를 사용하지 않는다면 테마 리졸버를 무시할 수 있다.</para>

	        <!-- MLP perhaps say that there are not side effect to this binding, etc... Clarify *ignore it*. Does this step still occur if you don't use themes? -->

	        <!--And what if you DO use themes, what do you do and when? Same question re locale resolving.-->
	      </listitem>

	      <listitem>
	        <para>멀티파트 파일 리졸버를 지정했다면 요청이 멀티파트인지 검사한다. 멀티파트라면
          진행중인 다른 요소들의 추가적인 처리를 위해 요청을
          <classname>MultipartHttpServletRequest</classname>로 감싼다. 멀티파트
          처리에 대한 자세한 내용은 <xref linkend="mvc-multipart" />를 참고해라.</para>
	      </listitem>

	      <listitem>
	        <para>적절한 핸들러를 검색한다. 핸들러를 찾으면 모델을 준비하거나 랜더링하기 위해서
          핸들러와 연결된 실행체인을 순서대로 실행한다.</para>
	      </listitem>

	      <listitem>
	        <para>모델이 반환되면 뷰를 렌더링한다. 모델이 반환되지 않으면(전처리자나 후처리자가
          보안적인 이슈등으로 요청을 가로챘기 때문일 것이다.) 요청이 이미 실행되었기 때문에
          뷰도 렌더링하지 않는다.</para>

	        <!--fulfilled how and by what?-->
	      </listitem>
	    </orderedlist>

	    <para><interfacename>WebApplicationContext</interfacename>에 선언한 핸들러
      예외 리졸버가 요청을 처리하는 중에 던져진 예외를 잡는다. 이러한 예외 리졸버를 사용하면 예외를
      처리하는 커스텀 동작을 정의할 수 있도록 한다.</para>

	</section>

    <para>스프링 <classname>DispatcherServlet</classname>도 서블릿 API에 정의된대로
    <emphasis>last-modification-date</emphasis>의 반환을 지원한다. 특정 요청에 마지막
    수정일시를 결정하는 과정은 직관적이다. <classname>DispatcherServlet</classname>가
    적절한 핸들러 매핑을 검색하고 찾아낸 핸들러가
    <emphasis><interfacename>LastModified</interfacename></emphasis> 인터페이스를
    구현했는지를 검사한다. 만약 구현했다면 <interfacename>LastModified</interfacename>
    인터페이스의 <literal>long getLastModified(request)</literal> 메서드의 값을
    클라이언트에 반환한다.</para>

    <para>서블릿 초기화 파라미터(<literal>init-param</literal> 요소)를
    <literal>web.xml</literal> 파일의 서블릿 선언에 추가해서 개별
    <classname>DispatcherServlet</classname> 인스턴스를 커스터마이징할 수 있다.
    지원하는 파라미터 목록은 다음 표를 참고해라.</para>

    <!--Reword above sentence to specify whether configuring parameters in table configures last-modification-date, or are they further -->

    <!--customization for some other purpose? If so, need to explain how you config last-modification-date-->

    <table id="mvc-disp-servlet-init-params-tbl">
      <title><classname>DispatcherServlet</classname> 초기화
      파라미터</title>

      <tgroup cols="2">
        <colspec colname="c1" colwidth="1*" />

        <colspec colname="c2" colwidth="4*" />

        <thead>
          <row>
            <entry>파라미터</entry>

            <entry>설명</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><literal>contextClass</literal></entry>

            <entry><interfacename>WebApplicationContext</interfacename>를
            구현한 클래스로 해당 서블릿이 사용하는 컨텍스트를 인스턴스화한다. 기본적으로
            <classname>XmlWebApplicationContext</classname>를 사용한다.</entry>
          </row>

          <row>
            <entry><literal>contextConfigLocation</literal></entry>

            <entry>어디서 컨텍스트를 찾을 수 있는지를 나타내려고 컨텍스트 인스턴스에
            (<literal>contextClass</literal>가 지정한) 전달하는 문자열이다. 문자열은
            여러 컨텍스트를 지원하려고 여러 문자열(콤마로 구분한다)로 이루어질 수 있다. 여러
            컨텍스트를 사용하는 경우에 빈의 위치는 두번 정의되는데 마지막 위치를 사용한다.</entry>

            <!-- MLP review -->
          </row>

          <row>
            <entry><literal>namespace</literal></entry>

            <entry><interfacename>WebApplicationContext</interfacename>의 네임스페이스.
            기본값은 <literal>[servlet-name]-servlet</literal>이다.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>

  <section id="mvc-controller">
    <title>컨트롤러 구현하기</title>

    <para>컨트롤러는 일반적으로 서비스 인터페이스를 통해서 정의하는 어플리케이션 동작에 대한 접근을
    제공한다. <!--I changed preceding to active voice because next sentence refers to user input. Thus *you* do some defining.-->
    컨트롤러는 사용자 입력을 해석해서 뷰로 사용자에게 나타내는 모델로 변환한다. 스프링은 컨트롤러를
    아주 다양하게 생성할 수 있도록 아주 추상적인 방법으로 컨트롤러를 구현한다.</para>

    <para>스프링 2.5에서 <interfacename>@RequestMapping</interfacename>,
    <interfacename>@RequestParam</interfacename>,
    <interfacename>@ModelAttribute</interfacename> 등과 같은 어노테이션을 사용해서
    MVC 컨트롤러에 어노테이션 기반의 프로그래밍 모델을 도입했다. 이 어노테이션 지원은 서블릿 MVC와
    포틀릿 MVC 모두에서 사용할 수 있다. 이 방식으로 구현한 컨트롤러는 특정 기반 클래스를 확장하거나
    특정 인터페이스를 구현하지 말아야 한다. 게다가 이러한 컨트롤러에 서블릿이나 포틀릿 기능에 대한
    접근을 쉽게 설정할 수 있더라도 보통 서블릿이나 포틀릿 API에 직접적인 의존성을 가지지 않아야
    한다.</para>

    <tip>
      <para><link linkend="new-in-3.0-samples">예제 저장소</link>에서 사용할 수 있는
      <emphasis>MvcShowcase</emphasis>, <emphasis>MvcAjax</emphasis>,
      <emphasis>MvcBasic</emphasis>, <emphasis>PetClinic</emphasis>,
      <emphasis>PetCare</emphasis> 등 다수의 웹 어플리케이션은 이번 섹션에서 설명한
      어노테이션 지원을 사용한다. </para>

      <!-- MLP Note removed reference to imagedb -->
    </tip>

    <!--You need an intro sentence here that indicates the *purpose* of the following code.  -->

    <programlisting language="java">@Controller
public class HelloWorldController {

    @RequestMapping("/helloWorld")
    public String helloWorld(Model model) {
        model.addAttribute("message", "Hello World!");
        return "helloWorld";
    }
}</programlisting>

    <para>여기서 보듯이 <interfacename>@Controller</interfacename>와
    <interfacename>@RequestMapping</interfacename> 어노테이션으로 메서드 이름과 시그니처를
    유연하게 할 수 있다. 이 특정 예제에서 메서드는 <classname>Model</classname>을 받고 뷰
    이름으로 <classname>String</classname>을 반환하지만 이번 섹션의 뒷부분에서 설명하듯이 여러가지
    다른 메서드 파라미터와 반환값을 사용할 수 있다. <interfacename>@Controller</interfacename>와
    <interfacename>@RequestMapping</interfacename>을 비롯한 다수의 다른 어노테이션들은 스프링
    MVC 구현체의 기초를 형성한다. 이번 섹션에서는 이러한 어노테이션을 설명하고 서블릿 환경에서 이러한
    어노테이션들을 사용하는 가장 일반적인 방법을 설명한다.</para>

    <section id="mvc-ann-controller">
      <title><interfacename>@Controller</interfacename>로
      컨트롤러 정의하기</title>

      <para><interfacename>@Controller</interfacename> 어노테이션은 해당 클래스가
      <emphasis>컨트롤러</emphasis>의 역할을 한다는 것을 나타낸다. 스프링에서는 어떤 컨트롤러
      기반 클래스도 확장할 필요가 없고 서블릿 API를 참조할 필요도 없다. 하지만 필요하다면 서블릿에
      특화된 기능을 참조할 수 있다.</para>

      <para><interfacename>@Controller</interfacename> 어노테이션은 어노테이션이 붙은
      클래스의 스테레오 타입처럼 동작하고 클래스의 역할을 나타낸다. 디스패처는 매핑된 메서드에 이러한
      어노테이션이 붙은 클래스를 찾고 <interfacename>@RequestMapping</interfacename>
      어노테이션(다음 섹션 참조)을 탐지한다.</para>

      <para>디스패처의 컨텍스트에 표준 스프링 빈 정의를 사용해서 어노테이션이 붙은 컨트롤러 빈을
      명시적으로 정의할 수 있다. 하지만 클래스패스에서 컴포넌트 클래스를 탐지와 컴포넌트 클래스들을
      위해 빈 정의의 자동등록에 대한 스프링의 일반적인 지원에 맞추어
      <interfacename>@Controller</interfacename> 스테레오타입도 자동탐지가
      가능하다.</para>

      <!-- MLP Bev.changed to 'also supports autodetection -->

      <para>이렇게 어노테이션이 붙은 컨트롤러의 자동탐지를 활성화하려면 설정에 컴포넌트 스캔을 추가해야
      한다. 다음 XML 코드처럼 <emphasis>spring-context</emphasis> 스키마를 사용해라.</para>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;

    &lt;context:component-scan base-package="org.springframework.samples.petclinic.web"/&gt;

    <lineannotation>&lt;!-- ... --&gt;</lineannotation>

&lt;/beans&gt;</programlisting>
    </section>

    <section id="mvc-ann-requestmapping">
      <title><interfacename>@RequestMapping</interfacename>으로
      요청 매핑하기</title>

      <para><filename>/appointments</filename>같은 URL을 매핑하려면 전체 클래스나 특정
      핸들러 메서드에 <interfacename>@RequestMapping</interfacename> 어노테이션을 사용해라.
      보통 클래스수준의 어노테이션은 폼(form) 컨트롤러에 특정 요청 경로(또는 경로 패턴)을 매핑하고
      추가적인 메서드 수준의 어노테이션은 특정 HTTP 요청 메서드("GET", "POST" 등)나 HTTP 요청
      파라미터 상태로 매핑 범위를 좁힌다.</para>

      <para><emphasis>Petcare</emphasis> 예제에서 가져온 다음 코드는 이 어노테이션을
      사용하는 스프링 MVC 어플리케이션의 컨트롤러를 보여준다.</para>

      <programlisting language="java">@Controller
<emphasis role="bold">@RequestMapping("/appointments")</emphasis>
public class AppointmentsController {

    private final AppointmentBook appointmentBook;

    @Autowired
    public AppointmentsController(AppointmentBook appointmentBook) {
        this.appointmentBook = appointmentBook;
    }

    <emphasis role="bold">@RequestMapping(method = RequestMethod.GET)</emphasis>
    public Map&lt;String, Appointment&gt; get() {
        return appointmentBook.getAppointmentsForToday();
    }

    <emphasis role="bold">@RequestMapping(value="/{day}", method = RequestMethod.GET)</emphasis>
    public Map&lt;String, Appointment&gt; getForDay(@PathVariable @DateTimeFormat(iso=ISO.DATE) Date day, Model model) {
        return appointmentBook.getAppointmentsForDay(day);
    }

    <emphasis role="bold">@RequestMapping(value="/new", method = RequestMethod.GET)</emphasis>
    public AppointmentForm getNewForm() {
        return new AppointmentForm();
    }

    <emphasis role="bold">@RequestMapping(method = RequestMethod.POST)</emphasis>
    public String add(@Valid AppointmentForm appointment, BindingResult result) {
        if (result.hasErrors()) {
            return "appointments/new";
        }
        appointmentBook.addAppointment(appointment);
        return "redirect:/appointments";
    }
}</programlisting>

      <para>이 예제에서 <interfacename>@RequestMapping</interfacename>를 여러 곳에서
      사용했다. 첫번째는 타입(클래스) 수준에서 사용했고 이 컨트롤러의 모든 핸들링 메서드는
      <filename>/appointments</filename> 경로에 상대적이라는 것을 나타낸다.
      <methodname>get()</methodname> 메서드의
      <interfacename>@RequestMapping</interfacename>는 좀 더 세련되었다. 이
      <interfacename>@RequestMapping</interfacename>은 GET 요청만 받아들인다. 즉,
      <filename>/appointments</filename>에 대한 HTTP GET 요청만 이 메서드를 실행한다.
      <methodname>post()</methodname>도 유사하다.
      <methodname>getNewForm()</methodname>은 HTTP 메서드와 경로를 함께 사용했으므로
      <filename>appointments/new</filename>에 대한 GET 요청을 이 메서드가 처리한다.</para>

      <para><methodname>getForDay()</methodname> 메서드는
      <interfacename>@RequestMapping</interfacename>의 또다른 사용방법인 URI 템플릿
      보여준다. (<link linkend="mvc-ann-requestmapping-uri-templates">다음
      섹션</link> 참고.)</para>

      <para>클래스 수준의 <interfacename>@RequestMapping</interfacename>는 필수가
      아니다. 클래스에 <interfacename>@RequestMapping</interfacename>를 사용하지 않으면
      모든 경로는 상대경로가 아니라 절대경로가 된다. <emphasis>PetClinic</emphasis> 예제
      어플리케이션에서 가져온 다음 예제는 <classname>@RequestMapping</classname>를 사용한
      다중 액션 컨트롤러를 보여준다.</para>

      <programlisting language="java">@Controller
public class ClinicController {

    private final Clinic clinic;

    @Autowired
    public ClinicController(Clinic clinic) {
        this.clinic = clinic;
    }

    <emphasis role="bold">@RequestMapping("/")</emphasis>
    public void welcomeHandler() {
    }

    <emphasis role="bold">@RequestMapping("/vets")</emphasis>
    public ModelMap vetsHandler() {
        return new ModelMap(this.clinic.getVets());
    }

}</programlisting>

      <tip>
        <title>인터페이스 메서드에
        <interfacename>@RequestMapping</interfacename> 사용하기</title>

        <para>컨트롤러 객체에 프록시 생성을 필요로 하는 기능을 적용하는 경우가 어노테이션이 붙은
        컨트롤러 클래스를 사용할 때의 일반적인 어려운 부분이다. (예를 들면
        <interfacename>@Transactional</interfacename> 메서드) 보통은 JDK 동적
        프록시를 사용하려고 컨트롤러에 인터페이스를 도입할 것이다. 이렇게 하려면
        <interfacename>@RequestMapping</interfacename> 어노테이션을 인터페이스로 옮겨야
        하고 매핑 메카니즘이 프록시가 노출한 인터페이스만 "볼 수 있다". 그렇지 않으면 기능을 적용할
        컨트롤러의 설정에 <code>proxy-target-class="true"</code>를 활성화할 수 있다.(이
        트랜잭션 시나리오에서는 <code>&lt;tx:annotation-driven /&gt;</code>) 이렇게 하는
        것은 GCLIB기반의 하위클래스 프록시를 인터페이스 기반 JDK 프록시 대신에 사용해야 함을 의미한다.
        다양한 프록시 메카니즘에 대한 자세한 내용은 <xref linkend="aop-proxying" />를
        참고해라.</para>
      </tip>

      <section id="mvc-ann-requestmapping-uri-templates">
        <title>URI 템플릿 패턴</title>

        <para><interfacename>@RequestMapping</interfacename> 메서드의 URL에서
        선택하는 부분에 편리하게 접근하려고 <emphasis>URI 템플릿</emphasis>을 사용할 수
        있다.</para>

        <para>URI 템플릿은 URI과 유사한 문자열로 하나이상의 변수명을 포함하고 있다. 이러한 변수에
        값을 대체했을 때 비로소 탬플릿은 URI가 된다. URI 템플릿에 <ulink
        url="http://bitworking.org/projects/URI-Templates/">제안된 RFC</ulink>은
        어떻게 URI를 파라미터화하는지 정의하고 있다. 예를 들어 URI 템플릿
        <code>http://www.example.com/users/{userId}</code>는 변수
        <emphasis>userId</emphasis>를 포함하고 있다. 이 변수에 <emphasis>fred</emphasis>
        값을 할당하면 <code>http://www.example.com/users/fred</code>가 된다.</para>

        <para>스프링 MVC에서 URI 템플릿 변수의 값에 바인딩하려고 메서드 인자에
        <interfacename>@PathVariable</interfacename> 어노테이션을
        사용할 수 있다.</para>

        <programlisting language="java">@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(<emphasis role="bold">@PathVariable</emphasis> String ownerId, Model model) {
  Owner owner = ownerService.findOwner(ownerId);
  model.addAttribute("owner", owner);
  return "displayOwner";
}</programlisting>

        <para>URI 템플릿 "<literal>/owners/{ownerId}</literal>"는
        <literal>ownerId</literal>라는 변수명을 지정한다. 컨트롤러가 이 요청을 처리할 때
        URI의 적합한 부분에서 찾아낸 값을 <literal>ownerId</literal>의 값에 설정한다. 예를
        들어 <code>/owners/fred</code>로 들어오는 요청에서 <literal>ownerId</literal>의
        값은 <literal>fred</literal>가 된다.</para>

        <tip>
          <para>@PathVariable 어노테이션을 처리하려면 스프링 MVC가 이름과 일치하는 URI 템플릿
          변수를 찾아야 한다. 어노테이션에서 이를 지정할 수 있다.</para>

          <programlisting language="java">@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(<emphasis role="bold">@PathVariable</emphasis>("ownerId") String theOwner, Model model) {
  // 구현부는 생략한다
}</programlisting>

          <para>또는 URI 템플릿 변수 이름이 메서드 인자의 이름과 일치한다면 자세한 내용은 생략할
          수 있다. 코드를 디버깅 정보없이 컴파일하지 않는 한 스프링 MVC가 메서드 인자 이름와
          일치하는 URI 템플릿 변수 이름를 찾아낼 것이다.</para>

          <programlisting language="java">@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(<emphasis role="bold">@PathVariable</emphasis> String ownerId, Model model) {
  // 구현부는 생략한다
}</programlisting>
        </tip>

        <para>메서드는 다수의 <interfacename>@PathVariable</interfacename>
        어노테이션을 가질 수 있다.</para>

        <programlisting language="java">@RequestMapping(value="/owners/{ownerId}/pets/{petId}", method=RequestMethod.GET)
public String findPet(<emphasis role="bold">@PathVariable</emphasis> String ownerId, <emphasis
            role="bold">@PathVariable</emphasis> String petId, Model model) {
  Owner owner = ownerService.findOwner(ownerId);
  Pet pet = owner.getPet(petId);
  model.addAttribute("pet", pet);
  return "displayPet";
}</programlisting>

        <para>URI 템플릿은 타입과 경로의 <emphasis>@RequestMapping</emphasis>
        어노테이션으로 만들 수 있다. 그래서 <methodname>findPet()</methodname> 메서드는
        <filename>/owners/42/pets/21</filename>같은 URL로 실행할 수 있다.</para>

        <programlisting language="java">@Controller
@RequestMapping(<emphasis role="bold">"/owners/{ownerId}"</emphasis>)
public class RelativePathUriTemplateController {

  @RequestMapping(<emphasis role="bold">"/pets/{petId}"</emphasis>)
  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {
    // 구현부는 생략한다
  }
}</programlisting>

        <para><interfacename>@PathVariable</interfacename> 인자는 int, long, Date
        등의 <emphasis role="bold">간단한 어떠한 타입이라도</emphasis> 될 수 있다. 스프링이
        자동으로 적절한 타입으로 변환하거나 타입변환에 실패한다면
        <classname>TypeMismatchException</classname>를 던진다. 추가적인 데이터 타입을
        파싱하도록 등록할 수도 있다. <xref linkend="mvc-ann-typeconversion" />와
        <xref linkend="mvc-ann-webdatabinder" />를 참고해라.</para>
      </section>

      <section id="mvc-ann-requestmapping-uri-templates-regex">
        <title>정규표현식을 사용한 URI 템플릿 패턴</title>

        <para>때로는 URI 템플릿 변수를 정의할 때 더 정확하게 해야할 필요가 있다.
        <code>"/spring-web/spring-web-3.0.5.jar"</code>같은 URL을 생각해 보자.
        이러한 URL을 어떻게 여러 URL을 받아들이도록 하는가?</para>

        <para><interfacename>@RequestMapping</interfacename> 어노테이션은 URI 템플릿
        변수에 정규표현식을 지원한다. 문법은 <code>{varName:regex}</code>인데 첫부분은
        변수명이고 두번째 부분은 정규표현식이다. 예를 들면 다음과 같다.</para>

        <programlisting language="java">
@RequestMapping("/spring-web/{symbolicName:[a-z-]+}-{version:\d\.\d\.\d}.{extension:\.[a-z]}")
  public void handle(@PathVariable String version, @PathVariable String extension) {
    // ...
  }
}</programlisting>
      </section>

      <section id="mvc-ann-requestmapping-patterns">
        <title>경로(Path) 패턴</title>

        <para>URI 템플릿에 추가해서 <interfacename>@RequestMapping</interfacename>
        어노테이션도 Ant방식의 경로 패턴을 지원한다.(예를 들면 <filename>/myPath/*.do</filename>)
        URI 템플릿과 Ant 방식을 섞어서 사용하는 것도 가능하다.(예를 들면
        <filename>/owners/*/pets/{petId}</filename>)</para>
      </section>

      <section id="mvc-ann-requestmapping-consumes">
        <title>소비가능한 미디어 타입(Consumable Media Types)</title>

        <para>소비가능한 미디어 타입의 목록을 지정해서 주요한 매핑을 제한할 수 있다.
        <emphasis>Content-Type</emphasis> 요청 헤더가 지정한 미디어타입과 일치할 때만
        요청이 매칭할 것이다. 예를 들면 다음과 같다.</para>

        <programlisting language="java">@Controller
@RequestMapping(value = "/pets", method = RequestMethod.POST, <emphasis
            role="bold">consumes="application/json"</emphasis>)
public void addPet(@RequestBody Pet pet, Model model) {
    // 구현부는 생략한다
}</programlisting>

        <para>소비가능한 미디어 타입 표현식에서 <emphasis>text/plain</emphasis>의
        <emphasis>Content-Type</emphasis>을 제외한 모든 요청과 일치하도록
        <emphasis>!text/plain</emphasis>처럼 부정문을 사용할 수도 있다.</para>

        <tip>
          <para><emphasis>consumes</emphasis> 조건은 타입수준과 메서드 수준에서
          지원한다. 대부분의 다른 조건과는 달리 타입수준에서 사용했을 때 메서드 수준의 소비가능한
          타입이 타입 수준의 소비가능한 타입을 확장하는 게 아니라 오버라이드한다.</para>
        </tip>
      </section>

      <section id="mvc-ann-requestmapping-produces">
        <title>생산가능한 미디어 타입(Producible Media Types)</title>

        <para>생산가능한 미디어 타입의 목록을 지정해서 주요 매핑을 제한할 수 있다.
        <emphasis>Accept</emphasis> 요청헤더가 이러한 값 중 하나와 일치할 때만 요청이
        매칭될 것이다. 게다가 <emphasis>produces</emphasis> 상태를 사용하면
        <emphasis>produces</emphasis> 조건에 지정한 미디어 타입과 관련된 응답을
        생성하는데 사용한 실제 컨텐트 타입을 보장한다. 예를 들면 다음과 같다.</para>

        <programlisting language="java">@Controller
@RequestMapping(value = "/pets/{petId}", method = RequestMethod.GET, <emphasis
            role="bold">produces="application/json"</emphasis>)
@ResponseBody
public Pet getPet(@PathVariable String petId, Model model) {
    // 구현부는 생략한다
}</programlisting>

        <para><emphasis>consumes</emphasis>에서처럼 생산가능한 미디어타입 표현식에는
        <emphasis>text/plain</emphasis>의 <emphasis>Accept</emphasis> 헤더값을 가진
        요청을 제외한 모든 요청에 매칭되도록 <emphasis>!text/plain</emphasis>처럼 부정문을
        사용할 수 있다.</para>

        <tip>
          <para><emphasis>produces</emphasis> 조건은 타입수준과 메서드 수준에서 지원한다.
          다른 대부분의 조건과는 달리 타입수준에서 사용했을 때 메서드수준의 producible 타입은
          타입수준의 producible 타입을 확장하는 게 아니라 오버라이드한다.</para>
        </tip>
      </section>

      <section id="mvc-ann-requestmapping-params-and-headers">
        <title>요청 파라미터와 헤더값</title>

        <para><code>"myParam"</code>, <code>"!myParam"</code>,
        <code>"myParam=myValue"</code>같은 요청 파라미터 조건으로 요청에 대한 매칭을 제한할
        수 있다. 앞에 두가지는 요청파라미터의 존재/부재 여부를 확인하고 세번째는 특정 파라미터 값을
        확인한다. 다음은 요청 파라미터 값 조건에 대한 예제이다.</para>

        <programlisting language="java">@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {

  @RequestMapping(value = "/pets/{petId}", method = RequestMethod.GET, <emphasis
            role="bold">params="myParam=myValue"</emphasis>)
  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {
    // 구현부는 생략한다
  }
}</programlisting>

        <para>요청 헤더의 존재/부재 여부에 대한 검사나 지정한 요청 헤더값에 기반한 매칭도
        동일하게 이뤄질 수 있다.</para>

        <programlisting language="java">@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {

@RequestMapping(value = "/pets", method = RequestMethod.GET, <emphasis
            role="bold">headers="myHeader=myValue"</emphasis>)
  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {
    // 구현부는 생략한다
  }
}</programlisting>

        <tip>
          <para>미디어타입 와일드카드를 사용해서 <emphasis>Content-Type</emphasis>와
          <emphasis>Accept</emphasis> 헤더값을  일치하도록 할 수 있기는 하지만 대신에
          <emphasis>consumes</emphasis>와 <emphasis>produces</emphasis> 조건을
          각각 사용하는 것을 권장한다. 이 둘은 해당 목적에 맞게 만들어진 것이다.</para>
        </tip>
      </section>
    </section>

    <section id="mvc-ann-methods">
      <title><interface>@RequestMapping</interface> 핸들러 메서드
      정의하기</title>

      <para><classname>@RequestMapping</classname> 핸들러 메서드는 아주 유연한 시그니처를
      가질 수 있다. 지원하는 메서드 인자와 반환값은 다음 섹션에서 설명한다. 대부분의 인자는
      <classname>BindingResult</classname> 인자만 제외하고 임의의 순서로 사용할 수 있다.
      이는 다음 섹션에서 설명한다.</para>

      <section id="mvc-ann-arguments">
        <title>지원하는 메서드 인자 타입</title>

        <para>다음은 지원하는 메서드 인자들이다. <itemizedlist>
            <listitem>
              <para>요청객체나 응답 객체(서블릿 API).
              <interfacename>ServletRequest</interfacename>나
              <interfacename>HttpServletRequest</interfacename>같은 특정 요청이나
              응답 타입을 어떠한 것이라도 선택할 수 있다.</para>
            </listitem>

            <listitem>
              <para><interfacename>HttpSession</interfacename>타입의 세션 객체
              (서블릿 API): 이 타입의 인자는 대응되는 세션의 존재를 강제한다. 그래서 이 인자는
              결코 <literal>null</literal>이 되지 않는다.</para>

              <note>
                <para>세션 접근은 특히 서블릿 환경에서는 쓰레드세이프하지 않을 것이다. 여러 요청이
                하나의 세션에 동시접근해야 한다면
                <classname>RequestMappingHandlerAdapter</classname>의
                "synchronizeOnSession" 플래그를 "true"로 설정하는 것을 고려해 봐라.</para>
              </note>
            </listitem>

            <listitem>
              <para><classname>org.springframework.web.context.request.WebRequest</classname>
              나
              <classname>org.springframework.web.context.request.NativeWebRequest</classname>.
              요청/세션 속성 접근과 마찬가지로 네이티브 서블릿/포틀릿 API에 묶이지 않고
              일반적인 요청 파라미터에 대한 접근을 허용한다.</para>
            </listitem>

            <listitem>
              <para>현재 요청의 로케일에 대한 <classname>java.util.Locale</classname>로
              사용가능한 가장 구체적인 로케일 리졸버(사실상 서블릿 환경에 설정한
              <interfacename>LocaleResolver</interfacename>)가 결정한다.</para>
            </listitem>

            <listitem>
              <para>요청의 내용에 접근하기 위한
              <classname>java.io.InputStream</classname> /
              <classname>java.io.Reader</classname>. 이 값은 서블릿 API가 노출한
              것처럼 가공되지 않은(raw) InputStream/Reader이다. </para>
            </listitem>

            <listitem>
              <para>응답의 내용을 생성하기 위한
              <classname>java.io.OutputStream</classname> /
              <classname>java.io.Writer</classname>. 이 값은 서블릿 API가 노출한
              것처럼 가공되지 않은(raw) OutputStream/Writer이다.</para>
            </listitem>

            <listitem>
              <para><interfacename>java.security.Principal</interfacename>는
              현재 인증된(authenticated) 사용자를 담고 있다.</para>
            </listitem>

            <listitem>
              <para>URI 템플릿 변수에 접근하는 <classname>@PathVariable</classname>
              어노테이션이 붙은 파라미터. <xref
              linkend="mvc-ann-requestmapping-uri-templates" />를 참고해라.</para>
            </listitem>

            <listitem>
              <para>특정 서블릿 요청 파라미터에 접근하는 <classname>@RequestParam</classname>
              어노테이션이 붙은 파라미터. 파라미터 값은 선언된 메서드 인자 타입으로 변환된다.
              <xref linkend="mvc-ann-requestparam" />를 참고해라.</para>
            </listitem>

            <listitem>
              <para>특정 서블릿 요청 HTTP 헤더에 접근하는
              <interfacename>@RequestHeader</interfacename> 어노테이션이 붙은
              파라미터. 파라미터 값들은 선언된 메서드 인자 타입으로 변환된다.</para>
            </listitem>

            <listitem>
              <para>HTTP 바디에 접근하기 위해 <interfacename>@RequestBody</interfacename>
              어노테이션이 붙은 파라미터. 파라미터 값은
              <interfacename>HttpMessageConverter</interfacename>를 사용해서 선언한
              메서드 인자 타입으로 변환한다. <xref linkend="mvc-ann-requestbody" />를
              참고해라.</para>
            </listitem>

            <listitem>
              <para>"multipart/form-data" 요청 부분의 내용에 접근하기 위해
              <interfacename>@RequestPart</interfacename> 어노테이션이 붙은
              파라미터. <xref linkend="mvc-multipart-forms-non-browsers" />와
              <xref linkend="mvc-multipart" />를 참고해라.</para>
            </listitem>

            <listitem>
              <para>서블릿 요청 HTTP 헤더와 내용에 접근하기 위한
              <classname>HttpEntity&lt;?&gt;</classname> 파라미터.
              <interfacename>HttpMessageConverter</interfacename>를 사용해서 요청
              스트림을 엔티티 바디로 변환할 것이다. <xref
              linkend="mvc-ann-httpentity" />를 참고해라.</para>
            </listitem>

            <listitem>
              <para>웹 뷰에 노출되는 암묵적인 모델을 풍부하게 하기 위한
              <interfacename>java.util.Map</interfacename> /
              <interfacename>org.springframework.ui.Model</interfacename> /
              <classname>org.springframework.ui.ModelMap</classname>.</para>
            </listitem>

            <listitem>
              <para>리다이렉트에 사용하는 속성의 정확한 세트를 지정하는
              <interfacename>org.springframework.web.servlet.mvc.support.RedirectAttributes</interfacename>이고
              플래시(flash) 속성(리다이렉트된 후에 요청이 속성을 사용할 수 있도록 서버측에
              임시적으로 저장된 속성)을 추가하기도 한다. 메서드가 "redirect:" 접두사가 붙은
              뷰 이름이나 <classname>RedirectView</classname>를 반환하면 암시적인 모델
              대신에 <literal>RedirectAttributes</literal>를 사용한다.</para>
            </listitem>

            <listitem>
              <para><classname>@InitBinder</classname>나 HandlerAdapter 설정에
              따라 커스터마이징할 수 있는 타입 변환으로 요청 파라미터를 빈 프로퍼티(setter로)나
              필드에 직접 바인딩하는 커맨드 객체나 폼 객체.
              <classname>RequestMappingHandlerAdapter</classname>의
              <literal>webBindingInitializer</literal> 프로퍼티를 참고해라. 유효성
              검사결과를 가진 이러한 커맨드 객체는 기본적으로 커맨드 클래스 이름을 사용해서 모델
              속성으로 노출된다. 예를 들어  "some.package.OrderAddress" 타입의 커멘드
              객체라면 "orderAddress" 모델 속성이 된다.
              <classname>ModelAttribute</classname> 어노테이션을 사용한 모델 속성
              이름을 커스터마이징할 수 있도록 메서드 인자에 사용할 수 있다.</para>
            </listitem>

            <listitem>
              <para>앞의 커맨드 객체나 폼 객체(바로 앞의 메서드 인자)에 대한 유효성검사 결과인
              <classname>org.springframework.validation.Errors</classname>
              /
              <classname>org.springframework.validation.BindingResult</classname>.</para>
            </listitem>

            <listitem>
              <para><classname>org.springframework.web.bind.support.SessionStatus</classname>
              핸들러 타입 수준의 <classname>@SessionAttributes</classname> 어노테이션이
              나타내는 세션 속성을 정리하도록 폼 처리를 완료되었다고 표시하는 상태 핸들.</para>
            </listitem>

            <listitem>
              <para><classname>org.springframework.web.util.UriComponentsBuilder</classname>
              현재 요청의 호스트, 포트, 스키마, 컨텍스트 경로, 서블릿 매핑의 리터럴 부분에
              상대적인 URL을 준비하는 빌더.</para>
            </listitem>
          </itemizedlist></para>

        <para><interfacename>Errors</interfacename>나
        <interfacename>BindingResult</interfacename> 파라미터는 하나의 모델 객체 이상을
        가지는 메서드 시그니처처럼 즉시 바인딩되는 모델 객체를 따라야 한고 스프링은 각각에 분리된
        <interfacename>BindingResult</interfacename> 인스턴스를 생성할 것이므로
        다음 예제는 동작하지 않는다.</para>

        <example>
          <title>BindingResult와 @ModelAttribute의 유효하지 않은 순서</title>

          <programlisting language="java">@RequestMapping(method = RequestMethod.POST)
public String processSubmit(<emphasis role="bold">@ModelAttribute("pet") Pet pet</emphasis>,
    Model model, <emphasis role="bold">BindingResult result</emphasis>) { … }</programlisting>

          <para><classname>Pet</classname>과
          <interfacename>BindingResult</interfacename>사이에는
          <interfacename>Model</interfacename> 파라미터가 존재한다. 이 예제가 동작하려면
          다음과 같이 파라미터의 순서를 변경해야 한다.</para>

          <programlisting language="java">@RequestMapping(method = RequestMethod.POST)
public String processSubmit(<emphasis role="bold">@ModelAttribute("pet") Pet pet</emphasis>,
    <emphasis role="bold">BindingResult result</emphasis>, Model model) { … }</programlisting>
        </example>
      </section>

      <section id="mvc-ann-return-types">
        <title>지원하는 메서드 반환 타입</title>

        <para>다음은 지원하는 반환 타입이다. <itemizedlist>
            <listitem>
              <para>커맨드 객체로 암묵적으로 풍부해지는 모델과
              <literal>@ModelAttribute</literal> 어노테이션이 붙은 참조 데이터
              접근자(accessor) 메서드의 결과를 가진
              <classname>ModelAndView</classname> 객체.</para>
            </listitem>

            <listitem>
              <para><interfacename>RequestToViewNameTranslator</interfacename>로
              암묵적으로 결정되는 뷰 이름과 커맨드 객체로 암묵적으로 풍부해지는 모델과
              <literal>@ModelAttribute</literal> 어노테이션이 붙은 참조 데이터
              접근자(accessor) 메서드의 결과를 가진
              <interfacename>Model</interfacename> 객체.</para>
            </listitem>

            <listitem>
              <para><interfacename>RequestToViewNameTranslator</interfacename>가
              암묵적으로 결정하는 뷰 이름과 커맨드 객체로 암묵적으로 풍부해지는 모델과
              <literal>@ModelAttribute</literal> 어노테이션이 붙은 참조 데이터
              접근자(accessor) 메서드의 결과를 가진 모델을 노출하는
              <interfacename>Map</interfacename> 객체.</para>
            </listitem>

            <listitem>
              <para>커맨드 객체로 암묵적으로 풍부해지는 모델과
              <literal>@ModelAttribute</literal> 어노테이션이 붙은 참조 데이터
              접근자(accessor) 메서드의 결과를 가진 <interfacename>View</interfacename>
              객체. <interfacename>Model</interfacename> 인자를 선언해서 핸들러 메서드도
              프로그래밍적으로 모델을 풍부하게 할 수 있다.(앞부분 참조)<!--see above where? Need more explicit reference. same problem with next item.--></para>
            </listitem>

            <listitem>
              <para>커맨드 객체로 암묵적으로 풍부해지는 모델과
              <literal>@ModelAttribute</literal> 어노테이션이 붙은 참조 데이터
              접근자(accessor) 메서드의 결과를 가지고 논리적인 뷰 이름으로 해석되는
              <classname>String</classname> 값.
              <interfacename>Model</interfacename>를 선언해서 핸들러 메서드도
              프로그래밍적으로 모델을 풍부하게 할 수 있다.(앞부분 참조)</para>
            </listitem>

            <listitem>
              <para>메서드가 응답을 직접 처리하거나(해당 목적에
              <interfacename>ServletResponse</interfacename> /
              <interfacename>HttpServletResponse</interfacename> 타입의 인자를
              선언해서 응답 내용을 직접 작성함으로써)
              <interfacename>RequestToViewNameTranslator</interfacename>로
              암묵적으로 정의되는 뷰 이름을 추정하면(핸들러 메서드 시그니처에 응답 인자를 선언하지
              않는다) <literal>void</literal>이다.</para>
            </listitem>

            <listitem>
              <para>메서드가 <interfacename>@ResponseBody</interfacename>
              어노테이션이 붙어있으면 반환 타입이 응답 HTTP 바디에 쓰여진다. 반환값을
              <interfacename>HttpMessageConverter</interfacename>를 사용해서 선언한
              메서드 인자 타입으로 변환할 것이다. <xref
              linkend="mvc-ann-responsebody" />를 참고해라.</para>
            </listitem>

            <listitem>
              <para>서블릿 응답 HTTP 헤더와 내용에 접근하는
              <classname>HttpEntity&lt;?&gt;</classname>나
              <classname>ResponseEntity&lt;?&gt;</classname>. 엔티티 바디는
              <interfacename>HttpMessageConverter</interfacename>를 사용해서 응답
              스트림으로 변환될 것이다. <xref linkend="mvc-ann-httpentity" />를
              참고해라.</para>
            </listitem>

            <listitem>
              <para>다른 모든 반환 타입은 메서드 수준에 <literal>@ModelAttribute</literal>로
              지정한 속성명을 사용해서(또는 반환 타입 클래스명에 기반한 기본 속성명) 뷰에 노출할
              단일 모델 속성(attribute)로 간주한다. 모델은 커맨드 객체로 암묵적으로 풍부해지고
              <literal>@ModelAttribute</literal> 어노테이션이 붙은 참조 데이터
              접근자(accessor) 메서드의 결과가 된다.</para>
            </listitem>
          </itemizedlist></para>
      </section>

      <section id="mvc-ann-requestparam">
        <title>요청 파라미터를 <interfacename>@RequestParam</interfacename>를
        가진 메서드 파라미터에 바인딩하기</title>

        <para>요청 파라미터를 컨트롤러의 메서드 파라미터로 바인딩하려면
        <classname>@RequestParam</classname> 어노테이션을 사용해라.</para>

        <para>다음 예제에서 사용방법을 보여준다.</para>

        <programlisting language="java">@Controller
@RequestMapping("/pets")
@SessionAttributes("pet")
public class EditPetForm {

    <lineannotation>// ...</lineannotation>

    @RequestMapping(method = RequestMethod.GET)
    public String setupForm(<emphasis role="bold">@RequestParam("petId") int petId</emphasis>, ModelMap model) {
        Pet pet = this.clinic.loadPet(petId);
        model.addAttribute("pet", pet);
        return "petForm";
    }

    <lineannotation>// ...</lineannotation></programlisting>

        <para>이 어노테이션을 사용한 파라미터는 기본적으로 필수 파라미터이지만
        <interfacename>@RequestParam</interfacename>의
        <literal>required</literal> 속성을 <literal>false</literal>로 설정해서
        (예시. <literal>@RequestParam(value="id", required=false)</literal>)
        파라미터를 선택사항으로 지정할 수 있다.</para>

        <para>대상 메서드 파라미터 타입이 <classname>String</classname>이 아니라면
        자동으로 타입변환을 한다. <xref
        linkend="mvc-ann-typeconversion" />를 참고해라.</para>
      </section>

      <section id="mvc-ann-requestbody">
        <title>@RequestBody 어노테이션으로 요청 바디 매핑하기</title>

        <para><classname>@RequestBody</classname> 메서드 파라미터 어노테이션은
        메서드 파라미터가 HTTP 요청 바디의 값에 바인딩되어야 한다는 것을 의미한다. 다음은
        그 예제이다.</para>

        <programlisting language="java">@RequestMapping(value = "/something", method = RequestMethod.PUT)
public void handle(@RequestBody String body, Writer writer) throws IOException {
  writer.write(body);
}</programlisting>

        <para><interfacename>HttpMessageConverter</interfacename>를 사용해서 요청
        바디를 메서드 인자로 변환한다.
        <interfacename>HttpMessageConverter</interfacename>가 HTTP 요청 메시지를
        객체로 변환하고 객체에서 HTTP 응답 바디로 변환하는 담당을 한다.
        <classname>RequestMappingHandlerAdapter</classname>는 다음의 기본
        <interfacename>HttpMessageConverters</interfacename>로
        <classname>@RequestBody</classname> 어노테이션을 지원한다.</para>

        <itemizedlist>
          <listitem>
            <para><classname>ByteArrayHttpMessageConverter</classname>는
            바이트 배열을 변환한다.</para>
          </listitem>

          <listitem>
            <para><classname>StringHttpMessageConverter</classname>는
            문자열을 변환한다.</para>
          </listitem>

          <listitem>
            <para><classname>FormHttpMessageConverter</classname>는 데이터를
            MultiValueMap&lt;String, String&gt;으로
            MultiValueMap&lt;String, String&gt;을 데이터로 변환한다.</para>
          </listitem>

          <listitem>
            <para><classname>SourceHttpMessageConverter</classname>는
            javax.xml.transform.Source로(에서) 변환한다.</para>
          </listitem>
        </itemizedlist>

        <para>이러한 컨버터에 대한 자세한 내용은 <link
        linkend="rest-message-conversion">메시지 컨버터</link>를 참고해라. MVC
        네임스페이스를 사용한다면 더 넓은 범위의 메시지 컨버터가 기본적으로 등독된다는 것도 기억해라.
        자세한 내용은 <xref linkend="mvc-annotation-driven" />를 참고해라.</para>

        <para>XML을 읽고 쓰고 싶다면 <classname>org.springframework.oxm</classname>
        패키지의 구체적인 <interfacename>Marshaller</interfacename>와
        <interfacename>Unmarshaller</interfacename>로
        <classname>MarshallingHttpMessageConverter</classname>를 설정해야 할
        것이다. 예를 들면 다음과 같다.</para>

        <programlisting language="xml">&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;
    &lt;property name="messageConverters"&gt;
      &lt;util:list id="beanList"&gt;
        &lt;ref bean="stringHttpMessageConverter"/&gt;
        &lt;ref bean="marshallingHttpMessageConverter"/&gt;
      &lt;/util:list&gt;
    &lt;/property
&lt;/bean&gt;

&lt;bean id="stringHttpMessageConverter"
       class="org.springframework.http.converter.StringHttpMessageConverter"/&gt;

&lt;bean id="marshallingHttpMessageConverter"
      class="org.springframework.http.converter.xml.MarshallingHttpMessageConverter"&gt;
  &lt;property name="marshaller" ref="castorMarshaller" /&gt;
  &lt;property name="unmarshaller" ref="castorMarshaller" /&gt;
&lt;/bean&gt;

&lt;bean id="castorMarshaller" class="org.springframework.oxm.castor.CastorMarshaller"/&gt;</programlisting>

        <para><classname>@RequestBody</classname> 메서드 파라미터는 설정한
        <classname>Validator</classname> 인스턴스를 사용해서 유효성검사를 하는 경우
        <classname>@Valid</classname> 어노테이션을 붙힐 수 있다. MVC 네임스페이스를
        사용한다면 JSR-303 구형체가 클래스패으세서 사용가능하다고 가정하고 JSR-303 밸리데이터를
        자동으로 설정한다. 유효성검사를 실패하면
        <classname>RequestBodyNotValidException</classname>가 발생한다. 예외는
        <classname>DefaultHandlerExceptionResolver</classname>가 처리하고 유효성검사
        오류를 담고 있는 메시지와 함께 클라이언트에게 <literal>400</literal> 오류를
        보낸다.</para>

        <note>
          <para>MVC 네임스페이스로 메시지 컨버터와 밸리데이터를 설정하는 자세한 내용은
          <xref linkend="mvc-annotation-driven" />도 참고해 봐라.</para>
        </note>
      </section>

      <section id="mvc-ann-responsebody">
        <title><interfacename>@ResponseBody</interfacename> 어노테이션으로
        응답 바디 매핑하기</title>

        <para><interfacename>@ResponseBody</interfacename> 어노테이션은
        <interfacename>@RequestBody</interfacename>와 유사하다. 이 어노테이션은
        메서드 위에 붙힐 수 있고 반환값이 HTTP 응답 바디에 바로 쓰여져야 한다는 것을 의미한다.
        (Model에는 사용할 수 없고 뷰 이름으로 해석되지 않는다.) 예를 들면 다음과 같다.</para>

        <programlisting language="java">@RequestMapping(value = "/something", method = RequestMethod.PUT)
@ResponseBody
public String helloWorld()  {
  return "Hello World";
}</programlisting>

        <para>위의 예제는 <literal>Hello World</literal> 텍스트를
        HTTP 응답 스트림에 쓸 것이다.</para>

        <para><interfacename>@RequestBody</interfacename>에서처럼 스프링은
        <interfacename>HttpMessageConverter</interfacename>를 사용해서 반환 객체를
        응답 바디로 변환한다. 이러한 컨버터에 대한 자세한 내용은 이전 섹션과 <link
        linkend="rest-message-conversion">메시지 컨버터</link>를 참고해라.</para>
      </section>

      <section id="mvc-ann-httpentity">
        <title><classname>HttpEntity&lt;?&gt;</classname> 사용하기</title>

        <para><classname>HttpEntity</classname>는
        <interfacename>@RequestBody</interfacename>,
        <interfacename>@ResponseBody</interfacename>와 유사하다. 요청 바디와 응답
        바디에 접근하듯이 <classname>HttpEntity</classname>(응답에 특화된 하위클래스인
        <classname>ResponseEntity</classname>)도 다음과 같이 요청 헤더와 응답 헤더에
        접근할 수 있다.</para>

        <programlisting language="java">@RequestMapping("/something")
public ResponseEntity&lt;String&gt; handle(HttpEntity&lt;byte[]&gt; requestEntity) throws UnsupportedEncodingException {
  String requestHeader = requestEntity.getHeaders().getFirst("MyRequestHeader"));
  byte[] requestBody = requestEntity.getBody();
  // 요청 헤더와 바디로 어떤 작업을 한다

  HttpHeaders responseHeaders = new HttpHeaders();
  responseHeaders.set("MyResponseHeader", "MyValue");
  return new ResponseEntity&lt;String&gt;("Hello World", responseHeaders, HttpStatus.CREATED);
}</programlisting>

        <para>위의 예제는 <literal>MyRequestHeader</literal> 요청 헤더 값을 가져오고
        바디를 바이트 배열로 읽는다. 그리고 응답에 <literal>MyResponseHeader</literal>를
        추가하고 응답스트림에 <literal>Hello World</literal>를 작성한 후 응답 상태코드를
        201(Created)로 설정한다.</para>

        <para><interfacename>@RequestBody</interfacename>와
        <interfacename>@ResponseBody</interfacename>에서처럼 스프링은 요청 스트림과
        응답 스트립을 변환하는데 <interfacename>HttpMessageConverter</interfacename>를
        사용한다. 이러한 컨버터에 대한 자세한 내용은 이전 섹션과 <link
        linkend="rest-message-conversion">메시지 컨버터</link>를 참고해라.</para>
      </section>

      <section id="mvc-ann-modelattrib-methods">
        <title>메서드에 <interfacename>@ModelAttribute</interfacename>
        사용하기</title>

        <para><interfacename>@ModelAttribute</interfacename> 어노테이션은 메서드나
        메서드 인자에 사용할 수 있다. 이번 섹션에서는 메서드에서 사용하는 방법을 설명하고 다음
        섹션에서는 메서드 인자에서 사용하는 방법을 설명한다.</para>

        <para>메서드에 붙은 <interfacename>@ModelAttribute</interfacename>는 하나
        이상의 모델 속성(attributes)을 추가하는 것이 해당 메서드의 목적임을 의미한다. 이러한
        메서드는 <interfacename>@RequestMapping</interfacename>와 같은 인자 타입을
        지원하지만 요청에 직접 매핑할 수는 없다. 대신에 컨트롤러의
        <interfacename>@ModelAttribute</interfacename> 메서드는 같은 컨트롤러내의
        <interfacename>@RequestMapping</interfacename> 메서드 이전에 호출된다.
        다음 두 예제를 보자.</para>

        <programlisting language="java">
// 하나의 속성을 추가한다
// 이 메서드의 반환값은 "account"라는 이름아래 있는 모델에 추가된다.
// @ModelAttribute("myAccount")로 이름을 커스터마이징 할 수 있다

@ModelAttribute
public Account addAccount(@RequestParam String number) {
    return accountManager.findAccount(number);
}

// 다중 속성 추가한다

@ModelAttribute
public void populateModel(@RequestParam String number, Model model) {
    model.addAttribute(accountManager.findAccount(number));
    // 계속 추가한다
}</programlisting>

        <para><interfacename>@ModelAttribute</interfacename> 메서드는 모델에
        공통적으로 필요한 속성을 추가하려고 사용한다. 예를 들면 상태나 pet 타입으로 드롭다운을
        채우거나 HTML 폼에서 데이터를 표현하는데 사용하려고 Account같은 커맨드 객체를 획득하는
        경우이다. 후자의 경우는 다음 섹션에서 더 자세히 얘기한다.</para>

        <para><interfacename>@ModelAttribute</interfacename> 메서드에는 두가지
        방식이 있다. 첫번째 방법은 메서드가 반환하는 값을 속성으로 추가한다. 두번째 방법은 메서드가
        <classname>Model</classname>을 받고 <classname>Model</classname>에 다수의
        모델 속성을 추가한다. 필요에 따라 이 두가지 방법중에 선택해서 사용할 수 있다.</para>

        <para>컨트롤러는 필요한 수만큼 <interfacename>@ModelAttribute</interfacename>
        메서드를 가질 수 있다. 이러한 메서드는 모두 같은 컨트롤러의
        <interfacename>@RequestMapping</interfacename> 메서드가 이전에 실행된다.</para>

        <tip>
          <para>모델 속성 명을 명시적으로 지정되지 않았을 때는 어떻게 되는가? 이러한 경우 타입에
          기반한 기본 이름이 모델 속성에 할당된다. 예를 들어 메서드가
          <classname>Account</classname> 타입의 객체를 반환하면 "account"를 기본이름으로
          사용한다. <interfacename>@ModelAttribute</interfacename> 어노테이션의 값으로
          이를 변경할 수 있다. 직접 <classname>Model</classname>에 속성을 추가한다면 적절히
          오버로드된 <literal>addAttribute(..)</literal> 메서드를 사용해라.(속성명이
          있거나 없거나)</para>
        </tip>

        <para><interfacename>@ModelAttribute</interfacename> 어노테이션을
        <interfacename>@RequestMapping</interfacename> 메서드에도 마찬가지로 사용할 수
        있다. 이러한 경우 <interfacename>@RequestMapping</interfacename> 메서드의
        반환값을 뷰 이름이 아니라 모델 속성으로 해석한다. 뷰 이름은 반환값이 없는 메서드 보다는 뷰
        이름 관례에서 얻어낸다.(<xref linkend="mvc-coc-r2vnt" /> 참고)</para>
      </section>

      <section id="mvc-ann-modelattrib-method-args">
        <title>메서드 인자에 <interfacename>@ModelAttribute</interfacename>
        사용하기</title>

        <para>이전 섹션에서 설명했듯이 메서드나 메서드 인자에
        <interfacename>@ModelAttribute</interfacename> 를 사용할 수 있다. 이번
        섹션에서는 메서드 인사에서 사용하는 방법을 설명한다.</para>

        <para>메서드 인자에 사용한 <interfacename>@ModelAttribute</interfacename>는
        모델에서 인자를 가져와야 함을 의미한다. 모델에서 제공하지 않는다면 먼저 인자가 인스턴스화
        되어야 하고 그 다음에 모델에 추가된다. 모델에 존재한다면 일치하는 이름을 가진 모든 요청
        파라미터에 필드가 존재해야 한다. 이는 스프링 MVC에서 데이터 바인딩이라고 알려져 있고 각 폼
        필드를 개별적으로 수비게 파싱할 수 있는 아주 유용한 메카니즘이다.</para>

        <programlisting language="java">
@RequestMapping(value="/owners/{ownerId}/pets/{petId}/edit", method = RequestMethod.POST)
public String processSubmit(<emphasis role="bold">@ModelAttribute Pet pet</emphasis>) {

}</programlisting>

        <para>위의 예제에서 Pet 인스턴스는 어디서 가져오는가? 몇가지 선택사항이 있다.</para>

        <itemizedlist>
          <listitem>
            <para><interfacename>@SessionAttributes</interfacename>를 사용했으므로
            이미 모델에 있을 수 있다. - <xref linkend="mvc-ann-sessionattrib" />를
            참고해라.</para>
          </listitem>

          <listitem>
            <para>이전 섹션에서 설명했듯이 같은 컨트롤러의
            <interfacename>@ModelAttribute</interfacename> 메서드때문에
            이미 모델에 있을 수 있다.</para>
          </listitem>

          <listitem>
            <para>URI 템플릿 변수와 타입 컨버터에 기반해서 얻어올 수 있다.
            (아래에서 더 자세히 설명한다.)</para>
          </listitem>

          <listitem>
            <para>기본 생성자를 사용해서 초기화할 수 있다.</para>
          </listitem>
        </itemizedlist>

        <para><interfacename>@ModelAttribute</interfacename> 메서드는
        <interfacename>@SessionAttributes</interfacename>를 사용해서 요청간에
        선택적으로 저장할 수 있는 데이터베이스에서 속성을 가져오는 일반적인 방법이다. 몇몇 경우에
        URI 템플릿 변수와 타입 컨버터를 사용해서 속성을 가져오는데 이 방법이 편리하다.
        다음은 그 예제이다.</para>

        <programlisting language="java">
@RequestMapping(value="/accounts/{account}", method = RequestMethod.PUT)
public String save(@ModelAttribute("account") Account account) {

}</programlisting>

        <para>이 예제에서 모델 속성의 이름(여기서는 "account")이 URI 템플릿 변수이름과 일치한다.
        <literal>String</literal> account 값을 <classname>Account</classname>
        인스턴스로 바꿀 수 있는 <classname>Converter&lt;String, Account&gt;</classname>를
        등록했다면 위의 예제는 <interfacename>@ModelAttribute</interfacename>
        메서드 없이도 동작할 것이다.</para>

        <para>다음 단계는 데이터 바인딩이다. <classname>WebDataBinder</classname>
        클래스는 요청 파라미터 이름(쿼리스트링 파라미터와 폼필드를 포함해서)을 모델 속성 필드의
        이름으로 매칭한다. 타입 변환(문자열에서 대상 필드 타입으로)후에 필드 매칭을 필요한 곳에
        적용한다. 데이터 바인딩과 유효성 검사는 <xref linkend="validation" />에서 다룬다.
        컨트롤러 수준의 데이터 바인딩 과정을 커스터마이징하는 것은 <xref
        linkend="mvc-ann-webdatabinder" />에서 다룬다.</para>

        <para>데이터 바인딩 결과에 따라 필요한 필드가 누락되었다거나 타입 변환 오류같은 오류가
        있을 수 있다. 이러한 오류를 확인하려면 <classname>BindingResult</classname>
        인자 바로 뒤에 <classname>BindingResult</classname> 인자를 추가해라.</para>

        <programlisting language="java">
@RequestMapping(value="/owners/{ownerId}/pets/{petId}/edit", method = RequestMethod.POST)
public String processSubmit(<emphasis role="bold">@ModelAttribute("pet") Pet pet</emphasis>, BindingResult result) {

    if (result.hasErrors()) {
        return "petForm";
    }

    // ...

}</programlisting>

        <para><classname>BindingResult</classname>에서 스프링의
        <literal>&lt;errors&gt;</literal> 폼 태그의 지원으로 오류를 볼 수 있는 동일한
        폼을 렌더링하는 것이 일반적인 경우에 오류가 있는지 확인할 수 있다.</para>

        <para>데이터 바인딩에 추가적으로 데이터 바인딩 오류를 기록하는데 사용한 같은
        <classname>BindingResult</classname>를 전달하는 자신만의 커스텀 밸리데이터를
        사용해서 유효성검사를 실행할 수도 있다. 이 방법으로 한 곳에서 데이터 바인딩과 유효성검사
        오류를 확인하고 사용자에게 보고할 수 있다.</para>

        <programlisting language="java">
@RequestMapping(value="/owners/{ownerId}/pets/{petId}/edit", method = RequestMethod.POST)
public String processSubmit(<emphasis role="bold">@ModelAttribute("pet") Pet pet</emphasis>, BindingResult result) {

    new PetValidator().validate(pet, result);
    if (result.hasErrors()) {
        return "petForm";
    }

    // ...
}</programlisting>

        <para>또는 JSR-303 <interfacename>@Valid</interfacename> 어노테이션을
        추가해서 자동으로 유효성검사가 이뤄지게 할 수 있다.</para>

        <programlisting language="java">
@RequestMapping(value="/owners/{ownerId}/pets/{petId}/edit", method = RequestMethod.POST)
public String processSubmit(<emphasis role="bold">@Valid @ModelAttribute("pet") Pet pet</emphasis>, BindingResult result) {

    if (result.hasErrors()) {
        return "petForm";
    }

    // ...
}</programlisting>

        <para>유효성검사를 설정하고 사용하는 방법은
        <xref linkend="validation-beanvalidation" />와 <xref
        linkend="validation" />를 참고해라.</para>
      </section>

      <section id="mvc-ann-sessionattrib">
        <title>요청간에 HTTP 세션의 모델 속성을 저장하는데
        <classname>@SessionAttributes</classname> 사용하기</title>

        <para>타입 수준의 <classname>@SessionAttributes</classname> 어노테이션은
        특정 핸들러가 사용하는 세션 속성을 선언한다. 이는 보통 이어지는 요청간에 폼에 기반한 빈으로
        제공하도록 세션이나 대화식 스토리지에 투명하게 저장되어야 하는 모델 속성의 이름이나
        모델 속성의 타입의 목록이다.</para>

        <para>다음 코드는 모델 속성명을 지정해서 이 어노테이션의 사용방법을 보여준다.</para>

        <programlisting language="java">@Controller
@RequestMapping("/editPet.do")
<emphasis role="bold">@SessionAttributes("pet")</emphasis>
public class EditPetForm {
    <lineannotation>// ...</lineannotation>
}</programlisting>

        <note>
          <para>컨트롤러 인터페이스(예를 들면 AOP 프록시)를 사용할 때는
          <emphasis>모든</emphasis> 매핑 어노테이션
          (<interfacename>@RequestMapping</interfacename>와
          <interfacename>@SessionAttributes</interfacename>같은)을 구현 클래스가
          아니라 컨트롤러 <emphasis>인터페이스</emphasis>에 일관성있게 써야 한다.</para>
        </note>
      </section>

      <section id="mvc-ann-redirect-attributes">
        <title>리다이렉트와 플래시(flash) 속성 지정하기</title>

        <para>기본적으로 모든 모델 속성은 리다이렉트 URL의 URI 템플릿 변수로 노출하는 것으로
        간주한다. 프리미티브 타입이나 프리미티브 타입의 컬렉션/배열의 남은 속성들은 자동적으로
        쿼리 파라미터로 추가한다.</para>

        <para>하지만 어노테이션이 붙은 컨트롤러에서 모델은 렌더링을 위해서 처음부터 추가된 부가적인
        속성들을 가지고 있을 수 있다.(예를 들면 드롭다운 필드값) 리다이렉트 시나리오에서 사용한
        속성을 정확하게 제어하려고 <interfacename>@RequestMapping</interfacename>
        메서드가 <interfacename>@RequestMapping</interfacename> 타입의 인자를 선언하고
        <classname>RedirectView</classname>에서 사용하기 위해 속성에 추가하려고 이를
        사용할 수 있다. 컨트롤러 메서드가 리다이렉트를 한다면
        <interfacename>RedirectAttributes</interfacename>의 내용을 사용한다.
        리다이렉트 하지 않는다면 기본 <interfacename>Model</interfacename>의 내용을
        사용한다.</para>

        <para><classname>RequestMappingHandlerAdapter</classname>는
        컨트롤러 메서드가 리다이렉트한다면 기본
        <classname>RequestMappingHandlerAdapter</classname>를 절대 사용하지 말아야
        한다는 의미로 사용할 수 있는 <literal>"ignoreDefaultModelOnRedirect"</literal>라는
        플래그를 제공한다. 그렇지 않으면 컨트롤러 메서드가
        <interfacename>RedirectAttributes</interfacename> 타입의 속성을 선언해야 한다.
        선언하지 않았다면 <classname>RedirectView</classname>에 전달되어야 하는 속성은
        없다. MVC 네임스페이스와 MVC Java config
        (<interfacename>@EnableWebMvc</interfacename>를 통해서) 둘 다 하위 호환성을
        유지하기 위해 이 플래스를 <literal>false</literal>로 설정하고 있다. 하지만 새로운
        어플리케이션에서는 이 플래그를 <literal>true</literal>로 설정하기를 권장한다.</para>

        <para><interfacename>RedirectAttributes</interfacename> 인터페이스도
        플래시(flash) 속성을 추가하는데 사용할 수 있다. 대상 리다이렉트 URL이 되는 리다이렉트
        속성과는 달리 플래시 속성은 HTTP 세션에 저장된다.(그래서 URL에 나타나지 않는다.)
        대상 리다이렉트 URL을 제공하는 컨트롤러의 모델은 자동으로 세션에서 플래시 속성을 제거한 후
        이러한 플래시 속성을 받는다. 스프링 MVC 플래시 속성에 대한 일반적인 지원은
        <xref linkend="mvc-flash-attributes" />를 참고해라.</para>
      </section>

      <section id="mvc-ann-form-urlencoded-data">
        <title><literal>"application/x-www-form-urlencoded"</literal>
        데이터에서 동작하기</title>

        <para>브라우저 클라이언트의 폼 제출(form submission) 요청을 지원하는
        <interfacename>@ModelAttribute</interfacename>의 사용은 이전 섹션에서 다루었다.
        같은 어노테이션을 브라우저가 아닌 클라이언트의 요청에 사용하는 것도 권장한다. 하지만 HTTP
        PUT 요청에서 사용할 때 한가지 중요한 차이점이 있다. 브라우저는 HTTP GET이나 HTTP POST로
        폼 데이터를 제출할 수 있다. 브라우저가 아닌 클라이언트는 HTTP PUT으로도 폼을 제출할 수 있다.
        서블릿 명세가 HTTP PUT이 아니라 HTTP POST에서만 폼 필드 접근을 지원하는 메서드의
        <literal>ServletRequest.getParameter*()</literal> 계열을 필요로 하기 때문에
        문제점이 생긴다.</para>

        <para>HTTP PUT 요청을 지원하려면 <literal>spring-web</literal> 모듈이
        <filename>web.xml</filename>에서 설정할 수 있는
        <classname>HttpPutFormContentFilter</classname> 필터를 제공해야 한다.</para>

        <programlisting language="xml">&lt;filter&gt;
  &lt;filter-name&gt;httpPutFormFilter&lt;/filter-name&gt;
  &lt;filter-class&gt;org.springframework.web.filter.HttpPutFormContentFilter&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
  &lt;filter-name&gt;httpPutFormFilter&lt;/filter-name&gt;
  &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
&lt;/filter-mapping&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;</programlisting>

        <para>위의 필터는 <literal>application/x-www-form-urlencoded</literal>
        컨텐트 타입의 HTTP PUT 요청을 가로채서 요청 바디에서 폼 데이터를 읽고 메서드의
        <literal>ServletRequest.getParameter*()</literal> 계열로 폼 데이터를 사용할
        수 있도록 <classname>ServletRequest</classname>로 감싼다.</para>
      </section>

      <section id="mvc-ann-cookievalue">
        <title>@CookieValue 어노테이션으로 쿠키(cookie) 값 매핑하기</title>

        <para><interfacename>@CookieValue</interfacename> 어노테이션은 메서드
        파라미터를 HTTP 쿠키 값에 바인딩되도록 한다.</para>

        <para>http 요청과 함께 받은 다음의 쿠키를 보자.</para>

        <programlisting>JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</programlisting>

        <para>다음 코드 예제는 <literal>JSESSIONID</literal> 쿠키의 값을
        얻는 방법을 보여준다.</para>

        <programlisting language="java">@RequestMapping("/displayHeaderInfo.do")
public void displayHeaderInfo(<emphasis role="bold">@CookieValue("JSESSIONID")</emphasis> String cookie)  {

  //...

}</programlisting>

        <para>대상 메서드 파라미터 타입이 <classname>String</classname>이 아니면 타입
        변환은 자동으로 적용된다. <xref linkend="mvc-ann-typeconversion" />를
        참고해라.</para>

        <para>이 어노테이션은 서블릿 환경과 포틀릿 환경에서 어노테이션이 붙은 핸들러 메서드를
        지원한다.</para>
      </section>

      <section id="mvc-ann-requestheader">
        <title>@RequestHeader 어노테이션으로 요청 헤더 속성 매핑하기</title>

        <para><interfacename>@RequestHeader</interfacename> 어노테이션은 메서드
        파라미터를 요청 헤더에 바인딩하도록 한다.</para>

        <para>다음은 요청 헤더의 예시이다.</para>

        <programlisting>
Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300</programlisting>

        <para>다음 예제 코드는 <literal>Accept-Encoding</literal>와
        <literal>Keep-Alive</literal> 헤더의 값을 얻는 방법을 보여준다.</para>

        <programlisting language="java">@RequestMapping("/displayHeaderInfo.do")
public void displayHeaderInfo(<emphasis role="bold">@RequestHeader("Accept-Encoding")</emphasis> String encoding,
                              <emphasis role="bold">@RequestHeader("Keep-Alive")</emphasis> long keepAlive)  {

  //...

}</programlisting>

        <para>메서드 파라미터가 <classname>String</classname>가 아니라면 타입변환을 자동으로
        적용한다. <xref linkend="mvc-ann-typeconversion" />를 참고해라.</para>

        <tip>
          <para>콤마로 구분된 문자열을 문자열의 배열/컬렉션이나 타입 변환 시스템이 알고 있는
          다른 타입으로 변환할 때 내장(built-in) 지원을 사용할 수 있다. 예를 들어
          <literal>@RequestHeader("Accept")</literal> 어노테이션이 붙은 메서드 파라미터는
          <classname>String</classname>의 타입이지만 <classname>String[]</classname>나
          <classname>List&lt;String&gt;</classname>도 될 수 있다.</para>
        </tip>

        <para>이 어노테이션은 서브릿 환경과 포틀릿 환경에서 어노테이션이 붙은 핸들러
        메서드를 지원한다.</para>
      </section>

      <section id="mvc-ann-typeconversion">
        <title>메서드 파라미터와 타입 변환</title>

        <para>요청 파라미터, 경로 변수, 요청 해더, 쿠키 값등 요청에서 추출한  문자열 기반의 값들은
        바인딩해야 하는 메서드 파라미터나 필드의 대상 타입으로 변환해야 한다.(예시. 요청 파라미터를
        <interfacename>@ModelAttribute</interfacename> 파라미터의 필드에 바인딩하기)
        대상 타입이 <classname>String</classname>이 아니라면 스프링이 자동으로 적절한
        타입으로 변환한다. int, long, Date 등의 모든 간단한 타입을 지원한다.
        <classname>WebDataBinder</classname>(<xref
        linkend="mvc-ann-webdatabinder" /> 참고)를 사용하거나
        <classname>FormattingConversionService</classname>로
        <classname>Formatters</classname>를 등록해서(<xref
        linkend="format" /> 참고) 변환 과정을 커스터마이징 할 수 있다.</para>
      </section>

      <section id="mvc-ann-webdatabinder">
        <title><classname>WebDataBinder</classname> 초기화 커스터마이징</title>

        <para>스프링의 <classname>WebDataBinder</classname>를 통해서
        PropertyEditors로 요청 파라미터 바인딩으로 커스터마이징하려면 컨트롤러내의
        <interfacename>@InitBinder</interfacename> 어노테이션이 붙은 메서드를 사용하거나
        커스텀 <interfacename>WebBindingInitializer</interfacename>를 제공해서
        설정을 구체화해서 사용할 수 있다.</para>

        <section id="mvc-ann-initbinder">
          <title><interfacename>@InitBinder</interfacename>로
          데이터바인딩 커스터마이징하기</title>

          <para><interfacename>@InitBinder</interfacename> 어노테이션이 붙은 컨트롤러
          메서드는 컨트롤러 클래스내에서 직접 웹 데이터 바인딩을 설정할 수 있도록 한다.
          <interfacename>@InitBinder</interfacename>는 어노테이션이 붙은 핸들러 메서드의
          커맨드 객체 인자와 폼 객체 인자를 존재하게 하는데 사용할
          <classname>WebDataBinder</classname>를 추기화하는 메서드를 식별한다.</para>

          <para>이러한 init-binder 메서드들은 커맨드/폼 객체와 이에 대응되는 유효성 검사결과
          객체를 제외하고 <interfacename>@RequestMapping</interfacename>이 지원하는
          모든 인자를 지원한다. init-binder 메서드들은 반환값을 갖지 말아야 한다. 그러므로 보통
          <literal>void</literal>로 선언한다. <interfacename>WebRequest</interfacename>나
          <classname>java.util.Locale</classname>를 섞어서 사용할 때
          <classname>WebDataBinder</classname>를 포함한 대표적인 인자들은 컨텍스트에
          특화된 에디터를 등록하는 코드를 작성할 수 있게 한다.</para>

          <para>다음 예제는 모든 <classname>java.util.Date</classname> 폼
          프로퍼티에 <classname>CustomDateEditor</classname>를 설정하는
          <interfacename>@InitBinder</interfacename>를 사용하는 방법을
          보여준다.</para>

          <programlisting language="java">@Controller
public class MyFormController {

    <emphasis role="bold">@InitBinder</emphasis>
    public void initBinder(WebDataBinder binder) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        dateFormat.setLenient(false);
        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
    }

    <lineannotation>// ...</lineannotation>
}</programlisting>
        </section>

        <section id="mvc-ann-webbindinginitializer">
          <title>커스텀 <interfacename>WebBindingInitializer</interfacename>
          설정</title>

          <para>데이터 바인딩 초기화를 구체화하려고
          <interfacename>WebBindingInitializer</interfacename> 인터페이스의 커스텀
          구현체를 제공할 수 있다. <classname>AnnotationMethodHandlerAdapter</classname>에
          대한 커스텀 빈 설정을 제공해서 활성화할 수 있으므로 기본 설정을 오버라이딩한다.</para>

          <para>PetClinic 어플리케이션에서 가져온 다음 예제는
          <interfacename>WebBindingInitializer</interfacename> 인터페이스의 커스텀
          구현체로 여러 PetClinic 컨트롤러가 필요로 하는 PropertyEditors를 설정하는
          <classname>org.springframework.samples.petclinic.web.ClinicBindingInitializer</classname>를
          사용한 설정을 보여준다.</para>

          <programlisting language="xml">&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;
    &lt;property name="cacheSeconds" value="0" /&gt;
    &lt;property name="webBindingInitializer"&gt;
        &lt;bean class="org.springframework.samples.petclinic.web.ClinicBindingInitializer" /&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
        </section>
      </section>

      <section id="mvc-ann-lastmodified">
        <title>내용을 캐싱을 쉽게하는 'Last-Modified' 응답헤더의 지원</title>

        <para>내용 캐싱을 쉽게 하려고 <interfacename>@RequestMapping</interfacename>
        메서드가 서블릿 API의 <literal>getLastModified</literal> 메서드 계약에 정의된 대로
        <literal>'Last-Modified'</literal> HTTP요청을 지원하기를 바랄 것이다. 이는 해당
        요청의 <literal>'If-Modified-Since'</literal> 요청헤더 값과 비교해서 마지막으로
        수정된 <literal>long</literal> 값을 계산하는 것을 포함하고 304 (Not Modified)
        상태코드로 응답을 보낼 가능성이 있다. 어노테이션이 붙은 컨트롤러 메서드를 다름과 같이
        작성할 수 있다.</para>

        <programlisting language="java">
@RequestMapping
public String myHandleMethod(WebRequest webRequest, Model model) {

    long lastModified = // 1. 어플리케이션에 특화된 계산

    if (request.checkNotModified(lastModified)) {
        // 2. 빠른 종료 - 더이상 처리가 필요없다
        return null;
     }

    // 3. 아니면 요청을 추가로 처리하고 컨텐츠를 실제로 준비한다
    model.addAttribute(...);
    return "myViewName";
}</programlisting>

        <para>알아두어야 할 핵심요소가 두가지 있는데
        <code>request.checkNotModified(lastModified)</code> 호출과
        <literal>null</literal> 반환이다. 전자는 <literal>true</literal>를
        반환하기 전에 응답 상태를 304롤 설정하한다. 후자는 전자와 함께 사용해서 스프링 MVC가
        요청을 더이상 처리하지 않도록 한다.</para>
      </section>
    </section>
  </section>

  <section id="mvc-handlermapping">
    <title>핸들러 매핑</title>

    <para>스프링의 과거 버전에서는 들어오는 웹 요청을 적절한 핸들러에 매칭하기 위해 사용자들이
    웹 어플리케이션 컨텍스트에 하나 이상의 <interfacename>HandlerMapping</interfacename>
    빈을 정의해야 했다. 어노테이션이 붙은 컨트롤러의 도입으로
    <classname>RequestMappingHandlerMapping</classname>이 자동으로 모든
    <interfacename>@Controller</interfacename> 빈의
    <interfacename>@RequestMapping</interfacename> 어노테이션을 검색하므로 보통은 사용자가
    <interfacename>HandlerMapping</interfacename> 빈을 정의할 필요가 없다. 하지만
    <classname>HandlerMapping</classname>를 확장한 모든
    <classname>HandlerMapping</classname> 클래스는 동작을 커스터마이징할 때 사용할 수
    있는 다음의 프로퍼티를 가진다는 것을 가진다는 것을 기억해 두어야 한다.</para>

    <variablelist>
      <varlistentry>
        <term><literal>interceptors</literal></term>

        <listitem>
          <para>사용할 인터셉터의 목록. <interfacename>HandlerInterceptor</interfacename>는
          <xref linkend="mvc-handlermapping-interceptor" />에서 설명한다.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>defaultHandler</literal></term>

        <listitem>
          <para>매칭되는 핸들러를 찾지 못했을 때 사용할 기본 핸들러.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>order</literal></term>

        <listitem>
          <para>스프링은 order 프로퍼티 값에 기반해서 컨텍스트에서 사용할 수 있는
          모든 핸들러 매핑을 정렬하고 가장 먼저 일치하는 핸들러를 적용한다.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>alwaysUseFullPath</literal></term>

        <listitem>
          <para>이 값이 <literal>true</literal>이면 스프링은 적절한 핸들러를 찾을 때 현재
          서블릿 컨텍스트 내에서 전체 경로를 사용한다. <literal>false</literal>(기본값)이면
          현재 서블릿 매핑내에서 경로를 사용한다. 예를 들어 서블릿이
          <literal>/testing/*</literal>로 매핑되어 있고
          <literal>alwaysUseFullPath</literal> 프로퍼티가 true이면
          <literal>/testing/viewPage.html</literal>를 사용하고 이 프로퍼티가
          false이면 <literal>/viewPage.html</literal>를 사용한다.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>urlDecode</literal></term>

        <listitem>
          <para>스프링 2.5부터 기본값은 <literal>true</literal>이다. 인코딩된 경로를
          비교하는 것을 좋아한다면 이 플래그를 <literal>false</literal>로 설정해라. 하지만
          <interfacename>HttpServletRequest</interfacename>는 항상 디코딩된 형식으로
          서블릿 경로를 노출한다. 인코딩된 경로와 비교할 때는 서블릿 경로가 매치되지 않는 다는 것을
          알아두어라.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>다음 예제는 인터셉터를 설정하는 방법을 보여준다.</para>

    <programlisting language="xml">&lt;beans&gt;
  &lt;bean id="handlerMapping" class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;
    &lt;property name="interceptors"&gt;
      &lt;bean class="example.MyInterceptor"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;beans&gt;</programlisting>

    <section id="mvc-handlermapping-interceptor">
      <title>Intercepting requests with a
      <interfacename>HandlerInterceptor</interfacename></title>

      <para>스프링의 핸들러 매핑 메카니즘은 특정 요청에 어떤 기능을 적용하기를 원할 때 유용한
      핸들러 인터셉터를 포함한다. 재산을 확인하는(checking for a principal)등의 기능을
      적용하는 경우이다.</para>

      <para>핸들러 매핑에 있는 인터셉터들은
      <literal>org.springframework.web.servlet</literal> 패키지의
      <interfacename>HandlerInterceptor</interfacename>를 구현해야 한다. 이
      인터페이스는 세개의 메서드를 정의하고 있다. <literal>preHandle(..)</literal>는 실제
      핸들러를 실행하기 <emphasis>전에</emphasis> 호출한다.
      <literal>postHandle(..)</literal>는 핸들러를 실행한 <emphasis>후에</emphasis>
      실행한다. <literal>afterCompletion(..)</literal>는 <emphasis>요청을 완전히 종료한
      후에</emphasis> 호출한다. 이는 세 메서드들은 모든 종류의 전처리와 후처리를 할 수 있는 충분한
      유연성을 제공한다.</para>

      <para><literal>preHandle(..)</literal> 메서드는 불리언 값을 반환한다. 실행 체인의
      처리를 멈추거나 계속 진행할 때 이 메서드를 사용할 수 있다. 이 메서드가
      <literal>true</literal>를 반환하면 핸들러 실행 체인이 계속 될 것이다. false를 반환하면
      <classname>DispatcherServlet</classname>는 인터셉터가 직접 요청을 처리한다고
      가정하고(예를 들어 적절한 뷰를 렌더링하는 등) 실행 체인의 다른 인터셉터와 실제 핸들러를
      더이상 실행하지 않는다.</para>

      <para><classname>AbstractHandlerMapping</classname>을 확장한 모든
      <classname>HandlerMapping</classname> 클래스가 있는
      <literal>interceptors</literal>를 사용해서 인터셉터를 설정할 수 있다.
      다음 예제에서 이를 보여준다.</para>

      <programlisting language="xml">&lt;beans&gt;
    &lt;bean id="handlerMapping"
          class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;
        &lt;property name="interceptors"&gt;
            &lt;list&gt;
                &lt;ref bean="officeHoursInterceptor"/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="officeHoursInterceptor"
          class="samples.TimeBasedAccessInterceptor"&gt;
        &lt;property name="openingTime" value="9"/&gt;
        &lt;property name="closingTime" value="18"/&gt;
    &lt;/bean&gt;
&lt;beans&gt;</programlisting>

      <programlisting language="java">package samples;

public class TimeBasedAccessInterceptor extends HandlerInterceptorAdapter {

    private int openingTime;
    private int closingTime;

    public void setOpeningTime(int openingTime) {
        this.openingTime = openingTime;
    }

    public void setClosingTime(int closingTime) {
        this.closingTime = closingTime;
    }

    public boolean preHandle(
            HttpServletRequest request,
            HttpServletResponse response,
            Object handler) throws Exception {

        Calendar cal = Calendar.getInstance();
        int hour = cal.get(HOUR_OF_DAY);
        if (openingTime &lt;= hour &amp;&amp; hour &lt; closingTime) {
            return true;
        } else {
            response.sendRedirect("http://host.com/outsideOfficeHours.html");
            return false;
        }
    }
}</programlisting>

      <para>이 매핑이 처리하는 모든 요청은
      <classname>TimeBasedAccessInterceptor</classname>가 가로챈다. 현재 시간이
      근무시간이 아니라면 사용자를 근무시간에만 웹사이트에 접근할 수 있다는 정적 HTML 파일로
      리다이렉트 한다</para>

      <note>
        <para><classname>RequestMappingHandlerMapping</classname>를 사용할 때
        실제 핸들러는 호출될 특정 컨트롤러 메서드를 식별하는
        <classname>HandlerMethod</classname>의 인스턴스이다.</para>
      </note>

      <para>볼 수 있듯이 스프링 아답터 클래스인
      <classname>HandlerInterceptorAdapter</classname>는
      <interfacename>HandlerInterceptor</interfacename> 인터페이스를
      확장하기 쉽게 해준다.</para>

      <tip>
        <para>위의 예제에서 어노테이션이 붙은 컨트롤러 메서드가 처리하는 모든 요청에 설정한
        인터셉터를 적용할 것이다. 인터셉터 적용을 URL 경로에 따라 제한하려면 MVC 네임스페이스를
        사용해서 제한할 수 있다. <xref linkend="mvc-annotation-driven" />를
        참고해라.</para>
      </tip>
    </section>
  </section>

  <section id="mvc-viewresolver">
    <title>뷰 처리</title>

    <para>웹 어플리케이션에 대한 모든 MVC 프레임워크는 뷰를 처리하는 방법을 제공한다. 스프링은
    특정 뷰 기술을 사용하지 않고도 브라우저에서 모델을 렌더링할 수 있게 하는 뷰 리졸버
    (view resolver)를 제공한다. 예를 들어 스프링에서는 JSP, Velocity 템플릿, XSLT 뷰를
    사용할 수 있다. 다수의 다른 뷰 기술들을 통합하고 사용하는 방법은
    <xref linkend="view" />를 참고해라.</para>

    <para>스프링이 뷰를 처리하는데 중요한 두가지 인터페이스는
    <interfacename>ViewResolver</interfacename>와
    <interfacename>View</interfacename>이다.
    <interfacename>ViewResolver</interfacename>는 뷰 이름과 실제 뷰사이에 매핑을 한다.
    <interfacename>View</interfacename> 인터페이스는 요청을 준비하고 뷰 기술들을 사용해서
    요청을 처리한다.</para>

    <section id="mvc-viewresolver-resolver">
      <title><interfacename>ViewResolver</interfacename> 인터페이스로
      뷰 처리하기</title>

      <para><xref linkend="mvc-controller" />에서 얘기했듯이 스프링 웹 MVC 컨트롤러의
      모든 핸들러 메서드는 명시적이나(<literal>String</literal>, <literal>View</literal>,
      <literal>ModelAndView</literal>를 반환하는 등) 암시적으로(관례에 기반해서) 논리적인
      뷰 이름을 처리해야 한다. 스프링의 뷰는 논리적인 뷰 이름으로 처리되고 뷰 리졸버가 처리한다.
      스프링에는 아주 약간의 뷰 리졸버를 가진고 있다. 다음 표에 리졸버의 대부분이 나와있고 표
      뒤에 약간의 예제가 있다.</para>

      <table id="mvc-view-resolvers-tbl">
        <title>뷰 리졸버</title>

        <tgroup cols="2">
          <colspec colname="c1" colwidth="1*" />

          <colspec colname="c2" colwidth="2*" />

          <thead>
            <row>
              <entry><interfacename>ViewResolver</interfacename></entry>

              <entry>설명</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><classname>AbstractCachingViewResolver</classname></entry>

              <entry>뷰를 캐시하는 추상 뷰 리졸버. 때로는 뷰를 사용할 수 있기 전에 뷰를
              준비해야 한다. 이 뷰 리졸버를 확장해서 캐싱을 제공한다.</entry>
            </row>

            <row>
              <entry><classname>XmlViewResolver</classname></entry>

              <entry>스프링의 XML 빈 팩토리와 같은 DTD를 사용하고 XML로 작성한 설정파일을
              받는 <interfacename>ViewResolver</interfacename>의 구현체. 기본 설정
              파일은 <literal>/WEB-INF/views.xml</literal>이다.</entry>
            </row>

            <row>
              <entry><classname>ResourceBundleViewResolver</classname></entry>

              <entry><classname>ResourceBundle</classname>의 빈 정의를 사용하는
              <interfacename>ViewResolver</interfacename>의 구현체로 번들에 기반한
              이름(bundle base name)으로 지정한다. 보통 클래스 패스에 있는 프로퍼티 파일에
              번들을 정의한다. <!--Correct to say you define? Seems so, because default implies you can change it.-->
              기본 파일명은 <literal>views.properties</literal>이다.</entry>
            </row>

            <row>
              <entry><classname>UrlBasedViewResolver</classname></entry>

              <entry>명시적으로 패밍을 정의하지 않고 논리적인 뷰 이름을 URL로 직접 처리하는
              <interfacename>ViewResolver</interfacename> 인터페이스의 간단한 구현체.
              임의의 매핑을 하지 않고 직곽적인 방법으로 논리적인 이름이 뷰 리소스의 이름과
              일치할 때 적합한다.</entry>
            </row>

            <row>
              <entry><classname>InternalResourceViewResolver</classname></entry>

              <entry><classname>InternalResourceView</classname>(사실상 서블릿과
              JSP)와 <classname>JstlView</classname>와
              <classname>TilesView</classname>같은 하위클래스를 지원하는
              <classname>UrlBasedViewResolver</classname>의 편리한 하위클래스.
              <literal>setViewClass(..)</literal>를 사용해서 이 리졸버가 생성하는 모든
              뷰에 대한 뷰 클래스를 지정할 수 있다. 자세한 내용은
              <classname>UrlBasedViewResolver</classname> 클래스의 Javadoc을
              참고해라.</entry>
            </row>

            <row>
              <entry><classname>VelocityViewResolver</classname> /
              <classname>FreeMarkerViewResolver</classname></entry>

              <entry><classname>VelocityView</classname>(사실상 Velocity
              템플릿)이나 <classname>FreeMarkerView</classname>와 이 둘의 커스텀
              하위클래스를 각각 지원하는 <classname>UrlBasedViewResolver</classname>의
              편리한 하위 클래스.</entry>
            </row>

            <row>
              <entry><classname>ContentNegotiatingViewResolver</classname></entry>

              <entry>요청 파일명이나 <literal>Accept</literal> 헤더에 기반한 뷰를
              처리하는 <interfacename>ViewResolver</interfacename>의 구현체.
              <xref linkend="mvc-multiple-representations" />를
              참고해라.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>뷰 기술로 JSP를 사용하는 예제에
      <classname>UrlBasedViewResolver</classname>를 사용할 수 있다. 이 뷰 리졸버는
      뷰 이름을 URL로 변환하고 뷰를 렌더링하는 RequestDispatcher로 요청을 처리한다.</para>

      <programlisting language="xml">&lt;bean id="viewResolver"
      class="org.springframework.web.servlet.view.UrlBasedViewResolver"&gt;
    &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;
    &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;
    &lt;property name="suffix" value=".jsp"/&gt;
&lt;/bean&gt;</programlisting>

      <para>논리적인 뷰 이름으로 <literal>test</literal>를 반환할 때 이 뷰 리졸버는
      <literal>/WEB-INF/jsp/test.jsp</literal>로 요청을 보낼
      <classname>RequestDispatcher</classname>로 요청을 보낸다.</para>

      <para>웹 어플리케이션에 다른 뷰 기술들을 섞어서 사용할 때는
      <classname>ResourceBundleViewResolver</classname>를 사용할 수 있다.</para>

      <programlisting language="xml">&lt;bean id="viewResolver"
      class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
    &lt;property name="basename" value="views"/&gt;
    &lt;property name="defaultParentView" value="parentView"/&gt;
&lt;/bean&gt;</programlisting>

      <para><classname>ResourceBundleViewResolver</classname>는 기반이 되는
      이름(basename)으로 식별되는 <classname>ResourceBundle</classname>를 검사하고 처리될
      각 뷰는 뷰 클래스로 <literal>[viewname].(class)</literal> 프로퍼티의 값을 사용하고 뷰
      URL로 <literal>[viewname].url</literal> 프로퍼티 값을 사용한다. 예제는 뷰 기술을
      다루는 다음 장에서 볼 수 있다. 여기서 보듯이 프로퍼티 파일을 <quote>확장</quote>한 모든
      뷰에서 부모 뷰를 식별할 수 있다. 이 방법으로 기본 뷰를 지정할 수 있다. 예를 들면 다음과
      같다.</para>

      <note>
        <para><classname>AbstractCachingViewResolver</classname>의 하위클래스들은
        처리하는 뷰 인스턴스를 캐싱한다. 캐싱은 뷰 기술의 성능을 향상시킨디ㅏ.
        <literal>cache</literal> 프로퍼티를 <literal>false</literal>로 설정해서
        캐시를 끄는 것도 가능하다. 게다가 런타임에서 어떤 뷰를 갱신해야 한다면(예를 들어 Velocity
        템플릿을 수정했을 때) <literal>removeFromCache(String viewName, Locale
        loc)</literal> 메서드를 사용할 수 있다.</para>
      </note>
    </section>

    <section id="mvc-viewresolver-chaining">
      <title>뷰리졸버 캐싱</title>

      <para>스프링은 다중 뷰 리졸버를 지원한다. 그러므로 리졸버를 체인으로 연결할 수 있다.
      예를 들어 특정 상황해서 어떤 뷰를 오버라이드 할 수 있다. 필요하다면 어플리케이션 컨텍스트에
      하나 이상의 리졸버를 추가하고 순서를 나타내려고 <literal>order</literal> 프로퍼티를
      설정해서 뷰 리졸버를 체인으로 연결한다. 숫자가 높은 order 프로퍼티의 뷰 리졸버가 체인에서
      나중에 위치한다는 것을 기억해라.</para>

      <para>다음 예제에서 뷰 리졸버의 체인은 두가지 리졸버로 구성되어 있는데 자동으로 항상 체인에
      마지막 리졸버가 되는 <classname>InternalResourceViewResolver</classname>와 엑셀
      뷰를 지정하는 <classname>XmlViewResolver</classname>이다.
      <classname>InternalResourceViewResolver</classname>는 엑셀 뷰를 지원하지 않는다.<!--Do you need to say anything else about excel not being supported by one of resolvers? What if anything is the result?--></para>

      <programlisting language="xml">&lt;bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
  &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;
  &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;
  &lt;property name="suffix" value=".jsp"/&gt;
&lt;/bean&gt;

&lt;bean id="excelViewResolver" class="org.springframework.web.servlet.view.XmlViewResolver"&gt;
  &lt;property name="order" value="1"/&gt;
  &lt;property name="location" value="/WEB-INF/views.xml"/&gt;
&lt;/bean&gt;

<lineannotation>&lt;!-- <literal>views.xml</literal>에서 --&gt;</lineannotation>

&lt;beans&gt;
  &lt;bean name="report" class="org.springframework.example.ReportExcelView"/&gt;
&lt;/beans&gt;</programlisting>

      <para>어떤 뷰 리졸버가 뷰로 처리되지 않는다면 스프링은  다른 뷰 리졸버가 있는지 컨텍스트를
      검사한다. 다른 뷰 리졸버가 존재한다면 스프링은 뷰를 처리할 때까지 뷰 리졸버를 계속해서
      검사한다. 어떤 뷰리졸버도 뷰를 반환하지 않는다면 스프링은
      <classname>ServletException</classname>를 던진다.</para>

      <para>뷰 리졸버의 계약에 따라 뷰를 찾을 수 없다는 의미로 null을 반환<emphasis>할 수
      있다</emphasis>. 하지만 어떤 경우에는 리졸버가 뷰가 존재하는지 존재하지 않는지 탐지할 수
      없으므로 모든 뷰 리졸버가 null을 반환하는 것은 아니다. 예를 들어
      <classname>InternalResourceViewResolver</classname>는 내부적으로
      <classname>RequestDispatcher</classname>를 사용하고 JSP가 존재하는지 찾아내는
      유일한 방법은 디스패칭을 하는 것이지만 이 동작은 딱 한번만 실행할 수 있다.
      <classname>VelocityViewResolver</classname>와 다른 몇몇 뷰 리졸버에서도 동일하다.
      존재하지 않는 뷰를 보고하는지를 확인하려면 뷰 리졸버의 Javadoc을 확인해라. 그러므로 체인의
      마지막이 아닌 다른 위치에 <classname>InternalResourceViewResolver</classname>를
      두면 <classname>InternalResourceViewResolver</classname>는
      <emphasis>항상</emphasis> 뷰를 반환할 것이기 때문에 체인을 완전히 검사하지 않게
      된다!<!--I don't understand the logic of this. How can it return a view if no view exists or no view can be found? this paragraph is confusing.--><!--Why would you put InternalResourceViewResolver in place other than last? It's automatically last. --></para>
    </section>

    <section id="mvc-redirecting">
      <title>뷰를 리다이렉트하기<!--Revise to say what you are redirecting to views. OR are you redirecting views? In that case heading should be Redirecting views.--></title>

      <para>앞에서 얘기했듯이 컨트롤러는 보통 뷰 리졸버가 특정 뷰 기술로 처리하는 논리적인 뷰
      이름을 반환한다. 서블릿이나 JSP 엔진으로 처리하는 JSP같은 뷰 기술에서 이 해결책은 보통
      <classname>InternalResourceViewResolver</classname>와
      <classname>InternalResourceView</classname>를 결합해서 내부적으로 계속 진행하거나
      서블릿 API의 <literal>RequestDispatcher.forward(..)</literal> 메서드나
      <literal>RequestDispatcher.include()</literal> 메서드로 처리한다. Velocity,
      XSLT같은 다른 뷰 기술에서는 뷰가 직접 응답 스트립에 내용을 작성한다.</para>

      <para>때로는 뷰를 렌더링하기 전에 클라이언트에 HTTP 리다이렉트를 보내기를 원할 수 있다. 예를
      들면 어떤 컨트롤러가 <literal>POST</literal>된 데이터로 호출했을 때 실제 응답은 다음
      컨트롤러(예를 들면 성공한 폼 제출에서)에 위임하기를 원할 수 있다. 이러한 경우 보통의 내부적인
      포워딩은 다른 컨트롤러도 같은 <literal>POST</literal> 데이터를 본다는 것을 의미하는데
      기대한 다른 데이터와 혼동할 수 있다면 잠재적으로 문제의 소지가 될 수 있다. 결과를 보여주기 전에
      리다이렉트를 하는 또다른 이유는 사용자가 폼 데이터를 여러번 제출할 가능성을 없애기 위함이다. 이
      시나리오에서 브라우저는 최초 <literal>POST</literal>를 먼저 보낼 것이다. 그 다음 다른
      URL로 리다이렉트하는 응답을 받을 것이다. 마지막으로 브라우저는 리다이렉트 응답에 있는 URL로
      <literal>GET</literal>을 이어서 수행할 것이다. 그러므로 브라우저의 관점에서 현재 페이지는
      <literal>POST</literal>의 결과가 아니라 <literal>GET</literal>의 결과이다. 결국
      사용자가 페이지 갱신을 해서 같은 데이터를 의도치않게 다시 <literal>POST</literal> 할 수
      없게 되는 효과가 있다. 갱신을 하면 최초 <literal>POST</literal> 데이터를 다시 보내는
      것이 아니라 결과페이지의 <literal>GET</literal>을 다시 수행한다.</para>

      <section id="mvc-redirecting-redirect-view">
        <title><classname>RedirectView</classname></title>

        <para>컨트롤러 응답의 결과로 리다이렉트를 강제하는 한가비 방법은 컨트롤러가 스프링의
        <classname>RedirectView</classname>의 인스턴스를 생성해서 반환하는 것이다.
        이 경우에 <classname>DispatcherServlet</classname>이 일반적인 뷰 처리 메카니즘을
        사용하지 않는다. 오히려 <classname>DispatcherServlet</classname>에는 이미
        (리다이렉트)뷰가 주어졌으므로 뷰가 뷰의 작업을 하도록 지시한다.</para>

        <para><classname>RedirectView</classname>는 HTTP 리다이렉트를 클라이언트
        브라우저에 반환하는 <literal>HttpServletResponse.sendRedirect()</literal>를
        호출한다. 기본적으로 모든 모델 속성을 리다이렉트 URL의 URI 템플릿 변수로 노출하는 것으로
        간주한다. 프리미티브 타입이나 프리미티브 타입의 컬렉션/배열인 남은 속성들은 자동으로
        쿼리 파라미터에 추가한다.</para>

        <para>모델 인스턴스를 리데이렉트 전용으로 준비했다면 프리미티브 타입 속성을 쿼리 파라미터에
        추가하는 것은 원하는 결과일 것이다. 하지만 어노테이션이 붙은 컨트롤러에서 모델은 렌더링을
        위해 추가한 다른 속성들을(예: 드롭다운 필드값들) 담고있을 수 있다. 이러한 속성이 URL에
        나타나는 것을 피하려면 어노테이션이 붙은 컨트롤러가
        <interfacename>RedirectAttributes</interfacename> 타입의 인자를 선언할 수
        있다. <interfacename>RedirectAttributes</interfacename>를 사용해서
        <classname>RedirectView</classname>를 사용할 수 있도록 정확한 속성을 지정한다.
        컨트롤러 메서드가 리다이렉트를 결정한다면
        <interfacename>RedirectAttributes</interfacename>의 내용을 사용한다.
        컨트롤러 메서드가 리다이렉트를 결정하지 않는다면 모델의 내용을 사용한다.</para>

        <para>현재 요청의 URI 템플릿 변수는 자동으로 리다이렉트 URL을 확상할 때 사용할 수 있게
        만들고 <interfacename>Model</interfacename>나
        <interfacename>RedirectAttributes</interfacename>를 통해서 명시적으로 추가할
        필요가 없다. 예를 들면 다음과 같다.</para>

        <programlisting language="java">@RequestMapping(value = "/files/{path}", method = RequestMethod.POST)
public String upload(...) {
    // ...
    return "redirect:files/{path}";
}</programlisting>

        <para><classname>RedirectView</classname>를 사용하고 컨트롤러가 직접 뷰를
        생성한다면 컨트롤러에 리다이렉트 URL이 생성되는 것이 아니라 컨텍스트에 뷰 이름과 일치하게
        컨텍스트에 설정되도록 컨트롤러에 리다이렉트 URL를 주입하도록 설정하기를 권장한다. 다음
        섹션에서 이 과정을 설명한다.</para>
      </section>

      <section id="mvc-redirecting-redirect-prefix">
        <title><literal>redirect:</literal> 접두사</title>

        <para><classname>RedirectView</classname>가 잘 동작
        컨트롤러가 직접 <classname>RedirectView</classname>를 생성한다면 리다이렉트가
        일어난다는 것을 컨트롤러가 인지한다는 것을 피할 수 있는 방법은 없다. 이는 실제로 최선의
        선택이 아니고 너무 깊은 커플링이 생긴다. 컨트롤러는 응답이 어떻게 처리되는지 신경쓰지 않아야
        한다. 보통 컨트롤러에 주입되는 뷰 이름만 처리해야 한다.</para>

        <para>전용 <literal>redirect:</literal> 접두사로 이 문제를 해결할 수 있다.
        <literal>redirect:</literal> 접두사를 가진 뷰 이름을 반환한다면
        <classname>UrlBasedViewResolver</classname>(그리고 모든 하위클래스)는
        리다이렉트가 필요하다는 의미의 이 접두사를 인지할 것이다. 뷰 이름에서 나머지 부분은
        리다이렉트 URL로 다룰 것이다.</para>

        <para>최종적인 효과는 컨트롤러가 <classname>RedirectView</classname>를 반환한
        것과 같지만 이제 컨트롤러는 논리적인 뷰 이름의 관점에서만 처리할 수 있다.
        <literal>redirect:/myapp/some/resource</literal>같은 논리적인 뷰 이름은 현재
        서블릿 컨텍스트에 상대적으로 리다이렉트 할 것이고
        <literal>redirect:http://myhost.com/some/arbitrary/path</literal>같은
        이름은 절대 URL로 리다이렉트 할 것이다.</para>
      </section>

      <section id="mvc-redirecting-forward-prefix">
        <title><literal>forward:</literal> 접두사<!--Can you revise this heading to say what you're using the forward prefix to accomplish?--></title>

        <para>뷰 이름에 전용 <literal>forward:</literal> 접두사를 사용해서
        <classname>UrlBasedViewResolver</classname>와 하위클래스가 결국 처리하게 하는
        것도 가능하다. 이는 뷰 이름의 남은 부분(URL이 될)을 감싸서
        <classname>InternalResourceView</classname>(최종적으로
        <literal>RequestDispatcher.forward()</literal>를 수행할)를 생성한다. 그러므로
        이 접두사는 <classname>InternalResourceViewResolver</classname>와
        <classname>InternalResourceView</classname>(예를 들면 JSP에서)에는 유용하지
        않다. 하지만 주로 다른 뷰 기술을 사용한다면 이 접두사는 도움이 될 수 있지만 여전히 서블릿/JSP
        엔진이 리소스의 포워딩을 처리하도록 강제하기를 원한다. (대신 여러 뷰 리졸버를 체인으로
        연결할 수도 있다.)<!--I think the preceding sentences were a bit garbled. I tried to reword a bit. And is this paragraph logical?--></para>

        <para><literal>redirect:</literal> 접두사처럼 <literal>forward:</literal>
        접두사가 붙은 뷰 이름은 컨트롤러에 주입되고 컨트롤러는 응답을 처리하는 관점에서 어떤 특별한
        일이 일어나는지 알지 못한다.<!--Can you reword to clarify the point? The controller does not detect what?--></para>
      </section>
    </section>

    <section id="mvc-multiple-representations">
      <title><classname>ContentNegotiatingViewResolver</classname></title>

      <para><classname>ContentNegotiatingViewResolver</classname>는 뷰를 직접
      처리하지 않고 다른 뷰 리졸버에 위임한다. 화면을 생성하는 뷰를 선택하는 것은 클라이언트가
      요청한다. 서버에서 클라이언트가 표현방법을 요청하는 두가지 전략이 존재한다.</para>

      <itemizedlist>
        <listitem>
          <para>리소스마다 다른 URI를 사용해라. 보통은 URI에 다른 파일 확장자를 사용한다.
          예를 들어 URI<literal>http://www.example.com/users/fred.pdf</literal>는
          fred 사용자의 PDF 표현을 요청하고
          <literal>http://www.example.com/users/fred.xml</literal>는
          XML 표현을 요청한다.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>리소스를 얻는 클라이언트에 같은 URI를 사용하되 <literal>Accept</literal>
          HTTP 요청 헤더를 이해할 수 있는
          <ulink url="http://en.wikipedia.org/wiki/Internet_media_type">미디어
          타입</ulink>으로 설정해라. 예를 들어 <literal>Accept</literal> 헤더가
          <literal>application/pdf</literal>인
          <literal>http://www.example.com/users/fred</literal>의 HTTP 요청은
          fred 사용자의 PDF 표현을 요청하고 <literal>Accept</literal> 헤더가
          <literal>text/xml</literal>인
          <literal>http://www.example.com/users/fred</literal> 요청은 XML 표현을
          요청한다. 이 전략을 <ulink
          url="http://en.wikipedia.org/wiki/Content_negotiation">컨텐트
          네고시에이션(content negotiation)</ulink>라고 부른다.</para>
        </listitem>
      </itemizedlist>

      <note>
        <para><literal>Accept</literal> 헤더에서 한가지 이슈는 웹브라우저에서 HTML에 설정할
        수 없다는 것이다. 예를 들어 파이어폭스는 <literal>Accept</literal>헤더를 다음과
        같이 바꾼다.<!--So how would you set the Accept header as in second bullet, if you can't do it in html? Indicate?--></para>

        <programlisting>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</programlisting>

        <para>이때문에 브라우저에 기반해서 웹 어플리케이션을 개발할 때는 각 표현마다 다른 URI를
        사용하는 것이 일반적이다.</para>
      </note>

      <para>리소스의 여러가지 표현을 지원하려고 스프링은
      <classname>ContentNegotiatingViewResolver</classname>를 제공한다.
      <classname>ContentNegotiatingViewResolver</classname>는 파일 확장자나 HTTP
      요청의 <literal>Accept</literal> 헤더에 기반해서 뷰를 처리한다.
      <classname>ContentNegotiatingViewResolver</classname>는 뷰를 직접 처리하지 않고
      대신 <literal>ViewResolvers</literal> 빈 프로퍼티로 지정한 뷰 리졸버의 목록으로
      위임한다.<!--A human has to specify this list of resolvers, right? See example below.--></para>

      <para><classname>ContentNegotiatingViewResolver</classname>는
      각각의 <classname>ViewResolvers</classname>와 연관된
      <classname>View</classname>가 지원하는 미디어타입
      (<literal>Content-Type</literal>라고도 알려진)과 요청의 미디어타입을 비교해서 요청을
      처리하도록 적절한 <classname>View</classname>를 선택한다. 목록에서
      <literal>Content-Type</literal>과 호환성이 있는 첫번째
      <classname>View</classname>가 클라이언트에 표현을(representation)을 반환한다.
      <classname>ViewResolver</classname> 체인에서 호환성있는 뷰가 없다면
      <literal>DefaultViews</literal> 프로퍼티로 지정한 뷰 목록을 참고할 것이다. 후자의
      방법은 논리적인 뷰 이름과 상관없이 현재 리소스의 적절한 표현을 렌더링할 수 있는 싱글톤
      <classname>Views</classname>에 적절하다. <literal>text/*</literal>처럼
      <literal>Accept</literal>는 와일드카드를 포함할 수도 있다. 이 경우에는 Content-Type이
      <literal>text/xml</literal>인 뷰와 호환된다.</para>

      <para>파일 확장자에 기반한 뷰 처리를 지원하려면 파일 확장자와 미디어 타입의 매핑을 지정하는
      <classname>ContentNegotiatingViewResolver </classname> 빈 프로퍼티
      <literal>mediaTypes</literal>을 사용해라. 요청 미디어타입을 결정하는데 사용된 알고리즘에
      대해서 자세히 알고 싶다면 <classname>ContentNegotiatingViewResolver</classname>
      API 문서를 참고해라.</para>

      <para>다음은 <classname>ContentNegotiatingViewResolver</classname>를
      설정하는 예제이다.</para>

      <programlisting language="xml">&lt;bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&gt;
  &lt;property name="mediaTypes"&gt;
    &lt;map&gt;
      &lt;entry key="atom" value="application/atom+xml"/&gt;
      &lt;entry key="html" value="text/html"/&gt;
      &lt;entry key="json" value="application/json"/&gt;
    &lt;/map&gt;
  &lt;/property&gt;
  &lt;property name="viewResolvers"&gt;
    &lt;list&gt;
      &lt;bean class="org.springframework.web.servlet.view.BeanNameViewResolver"/&gt;
      &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
        &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;
        &lt;property name="suffix" value=".jsp"/&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="defaultViews"&gt;
    &lt;list&gt;
      &lt;bean class="org.springframework.web.servlet.view.json.MappingJacksonJsonView" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;


&lt;bean id="content" class="com.springsource.samples.rest.SampleContentAtomView"/&gt;</programlisting>

      <para><classname>InternalResourceViewResolver</classname>는 뷰 이름과 JSP
      페이지의 변환을 다루는 반면 <classname>BeanNameViewResolver</classname>는 빈의
      이름에 기반해서 뷰를 반환한다. (스프링이 뷰를 검색하고 인스턴스화하는 방법은 "<link
      linkend="mvc-viewresolver-resolver">ViewResolver 인터페이스로 뷰 처리하기</link>"를
      참고해라.) 이 예제에서 <literal>content</literal> 빈은 Atom RSS를 반환하는
      <classname>AbstractAtomFeedView</classname>를 상속받은 클래스다. Atom 피드
      표현을 생성하는 자세한 내용은 Atom 뷰 부분을 봐라.<!--Need a correct link or x-ref re the preceding sentence.I couldn't find an "Atom Views" section.--></para>

      <para>위의 설정에서 요청이 <literal>.html</literal> 확장자라면 뷰 리졸버는
      <literal>text/html</literal> 미디어 타입과 일치하는 뷰를 검색한다.
      <classname>InternalResourceViewResolver</classname>는
      <literal>text/html</literal>와 일치하는 뷰를 제공한다. 요청이
      <literal>.atom</literal> 파일 확장자라면 뷰 리졸버는
      <literal>application/atom+xml</literal> 미디어타입과 일치하는 뷰를 찾는다. 이 뷰는
      반환된 뷰 이름이 <classname>content</classname>라면
      <classname>SampleContentAtomView</classname>와 매핑되는
      <classname>BeanNameViewResolver</classname>가 제공한다. 요청의 파일 확장자가
      <literal>.json</literal>이라면 뷰 이름에 상관없이
      <literal>DefaultViews</literal> 목록에서
      <classname>MappingJacksonJsonView</classname> 인스턴스를 선택할 것이다. 아니면
      클라이언트 요청이 파일 확장자는 갖지 않고 <literal>Accept</literal> 헤더를 원하는
      미디어타입으로 설정해서 같은 뷰 처리가 일어나도록
      할 수 있다.<!--Can you reword preceding sentence? I don't follow it.--></para>

      <note>
        <para>뷰 리졸버의 <classname>ContentNegotiatingViewResolver</classname>
        목록을 명시적으로 설정하지 않았다면 자동적으로 어플리케이션 컨텍스트에 정의한
        뷰 리졸버를 사용한다.</para>
      </note>

      <para><literal>http://localhost/content.atom</literal>형식의 URI나
      application/atom+xml의 <literal>Accept</literal> 헤더를 가진
      <literal>http://localhost/content</literal> URI에 Atom RSS 피드를
      반환하는 컨트롤러 코드는 다음과 같다.</para>

      <programlisting language="java">@Controller
public class ContentController {

    private List&lt;SampleContent&gt; contentList = new ArrayList&lt;SampleContent&gt;();

    @RequestMapping(value="/content", method=RequestMethod.GET)
    public ModelAndView getContent() {
        ModelAndView mav = new ModelAndView();
        mav.setViewName("content");
        mav.addObject("sampleContentList", contentList);
        return mav;
    }

}</programlisting>
    </section>
  </section>

  <section id="mvc-flash-attributes">
    <title>플래시(flash) 속성 사용하기</title>

    <para>플래시(flash) 속성은 어떤 요청이 다른 요청에서 사용할 수 있도록 속성을 저장하는 방법을
    제공한다. 이는 리다리렉트를 할 때(예를 들어 <emphasis>Post/Redirect/Get</emphasis>
    패턴) 가장 일반적으로 필요하다. 리다이렉트한 후에 요층을 이용할 수 있도록 리다이렉트하기 전에
    임시적으로 플래시 속성을 저장하고(보통은 세션에) 바로 제거한다.</para>

    <para>스프링 MVC는 플래시 속성을 지원하는 두가지 주요 추상화를 가진다.
    <classname>FlashMap</classname>는 플래시 속성을 보관하는데 사용하고
    <interfacename>FlashMapManager</interfacename>는
    <classname>FlashMap</classname> 인스턴스를 저장하고 획득하고 관리하는데 사용한다.</para>

    <para>플래시 속성 지원은 항상 "켜져 있고" 사용하지 않더라도 HTTP 세션 생성을 일으키지 않으므로
    명시적으로 활성화할 필요가 없다. 각 요청에는 이전의 요청(존재한다면)에서 전달받은 속성을 가진
    "입력" <classname>FlashMap</classname>과 뒤이은 요청을 위해 저장할 속성을 가진 "출력"
    <classname>FlashMap</classname>이 있다. 두 <classname>FlashMap</classname>
    인스턴스는 <classname>RequestContextUtils</classname>의 정적 메서드로 스프링 MVC
    어디서나 접근할 수 있다.</para>

    <para>어노테이션이 붙은 컨트롤러는 보통 <classname>FlashMap</classname>를 직접 사용할
    필요가 없다. 대신 <interfacename>@RequestMapping</interfacename> 메서드는
    <interfacename>RedirectAttributes</interfacename> 타입의 인자를 받을 수 있고
    리다이렉트시에 플래시 속성을 추가하려고
    <interfacename>RedirectAttributes</interfacename>를 사용할 수 있다.
    <interfacename>RedirectAttributes</interfacename>로 추가한 플래시 속성은 자동적으로
    "출력" FlashMap으로 전달된다. 유사하게 리다이렉트 후에 "입력"
    <classname>FlashMap</classname>의 속성은 대상 URL을 제공하는 컨트롤러의
    <interfacename>Model</interfacename>에 자동적으로 추가된다.</para>

    <sidebar id="mvc-flash-attributes-concurrency">
      <title>요청을 플래시 속성으로 매칭하기</title>

      <para>많은 다른 웹 프레임워크에도 플래시 속성의 개념은 존재하고 때때로 동시성 이슈가 생기는
      것으로 밝혀졌다. 이는 정의대로 플래시 속성이 다음 요청까지 저장되기 때문이다. 하지만 바로
      "다음" 요청이 플래시 속성을 받는 요청이 아니라 다른 비동기 요청일 수도 있다.(예를 들면
      폴링이나 리로스 요청) 이러한 경우에 플래시 속성이 너무 빨리 제거된다.</para>

      <para>이러한 이슈의 가능성을 줄이려고 <classname>RedirectView</classname>는
      대상 리다이렉트 URL의 경로와 쿼리 파라미터로 <classname>FlashMap</classname>
      인스턴스에 자동으로 "인증(stamps)"을 한다. 이어서 기본
      <classname>FlashMapManager</classname>는 "입력"
      <classname>FlashMap</classname>을 검색할 때 해당 정보와 들어오는 요청을
      매칭한다.</para>

      <para>이 방법이 동시성 이슈의 가능성을 완전히 제거하지는 못하지만 리다이렉트 URL에서
      이미 사용할 수 있는 정보로 크게 감소시킨다. 그러므로 리다이렉트 시나이로에서 주로 플래시
      속성을 사용하기를 권장한다.</para>
    </sidebar>
  </section>

  <section id="mvc-construct-encode-uri">
    <title><literal>URI</literal> 생성하기</title>

    <para>스프링 MVC는 <classname>UriComponentsBuilder</classname>와
    <classname>UriComponents</classname>를 사용해서 URI를 구성하고 인코딩하는
    메카니즘을 제공한다.
    </para>

    <para>예를 들면 URI 템플릿 문자열을 확장해서 인코딩할 수 있다.</para>

<programlisting language="java">UriComponents uriComponents =
        UriComponentsBuilder.fromUriString("http://example.com/hotels/{hotel}/bookings/{booking}").build();

URI uri = uriComponents.expand("42", "21").encode().toUri();
</programlisting>

    <para><classname>UriComponents</classname>는 불변이고(immutable)
    <literal>expand()</literal>와 <literal>encode()</literal>는 필요하다면
    새로운 인스턴스를 반환는 점을 유념해라.</para>

    <para>URI 컴포넌트를 개별적으로 사용해서 확장하고 인코딩할 수도 있다.</para>

<programlisting language="java">UriComponents uriComponents =
        UriComponentsBuilder.newInstance()
            .scheme("http").host("example.com").path("/hotels/{hotel}/bookings/{booking}").build()
            .expand("42", "21")
            .encode();
</programlisting>

	<para>서블릿 환경에서 <classname>ServletUriComponentsBuilder</classname>의
  하위클래스는 서블릿 요청에서 사용가능한 URL 정보를 복사하는 정적 팩토리 메서드를 제공한다.
  </para>

<programlisting language="java">HttpServletRequest request = ...

// 호스트, 스키마, 포트 경로, 쿼리스트링을 재사용한다.
// 쿼리파라미터 "accountId"를 치환한다

ServletUriComponentsBuilder ucb =
        ServletUriComponentsBuilder.fromRequest(request).replaceQueryParam("accountId", "{id}").build()
            .expand("123")
            .encode();
</programlisting>

    <para>아니면 컨텍스트 경로에서 사용가능한 정보중 일부만 카피할 수도 있다.</para>

<programlisting language="java">// 호스트, 포트, 컨텍스트 경로를 재사용한다
// 경로에 "/accounts"를 추가한다

ServletUriComponentsBuilder ucb =
        ServletUriComponentsBuilder.fromContextPath(request).path("/accounts").build()
</programlisting>

    <para>또는 이름으로 <classname>DispatcherServlet</classname>을 매핑한 경우(예시.
    <literal>/main/*</literal>) 포함된 서블릿 매핑의 리터럴 부분을 가질수도 있다.</para>

<programlisting language="java">// 호스트, 포트, 컨텍스트 경로를 재사용한다
// 경로에 서블릿 매핑의 리터럴 부분을 추가한다
// 경로에 "/accounts"를 추가한다

ServletUriComponentsBuilder ucb =
        ServletUriComponentsBuilder.fromServletMapping(request).path("/accounts").build()
</programlisting>

  </section>

  <section id="mvc-localeresolver">
    <title>로케일 사용</title>

    <para>스프링 아키텍처의 대부분은 스프링 웹 MVC 프레임워크와 마찬가지로 국제화
    (internationalization)를 지원한다. <classname>DispatcherServlet</classname>은
    자동으로 클라이언트의 로케일을 사용해서 메시지를 처리하도록 한다. 이는
    <interfacename>LocaleResolver</interfacename> 객체로 이뤄진다.</para>

    <para>요청이 들어왔을 때 <classname>DispatcherServlet</classname>는 로케일 리졸버를
    찾고 로케일 리졸버를 발견한다면 로케일을 설정하는데 사용을 시도한다.
    <literal>RequestContext.getLocale()</literal> 메서드를 사용해서 로케일 리졸버가
    처리한 로케일을 언제든지 얻을 수 있다.</para>

    <para>자동 로케일 처리에 대해서 더 얘기하자면 특정 환경에서(예를 들면 요청의 파라미터에 따라서)
    로케일을 변경하도록 핸들러 매핑(<xref linkend="mvc-handlermapping-interceptor" />
    참고)에 인터셉터를 추가할 수도 있다.</para>

    <para>로케일 리졸버와 인터셉터는
    <literal>org.springframework.web.servlet.i18n</literal> 패키지에 정의되어
    있고 일반적인 방법으로 어플리케이션 컨텍스트에 설정한다. 다음은 스프링에 포함된 로케일
    리졸버들이다.</para>

    <section id="mvc-localeresolver-acceptheader">
      <title><classname>AcceptHeaderLocaleResolver</classname></title>

      <para>이 로케일 리졸버는 클라이언트(예를 들면 웹 브라우저)가 보낸 요청의
      <literal>accept-language</literal> 헤더를 검사한다. 보통 이 헤더 필드는 클라이언트
      운영체제의 로케일이다.</para>
    </section>

    <section id="mvc-localeresolver-cookie">
      <title><classname>CookieLocaleResolver</classname></title>

      <para>이 로케일 리졸버는 로케일이 지정되었는 지 확인하려고 클라이언트의
      <classname>Cookie</classname>를 검사한다. 로케일이 지정되었다면 지정된 로케일을
      사용한다. 이 로케일 리졸버의 프로퍼티들을 사용해서 maximum age같은 쿠키의 이름을 지정할
      수 있다. 아래에서 <classname>CookieLocaleResolver</classname>를 정의하는
      예제를 봐라.</para>

      <programlisting language="xml">&lt;bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver"&gt;

    &lt;property name="cookieName" value="clientlanguage"/&gt;

    <lineannotation>&lt;!-- 초 단위다. <literal>-1</literal>로 설정한다면 쿠키를 유지하지 않는다.(브라우저를 닫을때 삭제한다) --&gt;</lineannotation>
    &lt;property name="cookieMaxAge" value="100000"&gt;

&lt;/bean&gt;</programlisting>

      <table id="mvc-cookie-locale-resolver-props-tbl">
        <title><classname>CookieLocaleResolver</classname> 프로퍼티</title>

        <tgroup cols="3">
          <colspec colname="c1" colwidth="1*" />

          <colspec colname="c2" colwidth="1*" />

          <colspec colname="c3" colwidth="3*" />

          <thead>
            <row>
              <entry>프로퍼티</entry>

              <entry>기본값</entry>

              <entry>설명</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>cookieName</entry>

              <entry>classname + LOCALE</entry>

              <entry>쿠키의 이름</entry>
            </row>

            <row>
              <entry>cookieMaxAge</entry>

              <entry>Integer.MAX_INT</entry>

              <entry>클라이언트에서 쿠키를 유지할 최대 시간 -1로 지정하면 쿠키를 유지하지 않는다.
              클라이언트가 브라우저를 닫을 때까지만 사용할 수 있다</entry>
            </row>

            <row>
              <entry>cookiePath</entry>

              <entry>/</entry>

              <entry>사이트의 특정 부분에서만 쿠키가 보이도록 제한한다. cookiePath를 지정하면
              쿠키는 해당 경로와 그 하위경로에서만 보일 것이다.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="mvc-localeresolver-session">
      <title><classname>SessionLocaleResolver</classname></title>

      <para><classname>SessionLocaleResolver</classname>는 사용자의 요청과
      연관된 세션에서 로케일을 얻을 수 있게 한다.<!--Aren't you missing some information and example? This section has only one sentence.--></para>
    </section>

    <section id="mvc-localeresolver-interceptor">
      <title><classname>LocaleChangeInterceptor</classname></title>

      <para>핸들러 매핑(<xref linkend="mvc-handlermapping" /> 참고)에
      <classname>LocaleChangeInterceptor</classname>를 추가해서 로케일을 변경하도록
      할 수 있다. 요청의 파라미터를 탐지해서 로케일을 변경할 것이다. 컨텍스트에도 존재하는
      <interfacename>LocaleResolver</interfacename>의
      <literal>setLocale()</literal>를 호출한다. 다음 예제는
      <literal>siteLanguage</literal>라는 이름의 파라미터를 가진
      <literal>*.view</literal>의 모든 리소스에 대한 요청이 로케일을 변경하는 것을 보여준다.
      그래서 예를 들어 <literal>http://www.sf.net/home.view?siteLanguage=nl</literal>
      URL에 대한 요청은 사이트의 언어를 Dutch로 변경할 것이다.</para>

      <programlisting language="xml">&lt;bean id="localeChangeInterceptor"
      class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"&gt;
    &lt;property name="paramName" value="siteLanguage"/&gt;
&lt;/bean&gt;

&lt;bean id="localeResolver"
      class="org.springframework.web.servlet.i18n.CookieLocaleResolver"/&gt;

&lt;bean id="urlMapping"
      class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
    &lt;property name="interceptors"&gt;
        &lt;list&gt;
            &lt;ref bean="localeChangeInterceptor"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="mappings"&gt;
        &lt;value&gt;/**/*.view=someController&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
    </section>
  </section>

  <section id="mvc-themeresolver">
    <title>테마(theme) 사용</title>

    <section id="mvc-themeresolver-introduction">
      <title>테마 소개</title>

      <para>어플리케이션의 전체 디자인(look-and-feel)을 설정하는데 스프링 웹 MVC 프레임워크
      테마를 적용할 수 있다. 테마는 어플리케이션의 시각적인 부분에 영향을 끼치는 정적 리소스들(보통
      스타일시트와 이미지)의 모음이다. </para>
    </section>

    <section id="mvc-themeresolver-defining">
      <title>테마 정의하기</title>

      <para>웹 어플리케이션에서 테마를 사용하려면
      <interfacename>org.springframework.ui.context.ThemeSource</interfacename>
      인터페이스의 구현체를 설정해야 한다. <interfacename>WebApplicationContext</interfacename>
      인터페이스는 <interfacename>ThemeSource</interfacename>를 확장하지만 전용 구현체에
      자신의 책임을 위임한다. 기본적으로 이 위임은 클래스패스의 루트에서 프로퍼티 파일들을 로드하는
      <classname>org.springframework.ui.context.support.ResourceBundleThemeSource</classname>
      구현체가 될 것이다. 커스텀 <interfacename>ThemeSource</interfacename> 구현체를
      사용하거나 <classname>ResourceBundleThemeSource</classname>의 기반이 되는 이름
      접두사(base name prefix)를 설정하기 위해 어플리케이션 컨테스트에 예약된 이름인
      <classname>themeSource</classname>로 빈을 등록할 수 있다. 웹 어플리케이션 컨텍스트는
      자동으로 해당 이름의 빈을 탐지해서 사용한다.</para>

      <para><classname>ResourceBundleThemeSource</classname>를 사용하는 경우 테마는
      간단한 프로퍼티 파일에 정의되어 있다. <!--Revise preceding sentence to clarify: To use ResourceBundleThemeSource, you define a theme in a properties file? OR do you mean a theme--><!--is already defined in a simple properties file for use with ResourceBundleThemeSource?-->
      프로퍼티 파일은 테마를 구성하는 리소스의 목록을 나열한다. 다음은 그 예제이다.<!--Is this an example of what a human enters? If not, why is it referred to as an example, if this is exact code already provided?--></para>

      <programlisting>styleSheet=/themes/cool/style.css
background=/themes/cool/img/coolBg.jpg</programlisting>

      <para>프로퍼티의 키는 뷰 코드에서 테마가 적용된 요소를 참조하기 위한 이름이다. JSP라면
      <literal>spring:message</literal> 태그와 아주 유사한
      <literal>spring:theme</literal>의 커스텀 태그를 보통 사용한다. 다음 JSP 코드는
      디자인(look and feel)을 커스터마이징하려고 이전 예제에서 정의한 테마를 사용한다.</para>

      <programlisting language="xml">&lt;%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;link rel="stylesheet" href="&lt;spring:theme code='styleSheet'/&gt;" type="text/css"/&gt;
   &lt;/head&gt;
   &lt;body style="background=&lt;spring:theme code='background'/&gt;"&gt;
      ...
   &lt;/body&gt;
&lt;/html&gt;</programlisting>

      <para>기본적으로 <classname>ResourceBundleThemeSource</classname>는 비어있는
      기반 이름 접두사(base name prefix)를 사용하므로 클래스패스의 루트에서 프로퍼티 파일을
      로드한다. 그러므로 클래스패스의 루트(예를 들면 <literal>/WEB-INF/classes</literal>)에
      있는 디렉토리에 <literal>cool.properties</literal> 테마 정의를 둘 것이다.
      <classname>ResourceBundleThemeSource</classname>는 테마에서 완전한 국제화를
      지원하는 표준 자바 리소스번들 로딩 메카니즘을 사용한다. 예를 들어 Dutch 문구와 특수한
      배경이미지를 참조하는 <literal>/WEB-INF/classes/cool_nl.properties</literal>를
      가질 수 있다.</para>
    </section>

    <section id="mvc-themeresolver-resolving">
      <title>테마 리졸버</title>

      <para>앞의 섹션에서처럼 테마를 정의한 후에 어떤 테마를 사용할지 결정하게 된다.
      <classname>DispatcherServlet</classname>은 사용할
      <interfacename>ThemeResolver</interfacename> 구현체를 찾으려고
      <classname>themeResolver</classname>라는 이름의 빈을 찾을 것이다. 테마 리졸버는
      <interfacename>LocaleResolver</interfacename>와 완전히 간은 방법으로 동작한다.
      특정 요청에 사용할 테마를 탐지해서 요청의 테마를 대체할 수 있다. 다음은 스프링이 제공하는
      테마 리졸버들이다.</para>

      <table id="mvc-theme-resolver-impls-tbl">
        <title><interfacename>ThemeResolver</interfacename>
        구현체</title>

        <tgroup cols="2">
          <colspec colname="c1" colwidth="1*" />

          <colspec colname="c3" colwidth="3*" />

          <thead>
            <row>
              <entry>클래스</entry>

              <entry>설명</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><classname>FixedThemeResolver</classname></entry>

              <entry><classname>defaultThemeName</classname> 프로퍼티로
              설정한 고정된 테마를 선택한다.</entry>
            </row>

            <row>
              <entry><classname>SessionThemeResolver</classname></entry>

              <entry>사용자의 HTTP 세션에서 테마를 유지한다. 각 세션에는 딱 한번만 설정되어야
              하지만 세션간에 유지되지는 않는다.</entry>
            </row>

            <row>
              <entry><classname>CookieThemeResolver</classname></entry>

              <entry>선택한 테마를 클라이언트의 쿠키에 저장한다.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>스프링은 요청 프라미터를 가진 모든 요청에서 테마를 변경할 수 있는
      <classname>ThemeChangeInterceptor</classname>도 제공한다.<!--Do you need more info or an example re preceding sentence?--></para>
    </section>
  </section>

  <section id="mvc-multipart">
    <title>스프링의 멀티파트(multipart) (파일 업로드) 지원</title>

    <section id="mvc-multipart-introduction">
      <title>소개</title>

      <para>스프링의 내장 멀티파트 지원이 웹 어플리케이션의 파일 업로드를 처리한다.
      <literal>org.springframework.web.multipart</literal> 패키지에 정의되어
      있는 <interfacename>MultipartResolver</interfacename> 객체를 추가해서 이
      멀티파트 지원을 사용할 수 있다. 스프링은 <ulink
      url="http://jakarta.apache.org/commons/fileupload"> <emphasis>Commons
      FileUpload</emphasis></ulink>나 다른 서블릿 3.0 멀티파트 요청 파싱과 함께
      사용하도록 하나의 <interfacename>MultipartResolver</interfacename>
      구현체를 제공한다.</para>

      <para>일부 개발자들이 직접 멀티파트를 처리하기를 원하기 때문에 기본적으로 스프링은 멀티파트를
      처리하지 않는다. 웹 어플리케이션 컨텍스트에 멀티파트 리졸버를 추가해서 스프링의 멀티파트 처리를
      활성화한다. 요청이 멀티파트를 포함하는지 확인하려고 각 용청을 검사한다. 멀티파트를 포함하고 있지
      않다면 요청을 원래대로 계속 처리한다. 요청이 멀티파트를 포함하고 있다면 컨텍스트에 정의한
      <classname>MultipartResolver</classname>를 사용한다. 그 다음에 요청의 멀티파트
      속성을 다른 속성들처럼 다룬다.</para>
    </section>

    <section id="mvc-multipart-resolver-commons">
      <title><interfacename>MultipartResolver</interfacename>를
      <emphasis>Commons FileUpload</emphasis>와 함께 사용하기</title>

      <para>다음 예제는 <classname>CommonsMultipartResolver</classname>를
      어떻게 사용하는지 보여준다.</para>

      <programlisting language="xml">&lt;bean id="multipartResolver"
    class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;

    <lineannotation>&lt;!-- 프로퍼티 중 하나를 사용할 수 있다; 최대파일 크기를 바이트로 표시한다 --&gt;</lineannotation>
    &lt;property name="maxUploadSize" value="100000"/&gt;
&lt;/bean&gt;</programlisting>

      <para>물론 멀티파트 리졸버가 동작하도록 클래스패스에 적절한 jar를 두어야 할 수도 있다.
      <classname>CommonsMultipartResolver</classname>의 경우
      <literal>commons-fileupload.jar</literal>를 사용해야 한다.</para>

      <para>스프링 <classname>DispatcherServlet</classname>가 멀티파트 요청을 탐지하면
      <classname>DispatcherServlet</classname>가 컨텍스트에 정의된 리졸버를 활성화하고
      요청을 전달한다. 그러면 리졸버는 현재 <classname>HttpServletRequest</classname>를
      멀티파트 파일 업로드를 지원하는 <classname>MultipartHttpServletRequest</classname>로
      감싼다. <classname>MultipartHttpServletRequest</classname>를 사용해서 해당
      요청이 담고있는 멀티파트의 정보를 얻을 수 있고 컨트롤러에서 실제로 멀티파일 파일들에
      접근할 수 있다.</para>
    </section>

    <section id="mvc-multipart-resolver-standard">
      <title><interfacename>MultipartResolver</interfacename>를
      <emphasis>서블릿 3.0</emphasis>과 함게 사용하기</title>

      <para>서블릿 3.0에 기반한 멀티파트 파싱을 사용하려면 <filename>web.xml</filename>에서
      <literal>"multipart-config"</literal>로
      <classname>DispatcherServlet</classname>를 표시하거나 프로그래밍적인 서블릿 등록이나
      서블릿 클래스에 <classname>javax.servlet.annotation.MultipartConfig</classname>
      어노테이션이 붙을 수 있는 커스텀 서블릿 클래스의 경우에
      <classname>javax.servlet.MultipartConfigElement</classname>로 서블릿을
      표시하거나 해야 한다. 서블릿 3.0처럼 서블릿 등록 단계에서 적용해야하는 최대 크기나 저장위치같은
      설정을 구성하는 것은 MultipartResolver에서 이러한 설정을 하는 것을 허용하지 않는다.</para>

      <para>앞에서 말한 방법으로 서블릿 3.0 멀티파트 파싱을 활성화하고 나면 스프링 구성에
      <classname>StandardServletMultipartResolver</classname>를
      추가할 수 있다.</para>

      <programlisting language="xml">&lt;bean id="multipartResolver"
    class="org.springframework.web.multipart.support.StandardServletMultipartResolver"&gt;
&lt;/bean&gt;</programlisting>
    </section>

    <section id="mvc-multipart-forms">
      <title>폼의 파일 업로드 처리</title>

      <para><classname>MultipartResolver</classname>가 자신의 일을 완료한 후에 요청은
      다른 요청들처럼 처리된다. 우선 폼을 파입입력으로 생성하고 이는 사용자가 폼을 업로드할 수 있도록
      할 것이다. 인코딩 속성(<literal>enctype="multipart/form-data"</literal>)이
      브라우저가 어떻게 폼을 멀티파트 요청처럼 인코딩해야 하는지 알도록 해준다.</para>

      <programlisting language="xml">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Upload a file please&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Please upload a file&lt;/h1&gt;
        &lt;form method="post" action="/form" enctype="multipart/form-data"&gt;
            &lt;input type="text" name="name"/&gt;
            &lt;input type="file" name="file"/&gt;
            &lt;input type="submit"/&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>

      <para>다음 과정으로 파일업로드를 처리하는 컨트롤러를 생성한다. 메서드 파라미터에
      <classname>MultipartHttpServletRequest</classname>나
      <filename>MultipartFile</filename>를 사용한다는 점만 제외하면 이 컨트롤러는
      <link linkend="mvc-ann-controller">
      <interfacename>@Controller</interfacename> 어노테이션이 붙은 일반적인
      컨트롤러와</link>와 아주 유사하다.</para>

      <programlisting language="java">@Controller
public class FileUploadController {

    @RequestMapping(value = "/form", method = RequestMethod.POST)
    public String handleFormUpload(@RequestParam("name") String name,
        @RequestParam("file") MultipartFile file) {

        if (!file.isEmpty()) {
            byte[] bytes = file.getBytes();
            <lineannotation>// 어딘가에 바이트를 저장한다</lineannotation>
           return "redirect:uploadSuccess";
       } else {
           return "redirect:uploadFailure";
       }
    }

}</programlisting>

      <para><interfacename>@RequestParam</interfacename> 메서드 파라미터가 폼에
      선언된 입력 요소에 어떻게 매핑되는지 봐라. 이 예제에서 <literal>byte[]</literal>로
      하는 것은 아무것도 없지만 실제 사용할 때는 <literal>byte[]</literal>를 데이터베이스이나
      파일시스템 등에 저장할 수 있다.</para>

      <para>서블릿 3.0 멀티파트 파싱을 사용하는 경우 메서드 파라미터에
      <classname>javax.servlet.http.Part</classname>를 사용할 수도 있다.</para>

      <programlisting language="java">@Controller
public class FileUploadController {

    @RequestMapping(value = "/form", method = RequestMethod.POST)
    public String handleFormUpload(@RequestParam("name") String name,
        @RequestParam("file") Part file) {

        InputStream inputStream = file.getInputStream();
        <lineannotation>// 업로드된 파일의 바이트를 어딘가에 저장한다</lineannotation>

        return "redirect:uploadSuccess";
    }

}</programlisting>
    </section>

    <section id="mvc-multipart-forms-non-browsers">
      <title>프로그래밍적인 클라이언트의 파일업로드 요청 처리</title>

      <para>RESTful 서비스 시나리오에서는 브라우저가 아닌 클라이언트가 멀티파트 요청을 제출할 수도
      있다. 앞의 모든 예제와 설정은 여기서도 마찬가지로 적용된다. 하지만 보통 파일와 간단한 폼필드를
      제출하는 브라우저와는 다르게 프로그래밍적인 클라이언트는 특정 컨텐트 타입의 훨씬 복잡한 데이터를
      보낼 수 있다. 예를 들면 파일과 함께 두번째 부분으로 JSON 포맷의 데이터를 가진 멀티파트
      요청 등이 있다.
      <programlisting>POST /someUrl
Content-Type: multipart/mixed

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="meta-data"
Content-Type: application/json; charset=UTF-8
Content-Transfer-Encoding: 8bit

{
  "name": "value"
}
--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="file-data"; filename="file.properties"
Content-Type: text/xml
Content-Transfer-Encoding: 8bit
... File Data ...</programlisting></para>

      <para><interfacename>@RequestParam("meta-data") String
      metadata</interfacename> 컨트롤러 메서드 인자로 "meta-data"라는 이름을 가진 부분에
      접근할 수 있다. 하지만 <interfacename>@RequestBody</interfacename>이
      <classname>HttpMessageConverter</classname>의 도움을 받아 멀티파트가 아닌 요청의
      바디를 대상 객체로 변환하는 것과 아주 유사하게 요청 바디에서 JSON 포맷의 데이터에서 초기화된
      강타입의 객체를 받는 것을 선호할 것이다. </para>

      <para>이 용도로 <interfacename>@RequestParam</interfacename> 대신
      <interfacename>@RequestPart</interfacename> 어노테이션을 사용할 수 있다.
      <interfacename>@RequestPart</interfacename>는 멀티파트의
      <literal>'Content-Type'</literal> 헤더를 기억하도록
      <classname>HttpMessageConverter</classname>로 전달된 멀티파트의 내용을
      가질 수 있게 한다.</para>

      <programlisting language="java">@RequestMapping(value="/someUrl", method = RequestMethod.POST)
public String onSubmit(<emphasis role="bold">@RequestPart("meta-data") MetaData metadata,
                       @RequestPart("file-data") MultipartFile file</emphasis>) {
    <lineannotation>// ...</lineannotation>

}</programlisting>

      <para>상호교환가능하게 <interfacename>@RequestParam</interfacename>나
      <interfacename>@RequestPart</interfacename>로
      <classname>MultipartFile</classname> 메서드 인자에 어떻게 접근할 수 있는지를 봐라.
      하지만 이 경우에 <literal>@RequestPart("meta-data") MetaData</literal> 메서드
      인자는 <literal>'Content-Type'</literal> 헤더에 기반해서 JSON 컨텐츠로 읽어서
      <classname>MappingJacksonHttpMessageConverter</classname>로 변환한다.</para>
    </section>
  </section>

  <section id="mvc-exceptionhandlers">
    <title>예외 처리</title>

    <section>
      <title
      id="mvc-HandlerExceptionResolver"><interfacename>HandlerExceptionResolver</interfacename></title>

      <para>스프링의 <literal>HandlerExceptionResolver</literal> 구현체가 컨트롤러가
      실행되는 중 발생한 의도치 않은 예외를 다룬다. <literal>HandlerExceptionResolver</literal>는
      웹 어플리케이션 디스크립터인 <literal>web.xml</literal>에 정의할 수 있는 예외 매핑과
      꽤 유사하다. 하지만 <literal>HandlerExceptionResolver</literal>가 더 유연한 방법을
      제공한다. 예를 들어 <literal>HandlerExceptionResolver</literal>는 예외가 던져졌을
      때 어떤 핸들러를 실행할 것인지에 대한 정보를 제공한다. 게다가 예외 처리의 프로그래밍적인 방법은
      요청을 다른 URL로 포워딩하기 전에(서블릿에 특화된 예외매핑을 사용할 때와 같은 결과이다.)
      적절하게 응답할 수 있는 더 많은 옵션을 제공한다.</para>

      <para><literal>resolveException(Exception, Handler)</literal> 메서드를
      구현하는 것과 <classname>ModelAndView</classname>를 반환하는 것과만 관련된
      <interfacename>HandlerExceptionResolver</interfacename> 인터페이스를 구현하는
      데 추가적으로 <classname>SimpleMappingExceptionResolver</classname>를 사용할
      수도 있다. 이 리졸버는 던져진 모든 예외의 클래스명을 받아서 뷰 이름에 매핑할 수 있게 해준다.
      이는 기능적으로는 서블릿 API의 예외 매핑기능과 동일하지만 여러 핸들러로 더욱 세밀한 예외
      매핑을 구현할 수도 있게 한다.</para>

      <para>기본적으로 <classname>DispatcherServlet</classname>이
      <classname>DefaultHandlerExceptionResolver</classname>를 등록한다.
      이 리졸버는 특정 응답 상태코드를 설정해서 해당 표준 스프링 MVC 예외를
      처리한다. <informaltable>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>예외</entry>

                <entry>HTTP 상태 코드</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><classname>ConversionNotSupportedException</classname></entry>

                <entry>500 (Internal Server Error)</entry>
              </row>

              <row>
                <entry><classname>HttpMediaTypeNotAcceptableException</classname></entry>

                <entry>406 (Not Acceptable)</entry>
              </row>

              <row>
                <entry><classname>HttpMediaTypeNotSupportedException</classname></entry>

                <entry>415 (Unsupported Media Type)</entry>
              </row>

              <row>
                <entry><classname>HttpMessageNotReadableException</classname></entry>

                <entry>400 (Bad Request)</entry>
              </row>

              <row>
                <entry><classname>HttpMessageNotWritableException</classname></entry>

                <entry>500 (Internal Server Error)</entry>
              </row>

              <row>
                <entry><classname>HttpRequestMethodNotSupportedException</classname></entry>

                <entry>405 (Method Not Allowed)</entry>
              </row>

              <row>
                <entry><classname>MissingServletRequestParameterException</classname></entry>

                <entry>400 (Bad Request)</entry>
              </row>

              <row>
                <entry><classname>NoSuchRequestHandlingMethodException</classname></entry>

                <entry>404 (Not Found)</entry>
              </row>

              <row>
                <entry><classname>TypeMismatchException</classname></entry>

                <entry>400 (Bad Request)</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>
    </section>

    <section id="mvc-ann-exceptionhandler">
      <title><interfacename>@ExceptionHandler</interfacename></title>

      <para><interfacename>HandlerExceptionResolver</interfacename> 인터페이스의
      대안은 <interfacename>@ExceptionHandler</interfacename> 어노테이션이다. 컨트롤러
      메서드가 실행되는 동안 특정 타입의 예외가 던져졌을 때 어떤 메서드를 호출할 것인지 지정하려고
      컨트롤러내에서 <classname>@ExceptionHandler</classname> 메서드 어노테이션을 사용한다.
      예를 들면 다음과 같이 사용한다.</para>

      <programlisting language="java">@Controller
public class SimpleController {

  // 다른 컨트롤러 메서드는 생략한다

  @ExceptionHandler(IOException.class)
  public String handleIOException(IOException ex, HttpServletRequest request) {
    return ClassUtils.getShortName(ex.getClass());
  }
}</programlisting>

      <para>여기서는 <classname>java.io.IOException</classname>가 던져졌을 때
      'handlerIOException' 메서드를 호출할 것이다.</para>

      <para><classname>@ExceptionHandler</classname> 값을 예외 타입의 배열로 설정할
      수도 있다. 목록에 있는 타입의 예외가 던져지면 해당
      <classname>@ExceptionHandler</classname> 어노테이션이 붙은 메서드가 호출될 것이다.
      어노테이션 값을 설정하지 않으면 메서드 인자로 나열한 예외 타입을 사용한다.</para>

      <para><classname>@RequestMapping</classname> 어노테이션이 붙은 표준 컨트롤러
      메서드와 아주 비슷하게 <classname>@ExceptionHandler</classname> 메서드의 메서드
      인자와 반환값은 아주 유연하다. 예를 들어 서블릿 환경에서
      <classname>HttpServletRequest</classname>에 접근할 수 있고 포틀릿 환경에서
      <classname>PortletRequest</classname>에 접근할 수 있다. 반환값은 뷰 이름이나
      <classname>ModelAndView</classname> 객체로 해석되는
      <classname>String</classname>이 될 수 있다. 더 자세한 내용은 API 문서를
      참고해라.</para>
    </section>
  </section>

  <section id="mvc-coc">
    <title>설정보다는 관례(Convention over configuration)에 대한 지원</title>

    <para>많은 프로젝트에서 수립된 관례를 따르고 수긍할만한 기본값을 갖는 것이 프로젝트가 필요로
    하는 것이고 스프링 웹 MVC는 이제 <emphasis>설정보다는 관례(convention over
    configuration)</emphasis>를 명시적으로 지원한다. 즉, 작명 관례 같은 것을 수립하면 핸들러
    매핑, 뷰 리졸버, <classname>ModelAndView</classname> 인스턴스 등을 설정하는데 필요한
    설정의 <emphasis>상당부분을</emphasis> 제거할 수 있다. 이는 빠른 프로토타이핑과 관련에서
    아주 좋은 것이고 프로덕션에도 가져가야 할 코드 일관성(항상 좋은 것이다)을 유지할 수도
    있다.</para>

    <para>설정보다 관례의 지원은 MVC의 세가지 핵심 영역인 모델, 뷰, 컨트롤러를 처리한다.</para>

    <section id="mvc-coc-ccnhm">
      <title><classname>ControllerClassNameHandlerMapping</classname>
      컨트롤러</title>

      <para><classname>ControllerClassNameHandlerMapping</classname> 클래스는
      요청 URL과 이러한 요청을 처리하는
      <classname>ControllerClassNameHandlerMapping</classname> 인스턴스간의 매핑을
      결정하는데 관례를 사용하는 <interfacename>HandlerMapping</interfacename>
      구현체이다.</para>

      <para>다음의 간단한 <interfacename>Controller</interfacename> 구현체를 보자.
      특히 클래스의 <emphasis>이름</emphasis>을 주의깊게 봐라.<!--Re preceding sentence, I don't see where the name of the class is discussed in explanation following the example. See my next comment.--></para>

      <programlisting language="java">public class <emphasis role="bold">ViewShoppingCartController</emphasis> implements Controller {

    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {
        <lineannotation>// 이 예제에서는 구현체가 크게 중요하지 않다...</lineannotation>
    }
}</programlisting>

      <para>다음은 이에 대응하는 스프링 웹 MVC 설정파일의 일부이다.</para>

      <programlisting language="xml">&lt;bean class="org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping"/&gt;

&lt;bean id="<emphasis role="bold">viewShoppingCart</emphasis>" class="x.y.z.ViewShoppingCartController"&gt;
    <lineannotation>&lt;!-- 필요한 의존성을 주입한다... --&gt;</lineannotation>
&lt;/bean&gt;</programlisting>

      <para><classname>ControllerClassNameHandlerMapping</classname>는
      어플리케이션 컨텍스트에 정의된 다양한 핸들러(또는
      <interfacename>Controller</interfacename>) 빈을 모두 찾아내서 핸들러 매핑을
      정의하려고 이름에서 <literal>Controller</literal>를 제거한다. 그러므로
      <classname>ViewShoppingCartController</classname>는
      <literal>/viewshoppingcart*</literal> 요청 URL에 매핑된다.</para>

      <para>핵심 아이디어에 빨리 익숙해지도록 예제를 좀 더 보자. (카멜케이스의
      <interfacename>Controller</interfacename> 클래스명과는 대조적으로
      URL에서는 모두 소문자이다.)</para>

      <itemizedlist>
        <listitem>
          <para><classname>WelcomeController</classname>는
          <literal>/welcome*</literal> 요청 URL에 매핑된다</para>
        </listitem>

        <listitem>
          <para><classname>HomeController</classname>는
          <literal>/home*</literal> 요청 URL에 매핑된다</para>
        </listitem>

        <listitem>
          <para><classname>IndexController</classname>는
          <literal>/index*</literal> 요청 URL에 매핑된다</para>
        </listitem>

        <listitem>
          <para><classname>RegisterController</classname>는
          <literal>/register*</literal> 요청 URL에 매핑된다</para>
        </listitem>
      </itemizedlist>

      <para><classname>MultiActionController</classname> 핸들러 클래스의 경우
      생성되는 매핑이 약간 더 복잡하다. 다음 예제에서
      <interfacename>Controller</interfacename> 이름은
      <classname>MultiActionController</classname> 구현체가 된다고 가정한다.</para>

      <itemizedlist>
        <listitem>
          <para><classname>AdminController</classname>는
          <literal>/admin/*</literal> 요청 URL에 매핑된다</para>
        </listitem>

        <listitem>
          <para><classname>CatalogController</classname>는
          <literal>/catalog/*</literal> 요청 URL에 매핑된다</para>
        </listitem>
      </itemizedlist>

      <para>컨트롤러 구현체를 작성할 때
      <literal>xxx</literal><emphasis role="bold">Controller</emphasis> 같은
      작명 관례를 따른다면 <classname>ControllerClassNameHandlerMapping</classname>이
      <emphasis>엄청 길어질 수 있는</emphasis>
      <classname>SimpleUrlHandlerMapping</classname>(또는 비슷한)을 정의하고 유지하는
      지루한 작업에서 구해줄 것이다.</para>

      <para><classname>ControllerClassNameHandlerMapping</classname> 클래스가
      <classname>AbstractHandlerMapping</classname> 기반 클래스를 확장하므로
      <interfacename>HandlerInterceptor</interfacename> 인스턴스와 다른 다수의
      <interfacename>HandlerMapping</interfacename> 구현체에서 하는 모든 것을
      정의할 수 있다.</para>
    </section>

    <section id="mvc-coc-modelmap">
      <title>모델 <classname>ModelMap</classname>
      (<classname>ModelAndView</classname>)</title>

      <para><classname>ModelMap</classname> 클래스는 일반적인 작명 관례를 따르는
      <interfacename>View</interfacename>에 나타날 추가적인 객체를 만들수 있는 기본적으로
      중요한 <interfacename>Map</interfacename>이다. 다음의
      <interfacename>Controller</interfacename> 구현체를 보자. 관련된 어떤 이름도
      지정하지 않고도 이 객체는 <classname>ModelAndView</classname>에 추가된다.</para>

      <programlisting language="java">public class DisplayShoppingCartController implements Controller {

    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {

        List cartItems = <lineannotation>// <classname>CartItem</classname> 객체의 <interfacename>List</interfacename>를 가져온다</lineannotation>
        User user = <lineannotation>// 쇼핑을 하는 <classname>User</classname>를 가져온다</lineannotation>

        ModelAndView mav = new ModelAndView("displayShoppingCart"); <lineannotation>&lt;-- 논리적인 뷰 이름</lineannotation>

        mav.addObject(cartItems); <lineannotation>&lt;-- 잘 봐라. 이름이 없고 그냥 객체다</lineannotation>
        mav.addObject(user); <lineannotation>&lt;-- 여기서도 마찬가지다!</lineannotation>

        return mav;
    }
}</programlisting>

      <para><classname>ModelAndView</classname> 클래스는
      <classname>ModelMap</classname> 클래스를 사용한다.
      <classname>ModelMap</classname>은 객체가 맵에 추가되었을 때 객체에 대한 키를 자동으로
      생성하는 커스텀 <interfacename>Map</interfacename> 구현체이다. 추가된 객체(
      <classname>User</classname>같은 스칼라(scalar) 객체의 경우)에 대한 이름을 결정하는
      전력은 객체의 클래스의 짧은 클래스명을 사용하는 것이다. 다음 예제는
      <classname>ModelMap</classname> 인스턴스에 넣은 스칼라 객체에 대해 생성된
      이름이다.</para>

      <itemizedlist>
        <listitem>
          <para>추가한 <classname>x.y.User</classname> 인스턴스에는
          <literal>user</literal>라는 이름이 생성될 것이다.</para>
        </listitem>

        <listitem>
          <para>추가한 <classname>x.y.Registration</classname> 인스턴스에는
          <literal>registration</literal>이라는 이름이 생성될 것이다.</para>
        </listitem>

        <listitem>
          <para>추가한 <classname>x.y.Foo</classname> 인스턴스에는
          <literal>foo</literal>라는 이름이 생성될 것이다.</para>
        </listitem>

        <listitem>
          <para>추가한 <classname>java.util.HashMap</classname> 인스턴스에는
          <literal>hashMap</literal>이라는 이름이 생성될 것이다.
          <literal>hashMap</literal>는 직관적이지 않으므로 이 경우에는 이름을
          명시하기를 바랄 것이다.</para>
        </listitem>

        <listitem>
          <para><literal>null</literal>을 추가하면
          <classname>IllegalArgumentException</classname>가 던져질 것이다. 추가하는
          객체가 <literal>null</literal>이 될 수 있다면 이름을 명시하기를 원할
          것이다.</para>
        </listitem>
      </itemizedlist>

      <sidebar>
        <title>뭐? 자동으로 복수형을 만들지 않는다고?</title>

        <para>스프링 웹 MVC의 설정보다 관례 지원은 자동 복수형을 지원하지 않는다. 즉,
        <classname>Person</classname>객체의 <interfacename>List</interfacename>를
        <classname>ModelAndView</classname>에 추가할 수 없고 생성된 이름이
        <classname>people</classname>이 되지 않는다.</para>

        <para>약간의 토론 끝에 <quote>최소 놀람의 법칙</quote>이 이기는 것으로
        끝나서 이렇게 결정되었다.</para>
      </sidebar>

      <para><interfacename>Set</interfacename>나
      <interfacename>List</interfacename>를 추가한 후에 이름을 생성하는 전략은 컬랙션
      내부를 들여다보고 컬렉션의 첫번재 객체의 짧은 클래스 이름을 가져와서 이름에
      <literal>List</literal>를 추가해서 사용하는 것이다. 배열은 배열의 내용을 들여다 필요는
      없지만 배열에도 동일하게 적용된다. 다음은 컬렉션의 이름 생성 의미를 더 명확하게 해 줄
      예제들이다.</para>

      <itemizedlist>
        <listitem>
          <para>0개 이상의 <classname>x.y.User</classname> 요소로 이루어진
          <classname>x.y.User[]</classname> 배열은 <literal>userList</literal>라는
          이름이 생성될 것이다.</para>
        </listitem>

        <listitem>
          <para>0개 이상의 <classname>x.y.User</classname> 요소로 이루어진
          <classname>x.y.Foo[]</classname> 배열은 <literal>fooList</literal>라는
          이름이 생성될 것이다.</para>
        </listitem>

        <listitem>
          <para>하나 이상의 <classname>x.y.User</classname> 요소로 이루어진
          <classname>java.util.ArrayList</classname>은
          <literal>userList</literal>라는 이름이 생성될 것이다.</para>
        </listitem>

        <listitem>
          <para>하나 이상의 <classname>x.y.Foo</classname> 요소로 이루어진
          <classname>java.util.HashSet</classname>는
          <literal>fooList</literal>라는 이름이 생성될 것이다.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">비어 있는</emphasis>
          <classname>java.util.ArrayList</classname>는 전혀 추가되지 않을 것이다.
          (사실 <methodname>addObject(..)</methodname> 호출은 본질적으로 조작할
          수 없게(no-op) 될 것이다.)</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="mvc-coc-r2vnt">
      <title>뷰 -
      <interfacename>RequestToViewNameTranslator</interfacename></title>

      <para>논리적인 뷰 이름을 명시적으로 제공하지 않은 경우
      <interfacename>RequestToViewNameTranslator</interfacename> 인터페이스가
      논리적인 뷰 이름을 결정한다. 딱 하나의 구현체인
      <classname>DefaultRequestToViewNameTranslator</classname> 클래스가
      있다.</para>

      <para><classname>DefaultRequestToViewNameTranslator</classname>는
      이 예제처럼 요청 URL을 논리적인 뷰 이름으로 매핑한다.</para>

      <programlisting language="java">public class RegistrationController implements Controller {

    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {
        <lineannotation>// 요청을 처리한다...</lineannotation>
        ModelAndView mav = new ModelAndView();
        <lineannotation>// 필요에 따라 모델에 <emphasis role="bold">데이터</emphasis>를 추가한다...</lineannotation>
        return mav;
        <lineannotation>// <interfacename>View</interfacename>가 없거나 논리적인 뷰 이름이 설정되었다</lineannotation>
    }
}</programlisting>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;

    <lineannotation>&lt;!-- 잘 알려진 이름의 이 빈이 우리를 위해서 뷰 이름을 생성한다 --&gt;</lineannotation>
    &lt;bean id="viewNameTranslator"
        class="org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator"/&gt;

    &lt;bean class="x.y.RegistrationController"&gt;
        <lineannotation>&lt;!-- 필요에 따라 의존성을 주입한다 --&gt;</lineannotation>
    &lt;/bean&gt;

    <lineannotation>&lt;!-- 요청 URL을 컨트롤러 이름에 매핑한다 --&gt;</lineannotation>
    &lt;bean class="org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping"/&gt;

    &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
        &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;
        &lt;property name="suffix" value=".jsp"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</programlisting>

      <para><literal>handleRequest(..)</literal> 메서드의 구현부에서 반환되는
      <classname>ModelAndView</classname>에 어떻게 뷰가 없거나 논리적인 뷰가 설정되는
      지를 봐라. <classname>DefaultRequestToViewNameTranslator</classname>는 요청
      URL에서 <emphasis>논리적인 뷰 이름</emphasis>을 생성하는 작업을 한다. 앞의
      <classname>RegistrationController</classname>의 경우
      (<classname>ControllerClassNameHandlerMapping</classname>와 결합해서 사용하는)
      에는 <literal>http://localhost/registration.html</literal> 요청 URL에서
      <classname>DefaultRequestToViewNameTranslator</classname>가
      <literal>registration</literal>라는 논리적인 뷰 이름을 생성하게 된다. 그 다음에
      <classname>InternalResourceViewResolver</classname>가 이 논리적인 뷰 이름을
      <literal>/WEB-INF/jsp/registration.jsp</literal> 뷰로 처리한다.</para>

      <tip>
        <para><classname>DefaultRequestToViewNameTranslator</classname> 빈을
        명시적으로 정의할 필요는 없다.
        <classname>DefaultRequestToViewNameTranslator</classname>의 기본 설정으로
        좋다면 스프링 웹 MVC <classname>DispatcherServlet</classname>이 이 클래스를
        인스턴스화하도록 할 수 있다.(명시적으로 설정하지 않은 경우)</para>
      </tip>

      <para>물론 기본 설정을 변경해야 한다면 자신만의
      <classname>DefaultRequestToViewNameTranslator</classname> 빈을 명시적으로
      설정해야 한다. 설정할 수 있는 다영한 프로퍼티에 대한 자세한 내용은
      <classname>DefaultRequestToViewNameTranslator</classname> 클래스의 광범위한
      Javadoc을 참고해라.</para>
    </section>
  </section>

  <section id="mvc-etag">
    <title>ETag 지원</title>

    <para><ulink url="http://en.wikipedia.org/wiki/HTTP_ETag">ETag</ulink>(엔티티
    태그)는 HTTP/1.1 호환 웹서버가 반환하는 HTTP 응답헤더로 해당 URL의 내용의 변경사항이 있는지
    결정하는데 사용한다. ETag는 <literal>Last-Modified</literal> 헤더보다 더 정교한
    후계자정도로 생각할 수 있다. 서버가 ETag 헤더와 함께 응답을 반환했을 때 클라이언트는 이어진
    GET 요청에서(<literal>If-None-Match</literal>헤더에서) 이 헤더를 사용할 수 있다.
    내용이 변경되지 않았다면 서버는 <literal>304: Not Modified</literal>를
    반환한다.</para>

    <para>서블릿 필터 <classname>ShallowEtagHeaderFilter</classname>가 ETag 지원을
    제공한다. <classname>ShallowEtagHeaderFilter</classname>는 평범한 서블릿 필터이므로
    어떤 웹프레임워크와도 조합해서 사용할 수 있다. <!--The preceding sentence was a fragment, not a complete sentence. Have I reworded ok?-->
    <classname>ShallowEtagHeaderFilter</classname> 필터는 얕은(shallow)
    ETag(깊은 ETag와는 반대로 자세한 것은 나중에 설명한다.)라는 것을 생성한다.<!--Provide xref to deep ETags.-->
    <classname>ShallowEtagHeaderFilter</classname> 필터는 렌더링된 JSP의 내용을
    캐싱하고 그 내용으로 MD5 해시를 만들어서 응답에 ETag 헤더로 반환한다. 다음에 클라이언트가 같은
    리소스를 요청할 때 <literal>If-None-Match</literal> 값으로 이 해시를 사용한다.
    <classname>ShallowEtagHeaderFilter</classname> 필터는 이를 감지하고 뷰를 다시
    렌더링해서 두 해시를 비교한다. 이 두 해시가 같다면 <literal>304</literal>를 반환한다.
    이 필터는 뷰를 계속 렌더링하므로 처리 비용이 줄어들지 않는 것이다. 렌더링한 응답을 네트워크로
    다시 보내지 않으므로 여기서 줄어드는 것은 대역폭(bandwidth)뿐이다.</para>

    <para><filename>web.xml</filename>에
    <classname>ShallowEtagHeaderFilter</classname>를 설정한다.</para>

    <programlisting language="xml">&lt;filter&gt;
  &lt;filter-name&gt;etagFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.ShallowEtagHeaderFilter&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
  &lt;filter-name&gt;etagFilter&lt;/filter-name&gt;
  &lt;servlet-name&gt;petclinic&lt;/servlet-name&gt;
&lt;/filter-mapping&gt;</programlisting>
  </section>

  <section id="mvc-config">
    <title>스프링 MVC 설정하기</title>

	<para><xref linkend="mvc-servlet-special-bean-types"/>와
  <xref linkend="mvc-servlet-config"/>에서 스프링 MVC의 전용 빈과
  <classname>DispatcherServlet</classname>이 사용하는 기본 구현체에
  대해서 설명했다. 이번 섹션에서는 스프링 MVC를 설정하는 추가적인 두가지 방법을
  배울 것이다. 다시 얘기하자만 MVC Java config와 MVC XML 네임스페이스이다.
  </para>

	<para>MVC Java config와 MVC 네임스페이스는
  <classname>DispatcherServlet</classname> 기본값을 덮어쓰는 유사한
  기본 설정을 제공한다. 목표는 대부분의 어플리케이션이 같은 설정을 생성하는 것을
  줄이고 스프링 MVC가 간단한 시작점이 되고 사용하는 설정에 대한 사전지식이 전혀
  없거나 약간만 필요하도록 설정을 고수준으로 생성하는 것이다.</para>

	<para>자신의 선호에 따라 MVC Java config나 MVC 네인스페이스 중에서
    선택할 수 있다. MVC Java config로 생성된 스프링 MVC 빈을 직접
    세밀하게 커스터마이징하는 것 뿐만 아니라 사용하는 설정을 보기 쉽다는
    등의 더 자세한 내용은 아래에서 볼 것이다.
    하지만 처음부터 시작해 보자.
  </para>

	<section id="mvc-config-enable">
		<title>MVC Java Config나 MVC XML 네임스페이스 활성화하기</title>

		<para>MVC Java config를 활성화 하려면
    <interfacename>@Configuration</interfacename> 클래스중 하나에
    <interfacename>@EnableWebMvc</interfacename> 어노테이션을 추가해라.</para>

		<programlisting language="java">@EnableWebMvc
@Configuration
public class WebConfig {

}</programlisting>

		<para>동일한 내용을 XML로 설정하려면 <literal>mvc:annotation-driven</literal> 요소를 사용해라.</para>

		<programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:mvc="http://www.springframework.org/schema/mvc"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd"&gt;

    &lt;mvc:annotation-driven /&gt;

&lt;beans&gt;</programlisting>

      <para>위의 코드는 <interfacename>@RequestMapping </interfacename>,
      <interfacename>@ExceptionHandler</interfacename> 등과 같은 어노테이션을 사용해서
      어노테이션이 붙은 컨트롤러 메서드로 요청을 처리하는 지원에
      <classname>RequestMappingHandlerMapping</classname>,
      <classname>RequestMappingHandlerAdapter</classname>,
      <classname>ExceptionHandlerExceptionResolver</classname>
      (among others)를 등록한다.</para>

    <para>이는 다음을 활성화 한다.
	  <orderedlist>
          <listitem>
            <para>데이터 바인딩에 사용한 JavaBeans PropertyEditors에 추가적으로
            <link linkend="core-convert">ConversionService</link> 인스턴스를
            통한 스프링 3 방식의 타입 변환.</para>
          </listitem>

          <listitem>
            <para><interfacename>ConversionService</interfacename>로
            <interfacename>@NumberFormat</interfacename> 어노테이션을 사용해서
            숫자 필드의 <link linkend="format">포매팅</link>을 지원한다</para>
          </listitem>

          <listitem>
            <para>클래스패스에 Joda Time 1.3 이상의 버전이 있다면
            <interfacename>@DateTimeFormat</interfacename> 어노테이션을
            사용해서 Date, Calendar, Long, Joda Time 필드의
            <link linkend="format">포매팅</link>을 지원한다.</para>
          </listitem>

          <listitem>
            <para>클래스패스에 JSR-303 프로바이더가 있으면
            <interfacename>@Valid</interfacename>로 @Controller 입력의 <link
            linkend="validation-mvc-jsr303">유효성검사</link>를 지원한다.</para>
          </listitem>

          <listitem>
            <para>HttpMessageConverter가
            <interfacename>@RequestMapping</interfacename>나
            <interfacename>@ExceptionHandler</interfacename> 메서드에서
            <interfacename>@RequestBody</interfacename> 메서드 파라미터와
            <interfacename>@ResponseBody</interfacename> 메서드 반환값을
            지원한다.</para>

            <para>다음은 mvc:annotation-driven로 설정되는 HttpMessageConverter의
            전체 목록이다. <itemizedlist>
                <listitem>
                  <para><classname>ByteArrayHttpMessageConverter</classname>는
                  바이트 배열을 변환한다.</para>
                </listitem>

                <listitem>
                  <para><classname>StringHttpMessageConverter</classname>는
                  문자열을 변환한다.</para>
                </listitem>

                <listitem>
                  <para><classname>ResourceHttpMessageConverter</classname>는
                  모든 미디어 타입의
                  <classname>org.springframework.core.io.Resource</classname>를
                  변환한다.</para>
                </listitem>

                <listitem>
                  <para><classname>SourceHttpMessageConverter</classname>는
                  <classname>javax.xml.transform.Source</classname>를
                  변환한다.</para>
                </listitem>

                <listitem>
                  <para><classname>FormHttpMessageConverter</classname>는
                  폼 데이터를 <classname>MultiValueMap&lt;String,
                  String&gt;</classname>로 변환하거나 그 반대로 변환한다.</para>
                </listitem>

                <listitem>
                  <para><classname>Jaxb2RootElementHttpMessageConverter</classname>는
                  자바 객체를 XML로(혹은 그 반대로) 변환한다. (클래스패스에 JAXB2가 있는 경우
                  추가된다.)</para>
                </listitem>

                <listitem>
                  <para><classname>MappingJacksonHttpMessageConverter</classname>는
                  JSON을 변환한다.(클래스패스에 Jackson이 있는 경우 추가된다.)</para>
                </listitem>

                <listitem>
                  <para><classname>AtomFeedHttpMessageConverter</classname>는
                  Atom 피드를 변환한다. (클래스패스에 Rome이 있는 경우 추가된다.)</para>
                </listitem>

                <listitem>
                  <para><classname>RssChannelHttpMessageConverter</classname>는
                  RSS 피드를 변환한다. (클래스패스에 Rome이 있는 경우 추가된다.)</para>
                </listitem>
              </itemizedlist></para>

          </listitem>
        </orderedlist>
        </para>
	</section>

	<section id="mvc-config-customize">
    <title>제공된 설정의 커스터마이징</title>

		<para>자바에서 기본 설정을 커스터마이징하려면 그냥
    <interfacename>WebMvcConfigurer</interfacename> 인터페이스를 구현하거나
    <classname>WebMvcConfigurerAdapter</classname> 클래스를 상속받아서 필요한
    메서드를 오버라이드(이쪽 방법을 더 선호할 것이다.)한다. 다음은 오버라이드할 수 있는 메서드의
    예시이다. 전체 메서드의 목록은 <interfacename>WebMvcConifgurer</interfacename>를
    보고 자세한 내용은 Javadoc를 봐라.</para>

		<programlisting language="java">@EnableWebMvc
@Configuration
public class WebConfig extends WebMvcConfigurerAdapter {

  @Override
  protected void addFormatters(FormatterRegistry registry) {
    // 포매터나 컨버터를 추가한다
  }

  @Override
  public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
    // 사용할 HttpMessageConverter의 목록을 설정한다
  }

}</programlisting>

		<para><literal>&lt;mvc:annotation-driven /&gt;</literal>의 기본
    설정을 커스터마이징하려면 어떤 속성과 하위요소를 지원하는지 확인해 봐라. 사용할 수 있는
    속성과 하위요소를 찾으려면 <ulink
    url="http://static.springsource.org/schema/mvc/spring-mvc-3.1.xsd">Spring
    MVC XML 스키마</ulink>를 보거나 IDE에서 코드 자동완성 기능을 사용할 수 있다. 아래
    예제에서 사용할 수 있는 것들중 일부를 보여주고 있다.</para>

		<programlisting language="xml">&lt;mvc:annotation-driven conversion-service="conversionService"&gt;
    &lt;mvc:message-converters&gt;
        &lt;bean class="org.example.MyHttpMessageConverter"/&gt;
        &lt;bean class="org.example.MyOtherHttpMessageConverter"/&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;

&lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt;
    &lt;property name="formatters"&gt;
        &lt;list&gt;
            &lt;bean class="org.example.MyFormatter"/&gt;
            &lt;bean class="org.example.MyOtherFormatter"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>

	</section>

    <section id="mvc-config-interceptors">
      <title>인터셉터 설정</title>

      <para><interfacename>HandlerInterceptors</interfacename>나
      <interfacename>WebRequestInterceptors</interfacename>를 모든 요청이나 특정
      URL 경로패턴에 한정해서 적용되도록 설정할 수 있다.</para>

      <para>자바로 인터셉터를 등록하는 예제:</para>

      <programlisting language="java">@EnableWebMvc
@Configuration
public class WebConfig extends WebMvcConfigurerAdapter {

  @Override
  public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new LocalInterceptor());
    registry.addInterceptor(new SecurityInterceptor()).addPathPatterns("/secure/*");
 }

}</programlisting>

      <para><literal>&lt;mvc:interceptors&gt;</literal> 요소를 사용해서 XML로 등록하는 예제:</para>

      <programlisting language="xml">&lt;mvc:interceptors&gt;
    &lt;bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor" /&gt;
    &lt;mvc:interceptor&gt;
        &lt;mapping path="/secure/*"/&gt;
        &lt;bean class="org.example.SecurityInterceptor" /&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</programlisting>

    </section>

    <section id="mvc-config-view-controller">
      <title>뷰 컨트롤러 설정</title>

      <para>이는 호출하면 바로 뷰로 포워딩되는
      <classname>ParameterizableViewController</classname>를 정의하는 숏컷이다.
      뷰가 응답을 생성하기 전에 실행할 자바 컨트롤러 로직이 없는 정적인 경우에 이를 사용한다.</para>

      <para>자바로 <literal>"/"</literal>에 대한 요청을
      <literal>"home"</literal>라는 뷰로 보내는 예제:</para>

      <programlisting language="java">@EnableWebMvc
@Configuration
public class WebConfig extends WebMvcConfigurerAdapter {

  @Override
  public void addViewControllers(ViewControllerRegistry registry) {
    registry.addViewController("/").setViewName("home");
  }

}</programlisting>

    <para><literal>&lt;mvc:view-controller&gt;</literal> 요소를 사용해서 XML로 설정하는 예제:</para>

      <programlisting language="xml">&lt;mvc:view-controller path="/" view-name="home"/&gt;</programlisting>
    </section>

    <section id="mvc-config-static-resources">
      <title>리소스 제공(Serving) 설정</title>

      <para>이 옵션은 <classname>ResourceHttpRequestHandler</classname>가
      <classname>Resource</classname> 위치에 있는 목록에서 제공하도록 특정 URL 패턴을
      따르는 정적 리소스 요청을 허용한다. 이는 클래스 패스의 경로를 포함해서 웹 어플리케이션 루트가
      아닌 다른 위치에서 정적 리소스를 제공하는 편리한 방법을 제공한다. 만료시간 헤더(Page Speed나
      YSlow같은 최적화 도구는 1년을 권장한다.)를 설정하는데 <code>cache-period</code>
      프로퍼티를 사용할 것이므로 클라이언트가 더 효율적으로 사용할 수 있을 것이다. 핸들러가
      <code>Last-Modified</code> 헤더도 적절히 평가할 것이므로(존재한다면)
      <code>304</code> 상태코드를 알맞게 반환해서 클라이언트가 이미 캐싱항 리소스에 대한
      불필요한 오버헤드를 줄일 것이다. 예를 들어 <code>/resources/**</code> URL 패턴으로
      웹 어플리케이션 내의 <code>public-resources</code> 디렉토리에서 리소스를 제공하려면
      다음과 같이 사용할 것이다.</para>

	  <programlisting language="java">@EnableWebMvc
@Configuration
public class WebConfig extends WebMvcConfigurerAdapter {

  @Override
  public void addResourceHandlers(ResourceHandlerRegistry registry) {
    registry.addResourceHandler("/resources/**").addResourceLocations("/public-resources/");
  }

}</programlisting>

    <para>XML로는 다음과 같이 사용한다.</para>

      <programlisting language="xml">&lt;mvc:resources mapping="/resources/**" location="/public-resources/"/&gt;</programlisting>

      <para>브라우저 캐시가 사용할 최대 기간을 보장하고 브라우저의 HTTP 요청을 줄이려고 1년
      만료 헤더와 함께 이러한 리소스를 제공하려면 다음과 같이 설정한다.</para>

	  <programlisting language="java">@EnableWebMvc
@Configuration
public class WebConfig extends WebMvcConfigurerAdapter {

  @Override
  public void addResourceHandlers(ResourceHandlerRegistry registry) {
    registry.addResourceHandler("/resources/**").addResourceLocations("/public-resources/").setCachePeriod(31556926);
  }

}</programlisting>

    <para>XML로는 다음과 같이 설정한다.</para>

      <programlisting language="xml">&lt;mvc:resources mapping="/resources/**" location="/public-resources/" cache-period="31556926"/&gt;</programlisting>

      <para><code>mapping</code> 속성은
      <classname>SimpleUrlHandlerMapping</classname>가 사용할 수 있는 Ant 패턴이어야
      하고 <code>location</code> 속성은 하나이상의 리소스 디렉토리 위치를 지정해야 한다. 목록을
      콤마로 구분해서 여러 리소스 위치를 지정할 수도 있다. 해당 요청의 리소스가 존재하는지 여부를
      지정한 순서대로 지정된 위치를 확인한다. 예를 들어 웹 어플리케이션 루트와 클래스 패스에 어떤
      jar에서라도 알려진 <code>/META-INF/public-web-resources/</code> 경로 모두에서
      리소스를 제공하려면 다음과 같이 설정한다.</para>

	  <programlisting language="java">@EnableWebMvc
@Configuration
public class WebConfig extends WebMvcConfigurerAdapter {

  @Override
  public void addResourceHandlers(ResourceHandlerRegistry registry) {
    registry.addResourceHandler("/resources/**")
      .addResourceLocations("/", "classpath:/META-INF/public-web-resources/");
  }

}</programlisting>

	  <para>XML에서는 다음과 같이 설정한다.</para>

      <programlisting language="xml">&lt;mvc:resources mapping="/resources/**" location="/, classpath:/META-INF/public-web-resources/"/&gt;</programlisting>

      <para>새로운 버전의 어플리케이션을 배포했을 때 변경될 수도 있는 리소스를 제공하는 경우
      클라이언트가 새로운 버전으로 배포된 어플리케이션의 리소스를 강제로 요청하도록 리소스 요청에
      사용하는 매핑 패턴에 버전 문자열을 포함시키는 것을 권장한다. 이러한 버전 문자열은 파라미터화될
      수 있고 SpEL로 접근할 수 있으므로 새로운 버전을 배포할 때 단일 지점에서 쉽게 관리할
      수 있다.</para>

      <para>예제처럼 프로덕션에서 Dojo 자바스크립트 라이브러리의 성능 최적화가 된 커스텀 빌드버전
      (권장사항대로)을 사용하는 어플리케이션을 생각해 보자. 그리고 이 빌드는 일반적으로 웹
      어플리케이션내에서 <code>/public-resources/dojo/dojo.js</code> 경로에 배포한다.
      Dojo의 다른 부분들이 어플리케이션의 새로운 각 버전에 대한 커스컴 빌드에 포함될 것이므로
      클라이언트 웹 브라우저가 새로운 버전의 어플리케이션이 배포될 때마다 커스텀 빌드
      <code>dojo.js</code> 리소스를 강제대로 새로 다운로드 하도록 해야 한다. 다음과 같이
      어플리케이션의 버전을 프로퍼티 파일에서 관리하는 것이 이를 위한 가장 간단한 방법이다.</para>

      <programlisting>application.version=1.0.0</programlisting>

      <para>그 다음 프로퍼티 파일의 값을 <code>util:properties</code> 태그를 사용하는
      빈처럼 SpEL에서 접근가능하도록 한다.</para>

      <programlisting language="xml">&lt;util:properties id="applicationProps" location="/WEB-INF/spring/application.properties"/&gt;</programlisting>

      <para>이제 SpEL로 접근가능한 어플리케이션 버전을 <code>resources</code> 태그를
      사용할때 포함시킬 수 있다.</para>

      <programlisting language="xml">&lt;mvc:resources mapping="/resources-#{applicationProps['application.version']}/**" location="/public-resources/"/&gt;</programlisting>

      <para>자바에서는 <interfacename>@PropertySouce</interfacename> 어노테이션을
      사용해서 정의된 모든 프로퍼티에 접근하도록 <classname>Environment</classname>
      추상화를 주입할 수 있다.</para>

      	  <programlisting language="java">@EnableWebMvc
@Configuration
@PropertySource("/WEB-INF/spring/application.properties")
public class WebConfig extends WebMvcConfigurerAdapter {

  @Inject Environment env;

  @Override
  public void addResourceHandlers(ResourceHandlerRegistry registry) {
    registry.addResourceHandler("/resources-" + env.getProperty("application.version") + "/**")
      .addResourceLocations("/public-resources/");
  }

}</programlisting>

      <para>마지막으로 적절한 URL로 리소스를 요청하기 위해 스프링의 JSP 태그의 장점을
      취할 수 있다.</para>

      <programlisting language="xml">&lt;spring:eval expression="@applicationProps['application.version']" var="applicationVersion"/&gt;

&lt;spring:url value="/resources-{applicationVersion}" var="resourceUrl"&gt;
    &lt;spring:param name="applicationVersion" value="${applicationVersion}"/&gt;
&lt;/spring:url&gt;

&lt;script src="${resourceUrl}/dojo/dojo.js" type="text/javascript"&gt; &lt;/script&gt;</programlisting>
    </section>

    <section id="mvc-default-servlet-handler">
      <title>mvc:default-servlet-handler</title>

      <para>이 태그는 여젼히 컨테이너의 기본 서블릿이 정적 리소스 요청을 처리하도록 하면서
      <code>DispatcherServlet</code>을 "/"에 매핑할 수 있게 한다.(그래서 컨테이너의
      기본 서블릿의 매핑을 오버라이딩한다) "/**" URL 매핑으로
      <code>DefaultServletHttpRequestHandler</code>를 설정하고 다른 URL 매핑에
      상대적으로 낮은 우선순위를 설정한다.</para>

      <para>이 핸들러는 모든 요청을 기본 서블릿으로 보낼 것이다. 그러므로 다른 모든 URL
      <code>HandlerMappings</code>의 순서에서 마지막에 있게 하는 것이 중요하다.
      <code>&lt;mvc:annotation-driven&gt;</code>을 사용하거나 아니면 자신만의
      커스터마이징된 <code>HandlerMapping</code> 인스턴스를 설정한 경우에
      <code>DefaultServletHttpRequestHandler</code>의 <code>order</code>
      프로퍼티 값(<code>Integer.MAX_VALUE</code>)보다 낮은 값으로 설정해야 한다.</para>

      <para>기본 설정을 사용해서 이 기능을 활성화 하려면 다음과 같이 한다.</para>

	  <programlisting language="java">@EnableWebMvc
@Configuration
public class WebConfig extends WebMvcConfigurerAdapter {

  @Override
  public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
    configurer.enable();
  }

}</programlisting>

	  <para>XML에서는 다음과 같이 설정한다.</para>

      <programlisting language="xml">&lt;mvc:default-servlet-handler/&gt;</programlisting>

      <para>"/" 서블릿 매핑을 오버라이딩할 때의 주의할 점은 기본 서블릿의
      <code>RequestDispatcher</code>를 경로가 아니라 이름으로 획득해야 한다는 것이다.
      <code>DefaultServletHttpRequestHandler</code>는 시작할 때 대부분의 주요 서블릿
      컨테이너(Tomcat, Jetty, Glassfish, JBoss, Resin, WebLogic, WebSphere를
      포함해서)의 알려진 이름 목록을 사용해서 컨테이너의 기본 서블릿을 자동으로 탐지하려고 시도할
      것이다. 다른 이름으로 기본 서블릿을 커스텀해서 설정했거나 기본 서블릿 이름을 알지 못하는 다른
      서블릿 컨테이너를 사용했다면 기본 서블릿의 이름을 다음 예제에서 처럼 명시적으로 제공해야
      한다.</para>

	  <programlisting language="java">@EnableWebMvc
@Configuration
public class WebConfig extends WebMvcConfigurerAdapter {

  @Override
  public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
    configurer.enable("myCustomDefaultServlet");
  }

}</programlisting>

      <para>XML에서는 다음과 같이 설정한다.</para>

      <programlisting language="xml">&lt;mvc:default-servlet-handler default-servlet-name="myCustomDefaultServlet"/&gt;</programlisting>
    </section>

    <section id="mvc-resources">
      <title>부가적인 Spring Web MVC 자료</title>

      <para>스프링 웹 MVC에 대한 자세한 내용은 다음의 링크와 문서를 봐라.</para>

      <itemizedlist>
        <listitem>
          <para>스프링 MVC로 웹어플리케이션을 어떻게 만드는지에 대한 뛰어난 글과 튜토리얼이 많이
          있다. <ulink url="http://www.springsource.org/documentation">Spring
          문서</ulink> 페이지에서 읽어봐라.</para>
        </listitem>

        <listitem>
          <para>Seth Ladd 등이 쓴 <quote>Expert Spring Web MVC and Web Flow</quote>
          (Apress 출판)는 스프링 웹 MVC의 좋은 점에 대한 뛰어난 책이다.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="mvc-config-advanced-java">
      <title>MVC Java Config를 사용한 고급 커스터마이징</title>

      <para>앞의 예제들에서 볼 수 있었듯이 MVC Java config와 MVC 네임스페이스는 사용하는
      빈에 대한 깊은 지식 없이도 고수준의 결과물을 제공한다. 대신 어플리케이션에 필요한 것에
      집중할 수 있게 해준다. 하지만 어떤 부분에서는 더 세밀한 제어를 하거나 사용하는 설정을
      이해하기 원할 것이다.</para>

      <para>더 세밀한 제어를 하기 위한 첫번째 단계는 당신의 위해서 생성된 의존 빈을 보는 것이다.
      MVC Java config에서는 <classname>WebMvcConfigurationSupport</classname>의
      <interfacename>@Bean</interfacename> 메서드와 Javadoc을 볼 수 있다. 이 클래스의
      설정은 <interfacename>@EnableWebMvc</interfacename> 어노테이션으로 자동 임포트된다.
      실제로 <interfacename>@EnableWebMvc</interfacename>를 열어보면
      <interfacename>@Import</interfacename>문을 볼 수 있다.</para>

      <para>더 세밀한 제어를 하기 위한 다음 단계는
      <classname>WebMvcConfigurationSupport</classname>에 생성된 빈 중 하나에서
      프로퍼티를 커스터마이징하거나 자신의 인스턴스를 제공하도록 하는 것이다. 이를 위해서는 두 가지가
      필요하다. 임포트하지 않도록 <interfacename>@EnableWebMvc</interfacename>
      어노테이션을 제거하고 <classname>WebMvcConfigurationSupport</classname>를
      직접 확장한다. 다음은 그 예제이다.
      </para>

      <programlisting language="java">@Configuration
public class WebConfig extends WebMvcConfigurationSupport {

  @Override
  public void addInterceptors(InterceptorRegistry registry){
    // ...
  }

  @Override
  @Bean
  public RequestMappingHandlerAdapter requestMappingHandlerAdapter() {

      // 생성하거나 "super"가 아답터를 생성하게 한다
      // 그 다음 그 프로퍼티중 하나를 커스터마이징한다
  }

}</programlisting>

      <para>이 방법으로 빈을 수정하는 것은 이번 섹션의 앞에서 보여주었던 고수준의 결과물을
      사용하는 것을 막지 않는다. </para>

    </section>

    <section id="mvc-config-advanced-xml">
      <title>MVC 네임스페이스를 사용한 고급 커스터마이징</title>

      <para>MVC 네임스페이스에서는 생성된 설정 이상의 세밀한 제어가 약간 더
      어렵다.</para>

      <para>세밀한 제어가 필요하다면 제공하는 설정을 교체하기 보다는 타입으로
      커스터마이징하려는 빈을 탐지하는
      <interfacename>BeanPostProcessor</interfacename>을 설정하고
      필요에 따라 그 프로퍼티를 수정하는 것을 고려해봐라. 다음은 그 예제이다.</para>

    <programlisting language="java">@Component
public class MyPostProcessor implements BeanPostProcessor {

  public Object postProcessBeforeInitialization(Object bean, String name) throws BeansException {
    if (bean instanceof RequestMappingHandlerAdapter) {
      // 아답터의 프로퍼티를 수정한다
    }
  }

}</programlisting>

      <para>자동 탐지되도록 <interfacename>&lt;component scan /&gt;</interfacename>에
      <classname>MyPostProcessor</classname>를 포함시키거나 원한다면 XML 빈 선언에
      명시적으로 <classname>MyPostProcessor</classname>를 선언할 수 있다.</para>
    </section>

  </section>

</chapter>
