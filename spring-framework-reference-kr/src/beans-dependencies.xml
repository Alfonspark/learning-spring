<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<section id="beans-dependencies">
  <title>의존성</title>

  <para>일반적인 엔터프라이즈 어플리케이션은 하나의 객체(또는 스프링 용어로는 빈)로 이루어지지 
    않는다. 가장 간단한 어플리케이션에서 조차도 엔드유저가 하나의 긴밀한 어플리케이션처럼 느낄 
    수 있도록 함께 동작하는 약간의 객체들이 있다. 다음 섹션은 목표를 이루기 위해 객체들이 
    협력하는 완전히 구현된 어플리케이션에서 독립적인 다수의 빈을 어떻게 정의하는지 설명한다.</para>

  <section id="beans-factory-collaborators">
    <title>의존성 주입</title>

    <!-- MLP: Beverly review the following two paragraphs -->

    <para><emphasis>의존성 주입</emphasis> (DI)은 객체들이 같이 동작할 객체들의 의존성을 
      생성자 아규먼트와 팩토리 메서드의 아규먼트와 생성되거나 팩토리 메서드에서 리턴된 객체 
      인스턴스에 설정된 프로퍼티만으로 정의하는 과정이다. 그 다음 컨테이너는 빈을 생성할 때 
      빈들의 의존성을 <emphasis>주입</emphasis>한다. 이 과정은 기본적으로 빈 스스로 
      인스턴스화를 제어하거나 자신의 의존성을 클래스의 생성자를 직접 사용해서 결정하는 것과는 
      거꾸로 된 것(그래서 <emphasis>제어의 역전</emphasis> (IoC)라고 부른다.)이다. 
      또는 <emphasis>서비스 로케이터</emphasis> 패턴도 있다.</para>

    <para>DI 원리를 적용하면 코드는 더 깔끔해지고 객체들이 의존성과 함께 제공될 때 디커플링이 
      더욱 효과적이다. 객체는 자신의 의존성을 검색하지 않고 의존성의 위치나 클래스를 알지 
      못한다. 이처럼 클래스들은 테스트하기 쉬워지고 특히 유닛 테스트에서 사용하는 스텁(stub)이나 
      목(mock) 구현체를 사용할 수 있는 인터페이스나 추상 기반 클래스에 의존성이 있을 때 더욱 
      쉬워진다.</para>

    <para>DI에는 2가지의 큰 변형이 존재한다. <link
      linkend="beans-constructor-injection">생성자 기반의 의존성 주입</link>과 
      <link linkend="beans-setter-injection">Setter 기반의 의존성 주입</link>이다.</para>

    <section id="beans-constructor-injection">
      <title>생성자 기반의 의존성 주입</title>

      <para><emphasis>생성자 기반의</emphasis> DI는 의존성을 나타내는 다수의 아규먼트로 
        생성자를 호출하는 컨테이너에서 이뤄진다. 빈을 생성하려고 아규먼트를 지정해서 
        <literal>static</literal> 팩토리 메서드를 호출하는 것과 거의 비슷하다. 이 말은 
        생성자에 대한 아규먼트와 <literal>static</literal> 팩토리 메서드에 대한 메서드를 
        비슷하게 다룬다는 의미다. 다음 예제는 생성자 주입으로만 의존성 주입이 될 수 있는 
        클래스를 보여준다. 클래시는 <emphasis>특별한</emphasis> 클래스가 아니고 컨테이너에서 
        특정한 인터페이스나 기반 클래스, 어노테이션에 의존성이 없는 POJO다.</para>

      <programlisting language="java">public class SimpleMovieLister {

  <lineannotation>// <classname>SimpleMovieLister</classname>는 <interfacename>MovieFinder</interfacename>에 의존성이 있다</lineannotation>
  private MovieFinder movieFinder;

  <lineannotation>// 스프링 컨테이너가 <interfacename>MovieFinder</interfacename>를 '주입'할 수 있도록 하는 생성자</lineannotation>
  public SimpleMovieLister(MovieFinder movieFinder) {
      this.movieFinder = movieFinder;
  }

  <lineannotation>// 주입된 <interfacename>MovieFinder</interfacename>를 실제로 '사용'하는 비즈니스 로직은 생략했다...</lineannotation>
}</programlisting>

      <section id="beans-factory-ctor-arguments-resolution">
        <title>생성자 아규먼트 결정</title>

        <para>생성자 아규먼트는 아규먼트의 타입을 사용해서 결정한다. 빈 정의의 생성자 아규먼트에 
          잠재적인 불확실성은 전혀 없고 빈 정의에서 정의된 생성자 아규먼트의 순서는 빈이 
          인스턴스화 될 때 적절한 생성자에 전달할 아규먼트의 순서이다. 다음 클래스를 보자.</para>

        <programlisting language="java">package x.y;

public class Foo {

  public Foo(Bar bar, Baz baz) {
      <lineannotation>// ...</lineannotation>
  }
}</programlisting>

        <para><classname>Bar</classname> 클래스와 <classname>Baz</classname> 클래스가 
          상속관계가 아니라고 가정하면 잠재적인 불확실성이 존재하지 않는다. 그러므로 다음의 설정은 
          잘 동작하고 생성자 아규먼트 인덱스나 <literal>&lt;constructor-arg/&gt;</literal> 
          요소에 명시적으로 타입을 지정할 필요가 없다.</para>

        <programlisting language="xml">&lt;beans&gt;
  &lt;bean id="foo" class="x.y.Foo"&gt;
      &lt;constructor-arg ref="bar"/&gt;
      &lt;constructor-arg ref="baz"/&gt;
  &lt;/bean&gt;

  &lt;bean id="bar" class="x.y.Bar"/&gt;
  &lt;bean id="baz" class="x.y.Baz"/&gt;

&lt;/beans&gt;</programlisting>

        <para>또 다른 빈이 참조되되었을 때 타입을 알고 있으면 매치할 수 있다.(앞의 예제와 같이) 
          <literal>&lt;value&gt;true&lt;value&gt;</literal>처럼 간단한 
          타입이 사용되면 스프링은 value의 타입을 결정할 수 없다. 그래서 다른 정보가 없으면 
          타입을 매치할 수 없다. 다음 클래스를 보자.</para>

        <programlisting language="java">package examples;

public class ExampleBean {

  <lineannotation>// Ultimate Answer를 계산하는 연도</lineannotation>
  private int years;

  <lineannotation>// 삶, 전세계, 모든 것들에 대한 대답</lineannotation>
  private String ultimateAnswer;

  public ExampleBean(int years, String ultimateAnswer) {
      this.years = years;
      this.ultimateAnswer = ultimateAnswer;
  }
}</programlisting>

        <section id="beans-factory-ctor-arguments-type">
          <title>생성자 아규먼트 타입 매칭</title>

          <para>앞의 시나리오에서 <literal>type</literal> 속성을 사용해서 생성자 아규먼트의 
            타입을 명시적으로 지정하면 컨테이너는 간단한 타입의 타입매칭을 <emphasis>할 수
            </emphasis> 있다. 다음 예제를 보자.</para>

          <programlisting language="xml">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
&lt;constructor-arg type="int" value="7500000"/&gt;
&lt;constructor-arg type="java.lang.String" value="42"/&gt;
&lt;/bean&gt;</programlisting>
        </section>

        <section id="beans-factory-ctor-arguments-index">
          <title>생성자 아규먼트 인덱스</title>

          <para>명시적으로 생성자 아규먼트의 인덱스를 지정하려면 <literal>index</literal> 
            속성을 사용해라. 다음 예제를 보자.</para>

          <programlisting language="xml">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
&lt;constructor-arg index="0" value="7500000"/&gt;
&lt;constructor-arg index="1" value="42"/&gt;
&lt;/bean&gt;</programlisting>

          <para>다수의 간단한 값이 가지는 불확실성을 해결하는데 추가로 같은 타입의 두 
            아규먼트를 가지는 생성자의 불확실성은 인덱스를 지정해서 해결한다. 참고로 
            <emphasis>index는 0부터 시작한다.</emphasis></para>
        </section>

        <section id="beans-factory-ctor-arguments-name">
          <title>생성자 아규먼트 이름</title>

          <para>스프링 3.0처럼 명확한 값을 위해 생성자 파라미터 이름도 사용할 수 있다.</para>

          <programlisting language="xml">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
&lt;constructor-arg name="years" value="7500000"/&gt;
&lt;constructor-arg name="ultimateanswer" value="42"/&gt;
&lt;/bean&gt;</programlisting>

          <para>이 코드가 동작하려면 스프링이 생성자에서 파라미터명을 검색할 수 있도록 debug 플래그를 사용 가능 하도록 해놓고 컨파일 해야 한다. debug 플래그를 사용 가능으로 해도 컴파일할 수 없다면(또는 debug 플래그를 사용하고 싶지 않다면) 생성자 아규먼트의 이름을 명시적으로 짓는 <interfacename><ulink
          url="http://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html">@ConstructorProperties</ulink></interfacename> JDK 어노테이션을 사용할 수 있다. 예제 클래스는 다음과 같다.</para>

          <programlisting language="java">package examples;

public class ExampleBean {

  <lineannotation>// </lineannotation>필드는 생략한다

  @ConstructorProperties({"years", "ultimateAnswer"})
  public ExampleBean(int years, String ultimateAnswer) {
      this.years = years;
      this.ultimateAnswer = ultimateAnswer;
  }
}</programlisting>
        </section>
      </section>
    </section>

    <section id="beans-setter-injection">
      <title>Setter 기반의 의존성 주입</title>

      <para><emphasis>Setter 기반의</emphasis> DI는 빈을 인스턴스화 하기 위해 
        아규먼트가 없는 생성자나 아규먼트가 없는 <literal>static</literal> 팩토리 메서드를 
        호출한 뒤에 빈의 setter 메서드를 호출하는 컨테이너로 이뤄진다.</para>

      <para>다음 예제는 순수한 setter 주입을 사용해서만 의존성 주입이 되는 클래스를 보여준다. 
        이 클래스는 평범한 자바 클래스다. 컨테이너에 특정 인터페이스나 기반 클래스, 
        어노테이이션에 의존성이 없는 POJO이다.</para>

      <programlisting language="java">public class SimpleMovieLister {

  <lineannotation>// <classname>SimpleMovieLister</classname>는 <interfacename>MovieFinder</interfacename>에 의존성이 있다</lineannotation>
  private MovieFinder movieFinder;

  <lineannotation>// 스프링 컨테이너가 <interfacename>MovieFinder</interfacename>를 '주입'할 수 있는 setter 메서드</lineannotation>
  public void setMovieFinder(MovieFinder movieFinder) {
      this.movieFinder = movieFinder;
  }

  <lineannotation>// 실제 주입된 <interfacename>MovieFinder</interfacename>를 '사용'하는 비즈니스 로직은 생략한다...</lineannotation>
}</programlisting>

      <para><interfacename>ApplicationContext</interfacename>는 빈이 관리하는 생성자 
        기반의 DI와 setter 기반의 DI를 지원한다. 생성자 방법으로 이미 주입된 의존성에 대해서 
        setter 기반의 DI도 지원한다. 프로퍼티를 하나의 형식에서 다른 형식으로 변환하는 
        <interfacename>PropertyEditor</interfacename> 인스턴스와 함께 사용하는 
        <interfacename>BeanDefinition</interfacename>의 형식으로 의존성을 설정한다. 
        하지만 대부분의 스프링 사용자들은 이러한 클래스들을 직접 사용하지 않고(프로그래밍적으로) 
        내부적으로 이러한 클래스의 인스턴스로 변환되는 XML 정의 파일을 사용해서 전체 스프링 
        IoC 컨테이너 인스턴스를 로드한다.</para>

      <sidebar>
        <title>생성자 기반의 DI냐? setter 기반의 DI냐?</title>

        <para>생성자 기반 DI와 Setter 기반 DI를 섞어서 사용할 수 있으므로 경험에 의하면 
          강제적인 의존성은 생성자 아규먼트를 사용하고 선택적인 의존성은 setter를 사용하는 
          것이 좋다. setter에 <link linkend="beans-required-annotation">@Required
          </link> 어노테이션을 사용해서 의존성이 꼭 필요한 setter를 만들 수 있다.</para>

        <para>스프링 팀은 보통 setter 주입을 더 좋아한다. 왜냐하면, 생성자 아규먼트가 많아지면 
          다루기가 쉽지 않기 때문이다. 특히 프로퍼티가 선택적이면 더욱 다루기가 어렵다. 
          setter 메서드는 나중에 다시 설정하거나 다시 주입해야 하는 클래스의 객체들을 만들 
          수도 있다. <link linkend="jmx">JMX MBean</link>을 통한 관리는 강제적인 
          유즈케이스이다.</para>

        <para>몇몇 순수주의자들은 생성자 기반의 주입을 좋아한다. 모든 객체의 의존성을 
          제공한다는 것은 객체가 항상 클라이언트한테 완전히 초기화된 상태를 리턴한다는 것을 
          의미한다. 이 방법은 단점은 객체가 재구성이나 재주입하기가 쉽지 않아진다는 것이다.</para>

        <para>개별 클래스에 적절한 DI를 사용해라. 때때로 소스코드가 없는 서드파티 클래스를 
          다룰 때는 어떤 DI를 사용할 지 직접 선택해야 한다. 레거시 클래스는 어떤 setter 
          메서드도 제공하지 않을 수 있으므로 생성자 주입이 이용 가능한 유일한 DI일 것이다.</para>
      </sidebar>
    </section>

    <section>
      <title>의존성 해결 과정</title>

      <para>컨테이너는 빈의 의존성 처리를 다음과 같이 처리한다.</para>

      <!-- MLP: Beverly to review all list items-->

      <orderedlist>
        <listitem>
          <para><interfacename>ApplicationContext</interfacename>는 빈에 대한 모든 
            정보를 담고 있는 설정 메타데이터로 생성되고 초기화된다. 설정 메타데이터는 XML이나 
            자바 코드, 어노테이션으로 명시할 수 있다.</para>
        </listitem>

        <listitem>
          <para>프로퍼티나 생성자 아규먼트, 일반적인 생성자 대신 사용하는 정적-팩토리 
            메서드의 형식으로 각 빈의 의존성을 나타낸다. <emphasis>빈이 실제로 생성될 
            때</emphasis> 이러한 의존성을 빈에 제공한다.</para>
        </listitem>

        <listitem>
          <para>각 프로퍼티나 생성자 아규먼트는 설정하려는 값에 대한 실제 정의이거나 컨테이너의 
            다른 빈에 대한 참조이다.</para>
        </listitem>

        <listitem>
          <para>각 프로퍼티나 생성자 아규먼트의 값은 명시된 타입에서 해당 프로퍼티나 생성자 
            아규먼트의 실제 타입으로 변환된다. 기본적으로 스프링은 문자열 형식으로 제공된 
            값을 <literal>int</literal>, <literal>long</literal>, 
            <literal>String</literal>, <literal>boolean</literal> 같은 내장된 
            모든 타입으로 변환할 수 있다.</para>
        </listitem>
      </orderedlist>

      <para>스프링 컨테이너는 컨테이너가 생성될 때 빈 참조 프로퍼티가 유효한 빈을 참조하는지 
        등과 같은 각 빈의 설정에 대한 유효성을 확인한다. 하지만 빈 프로퍼티 자체는 빈이 
        <emphasis>실제로 생성될 때</emphasis>까지 설정되지 않는다. 싱글톤 스코프이면서 
        미리 초기화된(기본값) 값으로 설정되는 빈은 컨테이너가 생성되면서 생성된다. 스코프가 
        <xref linkend="beans-factory-scopes"/>에 정의되지 않으면 빈은 요청되었을 때만 
        생성된다. 빈을 생성하면서 빈의 의존성과 의존성에 대한 의존성(등등)이 생성되고 할당되는 
        것과 같은 빈의 그래프를 발생시킬 가능성이 있다.</para>

      <sidebar>
        <title>순환 의존성</title>

        <para>생성자 주입을 주로 사용한다면 해결할 수 없는 순환 의존성 시나리오가 발생할 
          가능성이 있다.</para>

        <para>예를 들어 보자. 클래스 A가 생성자 주입으로 클래스 B의 인스턴스를 사용하고 
          클래스 B도 생성자 주입으로 클래스 A의 인스턴스를 사용한다. 서로 주입하는 
          클래스 A와 B의 빈을 설정하면 스프링 IoC 컨테이너는 런타임시에 이 순환 참조를 
          찾아내서 <classname>BeanCurrentlyInCreationException</classname>를 
          던진다.</para>

        <para>어떤 클래스들의 소스코드를 생성자 대신에 setter를 이용한 설정으로 변경하는 
          것이 한가지 해결책이 될 수 있다. 아니면 생성자 주입을 피하고 setter 주입만 
          사용해라. 다시 말하자면 setter 주입으로 순환 의존성을 설정할 수 있지만 별로 
          권장하는 방법은 아니다.</para>

        <para>(순환 의존성이 없는) <emphasis>전형적인</emphasis> 경우와는 다르게 빈 A와 
          빈 B 사이의 순환 의존성은 스스로 완전히 초기화될 수 있도록 하나의 빈이 다른 빈에 
          우선적으로 주입되게 강제한다.(고전적인 닭이 먼저냐 달걀이 먼저냐 이야기이다.)</para>
      </sidebar>

      <para>보통 스프링이 일을 제대로 하고 있다고 신뢰할 수 있다. 스프링은 컨테이너는 
        존재하지 않는 빈에 대한 참조나 순환 의존성같은 설정 문제를 로딩하면서 찾아낸다. 
        스프링은 빈이 실제로 사용되는 순간까지 가능한한 늦게 프로퍼티들을 설정하고 의존성을 
        해결한다. 이 말은 객체나 객체의 의존성을 생성하는 데 문제가 있다면 제대로 로딩된 스프링 
        컨테이너가 객체가 요청되었을 때 예외를 생성할 수 있다는 의미이다. 예를 들어 빈은 
        누락되거나 유효하지 않은 프로퍼티같은 예외를 던진다. <interfacename>
        ApplicationContext</interfacename>가 기본적으로 미리 초기화된 싱글톤 빈으로 
        구현된 이유는 몇몇 설정 이슈를 나중에 발견할 수 있는 가능성이 있기 때문이다. 이러한 
        빈이 실제로 필요하기 전에 생성하기 위한 시간과 메모리에 대한 비용을 들이면 설정이슈를 
        나중에 발견하는 대신에 <interfacename>ApplicationContext</interfacename>를 
        생성할 때 발견할 수 있다. 싱글톤 빈이 미리 초기화되는 대신에 지연된 초기화를 사용하도록 
        이러한 기본적인 행동을 오버라이드할 수 있다.</para>

      <para>순환 의존성이 존재하지 않다면 의존하는 빈에 하나 이상의 연관된 빈을 주입할 때 각 
        연관 빈은 의존하는 빈에 주입하기 위해 먼저 <emphasis>완전히</emphasis> 설정된다. 이는 
        빈 A가 빈 B에 의존성이 있을 때 스프링 IoC 컨테이너는 빈 A에 setter 메서드를 호출하려고 
        빈 B를 먼저 완전히 설정한다는 의미이다. 다시 말하면 빈을 먼저 인스턴스화하고(미리 
        인스턴스화되는 싱글턴이 아니라면) 빈의 의존성이 설정하고 관련 있는 라이프 사이클 
        메서드(<link linkend="beans-factory-lifecycle-initializingbean">설정된 init 
        메서드</link>나 <link linkend="beans-factory-lifecycle-initializingbean">
        InitializingBean 콜백 메서드</link> 같은)를 호출한다.</para>
    </section>

    <section id="beans-some-examples">
      <title>의존성 주입 예제</title>

      <para>다음 예제는 setter 기반의 DI를 위해 XML기반의 설정 메타데이터를 사용한다. 
        스프링 XML 설정파일에서 약간의 빈 정의를 지정했다.</para>

      <programlisting language="xml">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;

<lineannotation>&lt;!-- 중첩된 <literal>&lt;ref/&gt;</literal> 요소를 사용하는 setter 주입 --&gt;</lineannotation>
&lt;property name="beanOne"&gt;&lt;ref bean="anotherExampleBean"/&gt;&lt;/property&gt;

<lineannotation>&lt;!-- 더 세련된 'ref' 속성을 사용하는 setter 주입 --&gt;</lineannotation>
&lt;property name="beanTwo" ref="yetAnotherBean"/&gt;
&lt;property name="integerProperty" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</programlisting>

      <programlisting language="java">public class ExampleBean {

  private AnotherBean beanOne;
  private YetAnotherBean beanTwo;
  private int i;

  public void setBeanOne(AnotherBean beanOne) {
      this.beanOne = beanOne;
  }

  public void setBeanTwo(YetAnotherBean beanTwo) {
      this.beanTwo = beanTwo;
  }

  public void setIntegerProperty(int i) {
      this.i = i;
  }
}</programlisting>

      <para>앞의 예제에서 XML파일에서 명시된 프로퍼티에 대응되는 setter를 선언했다. 다음 
        예제는 생성자 기반의 DI를 사용한다.</para>

      <programlisting language="xml">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;

<lineannotation>&lt;!-- 중첩된 <literal>&lt;ref/&gt;</literal>를 사용하는 생성자 주입 --&gt;</lineannotation>
&lt;constructor-arg&gt;
  &lt;ref bean="anotherExampleBean"/&gt;
&lt;/constructor-arg&gt;

<lineannotation>&lt;!-- constructor injection using the neater 'ref' attribute --&gt;</lineannotation>
<lineannotation>&lt;!-- 더 세련된 'ref' 속성을 사용하는 생성자 주입 --&gt;</lineannotation>
&lt;constructor-arg ref="yetAnotherBean"/&gt;

&lt;constructor-arg type="int" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</programlisting>

      <programlisting language="java">public class ExampleBean {

  private AnotherBean beanOne;
  private YetAnotherBean beanTwo;
  private int i;

  public ExampleBean(
      AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
      this.beanOne = anotherBean;
      this.beanTwo = yetAnotherBean;
      this.i = i;
  }
}</programlisting>

      <para>빈 정의에 명시된 생성자 아규먼트는 <classname>ExampleBean</classname>의 
        생성자에 대한 아규먼트로 사용된다.</para>

      <para>이제 생성자 대신에 사용하는 다른 형태의 예제를 보자. 스프링은 객체의 인스턴스를 
        받으려고 <literal>static</literal> 팩토리 메서드를 호출한다.</para>

      <programlisting language="xml">&lt;bean id="exampleBean" class="examples.ExampleBean"
    factory-method="createInstance"&gt;
&lt;constructor-arg ref="anotherExampleBean"/&gt;
&lt;constructor-arg ref="yetAnotherBean"/&gt;
&lt;constructor-arg value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</programlisting>

      <programlisting language="java">public class ExampleBean {

  <lineannotation>// private 생성자</lineannotation>
  private ExampleBean(...) {
    ...
  }
  <lineannotation>
  // 정적 팩토리 메서드. 이 팩토리 메서드의 아규먼트는 아규먼트가 실제로 
  // 어떻게 사용되는가에 상관없이 리턴되는 빈의 의존성으로 간주될 수 있다.</lineannotation>
  public static ExampleBean createInstance (
          AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

      ExampleBean eb = new ExampleBean (...);
      <lineannotation>// 다른 작업들...</lineannotation>
      return eb;
  }
}</programlisting>

      <para><literal>static</literal> 팩토리 메서드의 아규먼트들은 
        <literal>&lt;constructor-arg/&gt;</literal> 요소로 제공되고 이는 생성자가 실제로 
        사용되는 것과 완전히 같다. 이 예제에서는 같은 타입이었지만 팩토리 메서드가 리턴하는 
        클래스의 타입은 <literal>static</literal> 팩토리 메서드가 담고 있는 클래스와 같은 
        타입이어야 할 필요는 없다. 인스턴스 (static이 아닌) 팩토리 메서드는 본질적으로 
        동일하므로(<literal>class</literal> 속성 대신에 <literal>factory-bean</literal> 
        속성을 사용하는 것은 제외하고) 자세한 내용을 여기서 이야기하지 않을 것이다.</para>
    </section>
  </section>

  <section id="beans-factory-properties-detailed">
    <title>의존성과 설정에 대한 자세한 내용</title>

    <para>이전 섹션에서 얘기했듯이 빈 프로퍼티와 생성자 아규먼트를 다른 곳에서 관리되는 
      빈(협력 객체)에 대한 참조나 인라인으로 정의된 값으로써 정의할 수 있다. 스프링의 XML기반의 
      설정 메타데이터는 이를 위해 <literal>&lt;property/&gt;</literal>와 
      <literal>&lt;constructor-arg/&gt;</literal> 요소내에서 서브 엘리먼트 타입을 
      지원한다.</para>

    <section id="beans-value-element">
      <title>스트레이트(Straight) 값 (프리미티브(primitive), <literal>Strings</literal> 
        등등)</title>

      <para><literal>&lt;property/&gt;</literal> 요소의 <literal>value</literal> 
        속성은 사람이 읽을 수 있는 문자열로 프로퍼티나 생성자 아규먼트를 지정한다. <link
        linkend="beans-beans-conversion">앞에서 얘기했듯이</link> 이러한 문자열 값을 
        <classname>String</classname>에서 프로퍼티나 아규먼트의 실제 타입으로 변환하기 
        위해 JavaBeans <literal>PropertyEditors</literal>를 사용한다.</para>

      <programlisting language="xml">&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;

<lineannotation>&lt;!-- <methodname>setDriverClassName(String)</methodname> 호출의 결과 --&gt;</lineannotation>
&lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt;
&lt;property name="url" value="jdbc:mysql://localhost:3306/mydb"/&gt;
&lt;property name="username" value="root"/&gt;
&lt;property name="password" value="masterkaoli"/&gt;
&lt;/bean&gt;</programlisting>

      <para>다음 예제는 훨씬 간결한 XML 설정을 위해 <link linkend="beans-p-namespace">
        p-namespace</link>를 사용한다.</para>

      <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:p="http://www.springframework.org/schema/p"
     xsi:schemaLocation="http://www.springframework.org/schema/beans
     http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;

&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"
      destroy-method="close"
      p:driverClassName="com.mysql.jdbc.Driver"
      p:url="jdbc:mysql://localhost:3306/mydb"
      p:username="root"
      p:password="masterkaoli"/&gt;

&lt;/beans&gt;

</programlisting>

      <para>앞의 XML이 훨씬 간결하다. 하지만 빈 정의를 생성할 때 프로퍼티 자동완성을 
        지원하는 <ulink url="http://www.jetbrains.com/idea/">IntelliJ IDEA</ulink>나 
        <ulink url="http://www.springsource.com/products/sts">SpringSource Tool
        Suite</ulink> (STS) 같은 IDE를 사용하지 않는다면 오타는 설계할 때가 아닌 런타임시에 
        발견된다. 이러한 IDE의 지원을 사용하는 것을 적극 추천한다.</para>

      <para>다음과 같이 <classname>java.util.Properties</classname>를 설정할 수도 
        있다.</para>

      <programlisting language="xml">&lt;bean id="mappings"
    class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;

 <lineannotation>&lt;!-- <classname>java.util.Properties</classname>처럽 입력한다 --&gt;</lineannotation>
 &lt;property name="properties"&gt;
    &lt;value&gt;
       jdbc.driver.className=com.mysql.jdbc.Driver
       jdbc.url=jdbc:mysql://localhost:3306/mydb
    &lt;/value&gt;
 &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <para>스프링 컨테이터는 <literal>&lt;value/&gt;</literal>안의 텍스트를 
        JavaBeans <interfacename>PropertyEditor</interfacename>의 메카니즘을 이용해서 
        <classname>java.util.Properties</classname> 인스턴스로 변환한다. 이는 괜찮은 
        단축키이고 스프링 팀이 <literal>value</literal> 속성 스타일보다 중첩된 
        <literal>&lt;value/&gt;</literal> 요소를 사용하기를 좋아하는 몇 안되는 곳 
        중 하나이다.</para>

      <section id="beans-idref-element">
        <title><literal>idref</literal> 요소</title>

        <para><literal>idref</literal>요소는 컨테이너 내의 다른 빈의 
          <emphasis>id</emphasis> (문자열 값 - 참조가 아니다)를 
          <literal>&lt;constructor-arg/&gt;</literal> 나
          <literal>&lt;property/&gt;</literal> 요소에 전달해서 간단히 오류를 
          검증할 수 있는(error-proof) 방법이다.</para>

        <programlisting language="xml">&lt;bean id="theTargetBean" class="..."/&gt;

&lt;bean id="theClientBean" class="..."&gt;
  &lt;property name="targetName"&gt;
      &lt;idref bean="theTargetBean" /&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

        <para>위의 빈 정의 코드는 다음 코드와 <emphasis>완전히</emphasis> 같다.(런타임에서)</para>

        <programlisting language="xml">&lt;bean id="theTargetBean" class="..." /&gt;

&lt;bean id="client" class="..."&gt;
  &lt;property name="targetName" value="theTargetBean" /&gt;
&lt;/bean&gt;</programlisting>

        <para><literal>idref</literal>를 사용하면 <emphasis>배포할 때</emphasis> 
          컨테이너가 참조되거나 이름 지어진 빈이 실제로 존재하는지 검사할 수 있기 때문에 
          두 번째 보다는 첫 번째 형식을 더 선호한다. 두 번째 형식에서 <literal>client</literal> 
          빈의 <literal>targetName</literal> 프로퍼티에 전달한 값에 대해 유효성 체크를 
          하지 않는다. <literal>client</literal> 빈이 실제로 인스턴스화 될 때만 오타를 
          발견할 수 있다.(대부분은 fatal이 발생하면서) <literal>client</literal> 빈이 
          <link linkend="beans-factory-scopes">prototype</link> 빈이라면 컨테이너를 
          배포하고 한참이 지난 후에야 오타를 발견하고 예외가 발생한다.</para>

        <para>추가적으로 참조된 빈이 같은 XML에 있고 빈의 이름이 빈 <emphasis>id</emphasis> 
          이라면 <literal> XML 파서 스스로 XML 문서가 파싱될 때 빈의 id의 유효성을 먼저 
          검사하도록 local</literal> 속성을 사용할 수 있다.</para>

        <programlisting language="xml">&lt;property name="targetName"&gt;
 <lineannotation>&lt;!-- '<literal>theTargetBean</literal>'이라는 id를 가진 빈은 반드시 존재해야 한다. 존재하지 않는다면 예외가 던져질 것이다. --&gt;</lineannotation>
 &lt;idref local="theTargetBean"/&gt;
&lt;/property&gt;</programlisting>

        <para>&lt;idref/&gt; 요소가 값을 가져오는 일반적인 위치(최소한 스프링 2.0 
          이전 버전에서는)는 <classname>ProxyFactoryBean</classname> 빈 정의안의 
          <link linkend="aop-pfb-1">AOP 인터셉터</link>의 설정이다. 인터셉터의 이름을 
          명시했을 때 &lt;idref/&gt; 요소를 사용하면 인터셉터의 id의 오타를 방지할 수 
          있다.</para>
      </section>
    </section>

    <section id="beans-ref-element">
      <title>다른 빈에 대한 참조 (협력 객체)</title>

      <para><literal>ref</literal> 요소는 <literal>&lt;constructor-arg/&gt;</literal> 나
        <literal>&lt;property/&gt;</literal> 정의 요소안의 마지막 요소이다. 이 요소에 
        컨테이너가 관리하는 다른 빈(협력 객체)을 참조하는 빈에 지정된 프로퍼티의 값을 설정한다. 
        참조된 빈은 프로퍼티의 빈의 의존성이고 프로퍼티가 설정되기 전에 필요에 따라 초기화된다. 
        (협력객체가 싱글톤 빈이라면 컨테이너가 이미 초기화했을 것이다.) 모든 참조는 결국 다른 
        객체에 대한 참조가 된다. 범위(scope)와 유효성검사는 <literal>bean,<literal>local,
        </literal></literal>, <literal>parent</literal> 속성으로 다른 빈의 id/name을 
        명시한 여부에 달려있다.</para>

      <para><literal>&lt;ref/&gt;</literal> 태그의 <literal>bean</literal> 속성으로 
        타겟 빈을 명시하는 것이 가장 일반적이고 이는 같은 XML 파일안에 존재하는지 여부에 
        관계 없이 같은 컨테이너나 부모 컨테이너의 어떤 빈에 대한 참조도 생성할 수 있다. 
        <literal>bean</literal> 속성의 값은 타겟 빈의 <literal>id</literal> 속성이나 
        타겟 빈의 <literal>name</literal> 속성의 값 중 하나와 같을 것이다.</para>

      <programlisting language="xml">&lt;ref bean="someBean"/&gt;</programlisting>

      <para><literal>local</literal> 속성으로 타겟빈을 명시하면 XML parser 기능을 사용해서 
        같은 파일안의 XML id 참조의 유효성을 검사한다. <literal>local</literal> 속성의 값은 
        타겟 빈의 <literal>id</literal> 속성과 반드시 일치해야 한다. 같은 파일에서 일치하는 
        요소를 찾지 못한다면 XML 파서는 오류가 난다. 이처럼 타겟 빈이 같은 XML 파일안에 있다면 
        local을 사용하는 것이 가장 좋은 선택이다.(가능한한 빨리 오류를 발견할 수 있도록)</para>

      <programlisting language="xml">&lt;ref local="someBean"/&gt;</programlisting>

      <para><literal>parent</literal> 속성으로 타겟 빈을 지정하면 현재 컨테이너의 부모 
        컨테이너에 있는 빈에 대한 참조를 만든다. <literal>parent</literal>의 값은 타겟 
        빈의 <literal>id</literal> 속성이나 <literal>name</literal> 속성의 값들 중 
        하나와 같아야 할 것이다. 그리고 타겟 빈은 반드시 현재 컨테이너의 부모 컨테이너에 
        존재해야 한다. 이러한 형태의 빈 참조는 컨테이너가 계층형으로 되어 있을 때나 부모 
        빈과 같은 이름의 프록시를 가지는 부모 컨테이너에 존재하는 빈을 감싸고 싶을 때 
        주로 사용한다.</para>

      <programlisting language="xml"><lineannotation>&lt;!-- 부모 컨텍스트 --&gt;</lineannotation>
&lt;bean id="accountService" class="com.foo.SimpleAccountService"&gt;
  <lineannotation>&lt;!-- 여기에 필요한 의존성을 추가한다 --&gt;</lineannotation>
&lt;/bean&gt;</programlisting>

      <programlisting language="xml"><lineannotation>&lt;!-- 자식(후손) 컨텍스트 --&gt;</lineannotation>
&lt;bean id="accountService"  <lineannotation>&lt;-- 빈 이름은 부모 빈과 같다 --&gt;</lineannotation>
    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="target"&gt;
        &lt;ref parent="accountService"/&gt;  <lineannotation>&lt;!-- 어떻게 부모 빈을 참조하는지 봐라 --&gt;</lineannotation>
    &lt;/property&gt;
  <lineannotation>&lt;!-- 여기에 필요한 다른 설정과 의존성을 추가한다 --&gt;</lineannotation>
&lt;/bean&gt;</programlisting>
    </section>

    <section id="beans-inner-beans">
      <title>이너 빈(Inner beans)</title>

      <para><literal>&lt;property/&gt;</literal> 나
        <literal>&lt;constructor-arg/&gt;</literal> 요소안에 있는 
        <literal>&lt;bean/&gt;</literal> 요소로 정의한 빈을 <firstterm>inner 
        bean</firstterm>이라고 부른다.</para>

      <programlisting language="xml">&lt;bean id="outer" class="..."&gt;
<lineannotation>&lt;!-- 타겟 빈에 대한 참조를 사용하는 대신에 간단히 타겟빈을 인라인으로 정의한다 --&gt;</lineannotation>
&lt;property name="target"&gt;
  &lt;bean class="com.example.Person"&gt; <lineannotation>&lt;!-- 이너 빈이다 --&gt;</lineannotation>
    &lt;property name="name" value="Fiona Apple"/&gt;
    &lt;property name="age" value="25"/&gt;
  &lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <para>이너 빈의 정의는 id나 name을 정의할 필요가 없어서 컨테이너는 이러한 
        값들을 무시한다. 심지어 <literal>scope</literal> 플래그도 무시한다. 
        이너 빈은 <emphasis>항상</emphasis> 익명이면서 <link
        linkend="beans-factory-scopes-prototype">prototype</link>의 범위를 
        가진다. 이너빈은 감싸진 빈외의 다른 협력 빈으로 주입하는 것을 <emphasis>
        불가능</emphasis>하다.</para>
    </section>

    <section id="beans-collection-elements">
      <title>컬렉션(Collection)</title>

      <para><literal>&lt;list/&gt;</literal>, <literal>&lt;set/&gt;</literal>, 
        <literal>&lt;map/&gt;</literal>, <literal>&lt;props/&gt;</literal> 요소에서 
        자바 <interfacename>Collection</interfacename> 타입인 <interfacename>List
        </interfacename>, <interfacename>Set</interfacename>, <interfacename>Map
        </interfacename>, <interfacename>Properties</interfacename>의 프로퍼티와 
        아규먼트를 각각 설정한다.</para>

      <programlisting language="xml">&lt;bean id="moreComplexObject" class="example.ComplexObject"&gt;
<lineannotation>&lt;!-- setAdminEmails(<classname>java.util.Properties</classname>) 호출의 결과 --&gt;</lineannotation>
&lt;property name="adminEmails"&gt;
  &lt;props&gt;
      &lt;prop key="administrator"&gt;administrator@example.org&lt;/prop&gt;
      &lt;prop key="support"&gt;support@example.org&lt;/prop&gt;
      &lt;prop key="development"&gt;development@example.org&lt;/prop&gt;
  &lt;/props&gt;
&lt;/property&gt;
<lineannotation>&lt;!-- setSomeList(<interfacename>java.util.List</interfacename>) 호출의 결과 --&gt;</lineannotation>
&lt;property name="someList"&gt;
  &lt;list&gt;
      &lt;value&gt;a list element followed by a reference&lt;/value&gt;
      &lt;ref bean="myDataSource" /&gt;
  &lt;/list&gt;
&lt;/property&gt;
<lineannotation>&lt;!-- setSomeMap(<interfacename>java.util.Map</interfacename>) 호출의 결과 --&gt;</lineannotation>
&lt;property name="someMap"&gt;
  &lt;map&gt;
      &lt;entry key="an entry" value="just some string"/&gt;
      &lt;entry key ="a ref" value-ref="myDataSource"/&gt;
  &lt;/map&gt;
&lt;/property&gt;
<lineannotation>&lt;!-- setSomeSet(java.util.Set) 호출의 결과 --&gt;</lineannotation>
&lt;property name="someSet"&gt;
  &lt;set&gt;
      &lt;value&gt;just some string&lt;/value&gt;
      &lt;ref bean="myDataSource" /&gt;
  &lt;/set&gt;
&lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <para><emphasis>map의 key나 value, set의 value의 값은 다음의 요소들 중 어떤 
        것이라도 될 수 있다.</emphasis></para>

      <programlisting language="xml">bean | ref | idref | list | set | map | props | value | null</programlisting>

      <section id="beans-collection-elements-merging">
        <title>컬렉션 병합(merging)</title>

        <para>스프링 2.0처럼 컨테이너는 컬렉션의 <emphasis>병합</emphasis>을 지원한다. 
          애플리케이션 개발자는 부모형식의 <literal>&lt;list/&gt;</literal>, 
          <literal>&lt;map/&gt;</literal>, <literal>&lt;set/&gt;</literal>, 
          <literal>&lt;props/&gt;</literal> 요소를 정의할 수 있고 부모 컬렉션을 
          상속받고 값을 오버라이드한 자식형식의 <literal>&lt;list/&gt;</literal>, 
          <literal>&lt;map/&gt;</literal>, <literal>&lt;set/&gt;</literal>, 
          <literal>&lt;props/&gt;</literal> 요소가 있을 수 있다. 자식 컬렉션의 
          값들은 부모와 자식 컬렉션의 요소를 합친 결과이고 자식의 컬렉션 요소는 부모 
          컬렉션의 값을 오버라이드한다.</para>

        <para><emphasis>병합에 대한 이번 섹션에서 부모-자식 빈의 메카니즘에 대해서 얘기한다. 부모와 
          자식 빈 정의에 익숙하지 않다면 계속 읽기 전에 <link 
          linkend="beans-child-bean-definitions">관련 섹션</link>을 읽어보기 바란다.
          </emphasis></para>

        <para>다음 예제는 컬렉션 병합을 보여준다.</para>

        <programlisting language="xml">&lt;beans&gt;
&lt;bean id="parent" abstract="true" class="example.ComplexObject"&gt;
  &lt;property name="adminEmails"&gt;
      &lt;props&gt;
          &lt;prop key="administrator"&gt;administrator@example.com&lt;/prop&gt;
          &lt;prop key="support"&gt;support@example.com&lt;/prop&gt;
      &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id="child" parent="parent"&gt;
  &lt;property name="adminEmails"&gt;
      <lineannotation>&lt;!-- 병합은 *자식* 컬렉션 정의에서 지정한다 --&gt;</lineannotation>
      &lt;props merge="true"&gt;
          &lt;prop key="sales"&gt;sales@example.com&lt;/prop&gt;
          &lt;prop key="support"&gt;support@example.co.uk&lt;/prop&gt;
      &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;
&lt;beans&gt;</programlisting>

        <para><literal>child</literal> 빈 정의에서 <literal>adminEmails</literal> 
          프로퍼티의 <literal>&lt;props/&gt;</literal> 요소에서 
          <literal>merge=true</literal> 속성을 사용했다. 컨테이너가 
          <literal>child</literal> 빈을 처리하고 인스턴스화했을 때 생성된 인스턴스는 
          부모의 <literal>adminEmails</literal> 컬렉션과 자식의 
          <literal>adminEmails</literal> 컬렉션을 합친 결과가 포함된 
          <literal>adminEmails</literal> <classname>Properties</classname> 
          컬렉션을 가진다.</para>

        <programlisting>administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk</programlisting>

        <para>자식 <classname>Properties</classname> 컬렉션의 값은 부모 
          <literal>&lt;props/&gt;</literal>의 모든 프로퍼티 요소를 상속받아 설정된다. 
          <literal>support</literal> 값에 대한 자식 컬렉션의 값은 부모 컬렉션의 값을 
          오버라이드한다.</para>

        <para>이 병합 작업은 <literal>&lt;list/&gt;</literal>, <literal>&lt;map/&gt;</literal>, 
          <literal>&lt;set/&gt;</literal> 컬렉션타입에도 비슷하게 적용된다. 
          <literal>&lt;list/&gt;</literal> 요소의 경우에서 <classname>List</classname> 
          컬렉션 타입과 결합한 의미는 유지된다. 이는 값의 <literal>ordered</literal> 컬렉션의 
          개념을 말한다. 부모의 값은 자식 리스트의 모든 값들보다 우선시된다. 
          <interfacename>Map</interfacename>, <interfacename>Set</interfacename>, 
          <interfacename>Properties</interfacename> 컬렉션 타입에서는 순서가 존재하지 않는다. 
          따라서 순서가 없다는 개념은 컨테이너가 내부적으로 사용하는 연관된 
          <interfacename>Map</interfacename>, <interfacename>Set</interfacename>, 
          <interfacename>Properties</interfacename>를 구현한 타입에 기반한 컬렉션 
          타입에서 유효하다.</para>
      </section>

      <section>
        <title>컬렉션 병합의 한계</title>

        <para>다른 켈렉션 타입은 병합할 수 없고(<interfacename>Map</interfacename> 
          <interfacename>List</interfacename>) 이러한 병합을 시도한다면 적절한 
          <classname>Exception</classname>가 던져진다. <literal>merge</literal> 
          속성은 하위에 있고 상속받는 자식 정의에서 지정되어야 한다. 부모 컬렉션 정의에서 
          <literal>merge</literal> 속성을 지정해도 사용되지 않으며 원하는 병합이 
          일어나지 않을 것이다. 병합 기능은 스프링 2.0 이후의 버전에서만 사용할 
          수 있다.</para>
      </section>

      <section id="beans-collection-elements-strongly-typed">
        <title>강타입(Strongly-typed)의 컬렉션(Java 5+에서만 사용 가능)</title>
 
        <para>자바 5 이상에서 강타입(strongly typed)의 컬렉션을 사용할 수 있다.(제너릭 
          타입을 사용해서) 예를 들면 <classname>String</classname> 엘리먼트만 이루어진 
          <interfacename>Collection</interfacename> 타입을 선언할 수 있다. 스프링으로 
          빈에 강타입의 <interfacename>Collection</interfacename>을 의존성-주입한다면 
          스프링의 타입변환 지원의 이점을 얻을 수 있다. 스프링의 타입변환은 강타입의 
          <interfacename>Collection</interfacename> 인스턴스의 엘리먼트를 
          <interfacename>Collection</interfacename>에 추가하기 전에 적절한 
          타입으로 변환한다.</para>

        <programlisting language="java">public class Foo {

  private Map&lt;String, Float&gt; accounts;

  public void setAccounts(Map&lt;String, Float&gt; accounts) {
      this.accounts = accounts;
  }
}</programlisting>

        <programlisting language="xml">&lt;beans&gt;
  &lt;bean id="foo" class="x.y.Foo"&gt;
      &lt;property name="accounts"&gt;
          &lt;map&gt;
              &lt;entry key="one" value="9.99"/&gt;
              &lt;entry key="two" value="2.75"/&gt;
              &lt;entry key="six" value="3.99"/&gt;
          &lt;/map&gt;
      &lt;/property&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</programlisting>

        <para><literal>foo</literal> 빈의 <literal>accounts</literal> 프로퍼티가 
          주입을 위한 준비되었을 때 강타입의 <classname>Map&lt;String, Float&gt;
          </classname> 엘리먼트 타입에 대한 제너릭 정보는 리플렉션(reflection)으로 
          사용할 수 있다. 그러므로 스프링의 타입변환 인프라는 강한 값인 
          <literal>9.99, 2.75</literal>, <literal>3.99</literal>이 실제 
          <classname>Float</classname> 타입으로 변환되는 것처럼 다양한 값 요소를 
          인지할 수 있다.</para>
      </section>
    </section>

    <section id="beans-null-element">
      <title>Null과 비어있는 문자열 값</title>

      <para><!--Clarify difference between null value and empty string value?-->스프링은 
        프로퍼티에 대한 비어있는 아규먼트를 비어있는 <literal>Strings</literal>처럼 다룬다. 
        다음 XML 기반 설정 메타데이터 코드는 email 프로퍼티에 비어있는 
        <classname>String</classname> 값 ("")을 설정한다.</para>

      <programlisting language="xml">&lt;bean class="ExampleBean"&gt;
&lt;property name="email" value=""/&gt;
&lt;/bean&gt;</programlisting>

      <para>앞의 예제는 다음 자바코드 <methodname>exampleBean.setEmail("")</methodname> 
        와 같다. <literal>&lt;null/&gt;</literal> 요소는 <literal>null</literal> 값을 
        다룬다. 예를 들면 다음과 같다.</para>

      <programlisting language="xml">&lt;bean class="ExampleBean"&gt;
&lt;property name="email"&gt;&lt;null/&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <para>위의 설정은 다음 자바코드 <methodname>exampleBean.setEmail(null)</methodname>
        와 같다.</para>
    </section>

    <section id="beans-p-namespace">
      <title>p-namespace를 사용하는 XML 단축키(shortcut)</title>

      <para>p-namespace는 프로퍼티 값과 협력 객체를 나타내기 위해 중첩된 
        <literal>&lt;property/&gt;</literal> 요소 대신 <literal>bean</literal> 
        요소의 속성을 사용 가능케 한다.</para>

      <para>스프링 2.0부터는 XML 스키마 정의에 기반해서 <link linkend="xsd-config">
        네임스페이스를 사용하는</link> 확장가능한 설정형식을 지원한다. 이번 챕터에서 얘기할 
        <literal>beans</literal> 설정 형식은 XML 스키나 문서에 정의한다. 하지만 
        p-namespace는 XSD 파일에 정의하지 않고 스프링 코어에만 존재한다.</para>

      <para>다음 예제는 같은 결과를 처리하는 두 가지 XML 코드를 보여준다. 첫 번째는 표준 
        XML형식을 사용하고 두 번째는 p-namespace를 사용한다.</para>

      <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:p="http://www.springframework.org/schema/p"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;

  &lt;bean name="classic" class="com.example.ExampleBean"&gt;
      &lt;property name="email" value="foo@bar.com"/&gt;
  &lt;/bean&gt;

  &lt;bean name="p-namespace" class="com.example.ExampleBean"
        p:email="foo@bar.com"/&gt;
&lt;/beans&gt;</programlisting>

      <para>이 예제는 빈 정의에서 email이라고 부르는 p-namespace의 속성을 보여준다. 이는 
        스프링이 프로퍼티 선언을 포함하도록 한다. 앞에서 언급했듯이 p-namespace는 스키마 
        정의가 없으므로 프로퍼티 이름에 속성의 이름을 설정할 수 있다.</para>

      <para>다음 예제는 다른 빈에 대한 참조를 가진 두 개 이상의 빈 정의를 포함한다.</para>

      <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:p="http://www.springframework.org/schema/p"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;

  &lt;bean name="john-classic" class="com.example.Person"&gt;
      &lt;property name="name" value="John Doe"/&gt;
      &lt;property name="spouse" ref="jane"/&gt;
  &lt;/bean&gt;

  &lt;bean name="john-modern"
      class="com.example.Person"
      p:name="John Doe"
      p:spouse-ref="jane"/&gt;

  &lt;bean name="jane" class="com.example.Person"&gt;
      &lt;property name="name" value="Jane Doe"/&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</programlisting>

      <para>여기서 보듯이 이 예제는 p-namespace를 사용한 프로퍼티 값을 포함하고 있을 뿐 
        아니라 프로퍼티 참조를 선언하는 특별한 형식을 사용한다. 첫 번째 빈 정의가 
        <literal>john</literal> 빈에서 <literal>jane</literal> 빈으로의 참조를 
        생성하는 <literal>&lt;property name="spouse" ref="jane"/&gt;</literal>를 
        사용하지만 두번찌 빈 정의는 완전히 같은 일을 하는 속성으로 
        <literal>p:spouse-ref="jane"</literal>를 사용한다. 이 경우에 
        <literal>spouse</literal>는 프로퍼티 이름이지만 <literal>-ref</literal>부분은 
        직접적인 값이 아니라 다른 빈에 대한 참조라는 것을 나타낸다.</para>

      <note>
        <para>p-namespace는 표준 XML 형식처럼 유연하지는 않다. 예를 들어 프로퍼티 참조를 
          선언하는 형식은 <literal>Ref</literal>로 끝나는 프로퍼티와 충돌이 나지만 표준 
          XML은 충돌나지 않는다. 동시에 세가지 방법을 사용하는 XML 문서가 생기는 문제를 피하기 
          위해 어떤 방법을 사용할지 신중하게 선택하고 이에 대해서 팀 멤버들과 협의하기를 
          추천한다.<!--Clarify ref to all three approaches.I see two, XML and namespace.--></para>
      </note>
    </section>
    
   	<section id="beans-c-namespace">
      <title>c-namespace를 사용하는 XML 단축키(shortcut)</title>
      
      <para><xref linkend="beans-p-namespace"/>와 스프링 3.1에 도입된 
        <emphasis>c-namespace</emphasis>는 생성자 아규먼트 설정을 위해서 
        중첩된 <literal>constructor-arg</literal> 요소 대신에 인라인 속성을 
        사용할 수 있게 한다.</para>
      
      <para><literal>c</literal> 네임스페이스를 사용하는 <xref linkend="beans-constructor-injection"/>의 예제를 보자.</para>
      
      <programlisting language="java">&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:c="http://www.springframework.org/schema/c"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
      
  &lt;bean id="bar" class="x.y.Bar"/&gt;
  &lt;bean id="baz" class="x.y.Baz"/&gt;

  &lt;-- 'traditional' declaration --&gt;      
  &lt;bean id="foo" class="x.y.Foo"&gt;
      &lt;constructor-arg ref="bar"/&gt;
      &lt;constructor-arg ref="baz"/&gt;
      &lt;constructor-arg value="foo@bar.com"/&gt;
  &lt;/bean&gt;

  &lt;-- 'c-namespace' declaration --&gt;
  &lt;bean id="foo" class="x.y.Foo" c:bar-ref="bar" c:baz-ref="baz" c:email="foo@bar.com"&gt;

&lt;/beans&gt;</programlisting>

    <para>생성자 아규먼트를 그 이름으로 설정하기 위해서 <literal>c:</literal> 네임스페이스는 
    <literal>p:</literal> 네임스페이스와 같은 관례를 사용한다.(빈 참조에는 
    <literal>-ref</literal>가 뒤에 붙는다.) 그리고 마찬가지로 XSD 스키마에 정의되어 있지 
    않더라도(스프링 코어 안에 존재한다.) 선언될 필요가 있다.</para>
	  
    <para>생성자 아규먼트 이름을 이용할 수 없는 드문 경우(보통 바이트코드가 디버깅 정보 없이 컴파일된다면)에는 아규먼트 인덱스를 대신 폴백(fallback)으로 사용한다.</para>

      <programlisting language="java">&lt;-- 'c-namespace' 인덱스 선언 --&gt;
&lt;bean id="foo" class="x.y.Foo" c:_0-ref="bar" c:_1-ref="baz"&gt;</programlisting>

      <note>XML 문법때문에 인덱스 노테이션은 <emphasis>_</emphasis>로 시작해야 한다. XML 속성의 이름은 숫자로 시작할 수 없다.(IDE가 이를 허락한다고 하더라도)</note>
      
    <para>실제로 생성자 결정 <link linkend="beans-factory-ctor-arguments-resolution">메카니즘</link>은 실제로 필요한 것 없이도 적합한 아규먼트를 꽤 잘 찾아내기 때문에 설정 전체에 이름 노테이션을 사용하기를 추천한다.</para>
    </section>

    <section id="beans-compound-property-names">
      <title>프로퍼티 이름 혼합</title>

      <para>빈 프로퍼티를 설정할 때 마지막 프로퍼티 이름을 제외한 경로의 모든 컴퍼넌트가 
        <literal>null</literal>이 아니라면 혼합된 프로퍼티 이름이나 중첩된 프로퍼티 
        이름을 사용할 수 있다. 다음 빈 정의를 보자.</para>

      <programlisting language="xml">&lt;bean id="foo" class="foo.Bar"&gt;
&lt;property name="fred.bob.sammy" value="123" /&gt;
&lt;/bean&gt;</programlisting>

      <para><literal>foo</literal> 빈에는 <literal>fred</literal> 프로퍼티가 있다. 
        <literal>fred</literal> 프로퍼티에는 <literal>bob</literal> 프로퍼티가 있고 
        <literal>bob</literal> 프로퍼티에는 <literal>sammy</literal> 프로퍼티가 있다. 
        마지막 <literal>sammy</literal> 프로터티에는 <literal>123</literal> 이라는 값이 
        설정된다. 이것이 동작하게 하려면 <literal>foo</literal>의 <literal>fred</literal> 
        프로퍼티와 <literal>fred</literal>의 <literal>bob</literal> 프로퍼티가 빈이 
        생성된 후에 반드시 <literal>null</literal>이 아니어야 한다. 그렇지 않으면 
        <exceptionname>NullPointerException</exceptionname> 예외가 던져진다.</para>
    </section>
  </section>

  <section id="beans-factory-dependson">
    <title><literal>depends-on</literal>의 사용</title>

    <para>빈이 다른 빈의 의존성이 있다면 보통 빈은 다른 빈의 프로퍼티로 설정된다는 것을 
      의미한다. 일반적으로 이는 XML 기반의 설정 메타데이터에서 
      <link linkend="beans-ref-element"><literal>&lt;ref/&gt;</literal> 요소</link>로 
      설정한다. 하지만 종종 빈들 사이의 의존성은 직접적이지 않을 수 있다. 예를 들어 데이터베이스 
      드라이버 등록같은 클래스의 정적 초기화(static initializer)는 실행될 필요가 있다. 
      <literal>depends-on</literal> 속성은 <literal>&lt;ref/&gt;</literal> 요소로 
      빈을 초기화하기 전에 명시적으로 하나 이상의 빈을 강제적으로 초기화한다. 다음 예제는 
      하나의 빈의 의존성을 나타내려고 <literal>depends-on</literal> 속성을 사용한다.</para>

    <programlisting language="xml">&lt;bean id="beanOne" class="ExampleBean" depends-on="<emphasis role="bold">manager</emphasis>"/&gt;

&lt;bean id="<emphasis role="bold">manager</emphasis>" class="ManagerBean" /&gt;</programlisting>

    <para>여러 빈의 의존성을 나타내려면 <literal>depends-on</literal> 속성의 값에 콤마, 
      공백, 세미콜론을 구분자로 사용해서 빈 이름의 리스트를 지정한다.</para>

    <programlisting language="xml">&lt;bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao"&gt;
&lt;property name="manager" ref="manager" /&gt;
&lt;/bean&gt;

&lt;bean id="manager" class="ManagerBean" /&gt;
&lt;bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" /&gt;</programlisting>

    <note>
      <para>빈 정의의 <literal>depends-on</literal> 속성은 초기화할 때의 의존성과 
        대응되는 소멸될 때의 의존성을 모두 지정할 수 있다. 소멸될 때의 의존성은 
        <link linkend="beans-factory-scopes-singleton">싱글톤</link> 빈에서만 
        가능하다. 주어진 빈으로 <literal>depends-on</literal>의 관계를 정의한 의존하는 
        빈이 주어진 빈 자체가 소멸되는 것보다 먼저 소멸된다. 그래서 
        <literal>depends-on</literal>는 셧다운하는 순서를 제어할 수도 있다.</para>
    </note>
  </section>

  <section id="beans-factory-lazy-init">
    <title>지연 초기화(Lazy-initialized)되는 
      빈<!--Changed to lazy-initialized from lazily instantiated because attribute is lazy-init, and there was a lot of inconsistency. --></title>

    <para>기본적으로 <interfacename>ApplicationContext</interfacename> 구현체는 
      초기화 과정에서 모든 <link linkend="beans-factory-scopes-singleton">싱글톤</link> 
      빈을 열심히 생성하고 설정한다. 보통 이러한 미리 인스턴스화하는 과정은 설정이나 주변 환경의 오류를 
      즉시 발견할 수 있기 때문에 몇 시간 혹은 며칠 뒤에 발견하는 것보다 바람직하다. 이 미리 
      인스턴스화하는 동작이 바람직하지 <emphasis>않다면</emphasis> 빈 정의를 지연초기화로 
      표시함으로써 싱글톤 빈의 미리 인스턴스화하는 행동을 막을 수 있다. 지연 초기화되는 빈은 
      IoC 컨테이너가 시작할 때가 아닌 빈 인스턴스가 최초로 요청되었을 때 생성하도록 한다.<!--Above, clarify what you mean by eagerly. Note, I've trimmed this section for conciseness, but info is still here.--></para>

    <para>예를 들면 XML에서 <literal>&lt;bean/&gt;</literal> 요소의 
      <literal>lazy-init</literal> 속성으로 지연 초기화를 제어한다.</para>

    <programlisting language="xml">&lt;bean id="lazy" class="com.foo.ExpensiveToCreateBean" <emphasis role="bold">lazy-init="true"</emphasis>/&gt;

&lt;bean name="not.lazy" class="com.foo.AnotherBean"/&gt;</programlisting>

    <para><interfacename>ApplicationContext</interfacename>가 앞의 설정을 
      사용할 때 <literal>lazy</literal>라고 이름 붙은 빈은 
      <interfacename>ApplicationContext</interfacename>이 시작할 때 미리 인스턴스화하지 
      않는다. 반면에 <literal>not.lazy</literal>빈은 미리 인스턴스화된다.</para>

    <para>하지만 지연 초기화되는 빈이 지연 초기화되지 <emphasis>않는</emphasis> 
      싱글톤 빈의 의존성이라면 싱글톤 빈의 의존성을 반드시 만족시켜야 하기 때문에 
      <interfacename>ApplicationContext</interfacename>는 지연 초기화되는 빈을 
      시작하면서 생성한다. 지연 초기화되는 빈은 지연 초기화되지 않는 다른 싱글톤 
      빈에 주입된다.</para>

    <para><literal>&lt;beans/&gt;</literal> 요소의 <literal>default-lazy-init</literal> 
      속성을 사용해서 컨테이너 레벨에서 지연 초기화를 제어할 수도 있다. 예를 들면 다음과 같다.</para>

    <programlisting language="xml">&lt;beans default-lazy-init="true"&gt;
  <lineannotation>&lt;!-- 어떤 빈도 미리 인스턴스화되지 않는다... --&gt;</lineannotation>
&lt;/beans&gt;</programlisting>
  </section>

  <section id="beans-factory-autowire">
    <title>협력객체의 자동연결(Autowiring)</title>

    <!--I've moved around info and done a lot of editing/reformatting in this section, but nothing is missing.-->

    <para>스프링 컨테이너는 협력 빈들 사이의 관계를 <emphasis>자동연결(autowire)</emphasis>
      할 수 있다. 스프링이 <interfacename>ApplicationContext</interfacename>의 내용을 
      검사해서 빈에 대한 협력 객체(다른 빈들)를 자동으로 처리하도록 할 수 있다. 
      자동연결(Autowiring)은 다음과 같은 장점이 있다.</para>
    
    <para><itemizedlist>
      <listitem>
        <para>자동연결(Autowiring)은 프로퍼티나 생성자 아규먼트를 지정하는 일을 현저하게 
          줄일 수 있다. (이 점에 관해서 <link linkend="beans-child-bean-definitions">
          이 챕터의 다른 부분에서 얘기 할</link> 빈 템플릿(bean template)같은 다른 
          메카니즘도 역시 유용하다.)</para>
      </listitem>

      <listitem>
        <para>자동연결(Autowiring)은 객체의 발전처럼 설정을 수정할 수 있다. 예를 들어 
          클래스에 의존성을 추가해야 한다면 의존성은 설정을 수정할 필요없이 자동으로 만족될 
          수 있다. 그러므로 자동연결은 개발할 때 특히 유용하다. 코드베이스가 더 안정적이 
          되었을 때 명시적으로 연결하기 위해 옵션을 변경할 필요가 없다.</para>
      </listitem>
      </itemizedlist> XML 기반의 설정 메타데이터를 사용할 때<footnote>
      <para><xref linkend="beans-factory-collaborators"/>를 참고해라.</para>
      </footnote>, <literal>&lt;bean/&gt;</literal> 요소의 <literal>autowire</literal> 
      속성으로 빈 정의에 대한 autowire 모드를 지정한다. 자동연결(autowiring) 기능에는 
      5 가지 모드가 있다. 빈 <emphasis>마다</emphasis> 자동연결을 지정하기 때문에 
      자동연결할 빈을 선택할 수 있다.</para>

    <table id="beans-factory-autowiring-modes-tbl">
      <title>자동연결 모드</title>

      <tgroup cols="2">
        <colspec colname="c1" colwidth="1*"/>

        <colspec colname="c2" colwidth="5*"/>

        <thead>
          <row>
            <entry>모드</entry>

            <entry>설명</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>no</entry>

            <entry><para>(기본값) 자동연결하지 않는다. 빈 참조는 반드시 
              <literal>ref</literal> 요소로 정의되어야 한다. 협력객체들을 명시적으로 
              지정하면 더 많은 제어와 투명성을 제공하기 때문에 더 큰 배포를 위해 기본설정을 
              변경하는 것은 권하지 않는다. 어떤 면에서 이는 시스템 구조의 
              문서화이다.</para></entry>
          </row>

          <row>
            <entry>byName</entry>

            <entry><para>프로퍼티 이름에 의한 자동연결(Autowiring). 스프링은 자동 연결이 
              필요한 프로퍼티와 같은 이름의 빈을 찾는다. 예를 들어 빈 정의가 이름에 의한 
              자동연결로 설정되어있고 <emphasis>master</emphasis> 프로퍼티가 있다면
              (<emphasis>setMaster(..)</emphasis> 메서드가 있다는 의미이다.) 스프링은 
              <literal>master</literal>라는 이름의 빈 정의를 찾아서 프로퍼티를 설정하는 데 
              사용한다.</para></entry>
          </row>

          <row>
            <entry>byType</entry>

            <entry><para>컨테이너 내에서 프로퍼티 타입과 정확히 일치하는 하나의 빈이 있다면 
              프로퍼티를 자동연결한다. 하나 이상의 빈이 존재한다면 해당 빈에 대해서는 
              <emphasis>byType</emphasis> 자동연결을 사용하지 말아야 한다는 것을 말해주는 
              fatal 예외가 던져진다. 일치하는 빈이 하나도 없다면 아무 일도 일어나지 않는다. 
              프로퍼티를 설정되지 않는다.</para></entry>
          </row>

          <row>
            <entry>constructor</entry>

            <entry><para><emphasis>byType</emphasis>과 유사하지만 생성자 아규먼트에 
              적용된다. 컨테이너 내에서 생성자 아규먼트의 타입과 정확히 일치하는 빈이 없다면 
              fatal 오류가 발생한다.</para></entry>
          </row>

        </tbody>
      </tgroup>
    </table>

    <para><emphasis>byType</emphasis> 자동연결 모드나 <emphasis>constructor</emphasis> 
      자동연결 모드를 사용해서 배열이나 타입이 있는 컬렉션을 연결할 수 있다. 이러한 경우에 컨테이너 
      내에서 타입이 일치할 것으로 기대되는 <emphasis>모든</emphasis> 자동연결 후보들은 의존성을 
      만족하기 위해 제공된다. 기대하는 키 타입이 <classname>String</classname>이라면 강타입의 
      맵과 자동연결할 수 있다. 자동연결된 맵의 값들은 일치하기를 기대하는 타입의 모든 빈 인스턴스로 
      이루어질 것이고 맵의 키들에는 대응되는 빈의 이름이 담겨있다.</para>

    <para>자동 연결이 수행된 후에 자동연결과 의존성 확인을 합칠 수 있다.</para>

    <section id="beans-autowired-exceptions">
      <title>자동연결의 한계와 단점들</title>

      <para>자동연결은 프로젝트 전체적으로 사용할 때 최상으로 잘 동작한다. 자동연결을 일반적으로 
        사용하지 않는다면 한두 개의 빈 정의만을 연결하려고 자동연결을 사용하는 개발자에게 
        혼동을 줄 것이다.</para>

      <para>자동연결의 한계와 단점들을 보자.</para>

      <itemizedlist>
        <listitem>
          <para><literal>property</literal>와 <literal>constructor-arg</literal> 
            설정의 명시적인 의존성은 항상 자동연결을 오버라이드한다. 프리미티브 타입, 
            <classname>Strings</classname>, <classname>Classes</classname> 같은 
            소위 <emphasis>간단한</emphasis> 프로퍼티들(간단한 프로퍼티의 배열도 포함)은 
            자동연결할 수 없다. 이 한계는 의도적인 디자인이다.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>자동연결은 명시적인 연결보다는 정확하지 않다. 앞에서 본 표처럼 스프링은 
            기대하지 않을 결과가 일어날 수도 있는 애매모호한 경우에 추측하는 것을 피하기 
            위해 조심하지만 스프링이 관리하는 객체사이의 관계는 더이상 명백하게 문서화되지 
            않는다.</para>
        </listitem>

        <listitem>
          <para>연결 정보는 스프링 컨테이너에서
            문서를 생성하는 것 같은 도구에서는 이용할 수 없을 것이다.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>컨테이너 내에서 다수의 빈 정의들은 자동연결되는 setter 메서드나 생성자 
            아규먼트로 지정된 타입과 일치하는 것을 찾아낼 것이다. 배열, 컬렉션, 맵에 대해서 
            이는 필연적인 문제는 아니다. 하지만 단일 값을 기대하는 의존성에 대해서 이 
            애매모호함은 임의로 처리되지 않는다. 유일한 빈 정의를 이용할 수 없다면 
            예외가 던져진다.</para>
        </listitem>
      </itemizedlist>

      <para>후자의 경우에 여러 가지 선택사항이 있다.</para>

      <itemizedlist>
        <listitem>
          <para>명백한 연결을 사용하고 자동연결을 사용하지 않는다.</para>
        </listitem>

        <listitem>
          <para>다음 섹션에서 설명할 <literal>autowire-candidate</literal> 속성에 
            <literal>false</literal>를 설정해서 빈 정의의 자동연결을 피한다.</para>
        </listitem>

        <listitem>
          <para><literal>&lt;bean/&gt;</literal> 요소의 
            <literal>primary</literal> 속성을 <literal>true</literal>로 
            설정함으로써 단일 빈 정의를 <emphasis>주요한</emphasis> 후보로 
            지정한다.</para>
        </listitem>

        <listitem>
          <para>자바 5 이상의 버전을 사용한다면 
            <xref linkend="beans-annotation-config"/>에서 설명했듯이 어노테이션 
            기반의 설정으로 더 포괄적인 제어를 구현한다.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="beans-factory-autowire-candidate">
      <title>자동연결에서 빈 제외하기</title>

      <para>per-bean 원리에 따라 자동연결에서 빈을 제외할 수 있다. 스프링 XML 형식에서 
        <literal>&lt;bean/&gt;</literal> 요소의 <literal>autowire-candidate</literal> 
        속성을 <literal>false</literal>로 설정한다. 컨테이너는 자동연결 인프라(<link 
        linkend="beans-autowired-annotation"><interfacename>@Autowired</interfacename>
        </link>같은 어노테이션 설정을 포함해서)가 지정한 빈 정의를 이용할 수 없게 한다.</para>

      <para>빈 이름에 대한 패턴매칭에 기반해서 자동연결의 후보를 제한할 수도 있다. 최상위 
        레벨의 <literal>&lt;beans/&gt;</literal> 요소는 
        <literal>default-autowire-candidates</literal> 속성으로 하나 이상의 패턴을 
        갖는다. 예를 들어 <emphasis>Repository</emphasis>로 끝나는 이름을 가진 빈을 
        자동연결 후보에서 제외하려면 *Repository라는 값을 지정한다. 여러 패턴을 지정하려면 
        콤마로 구분한 리스트로 정의한다. 빈 정의에서 <literal>autowire-candidate</literal> 
        속성을 <literal>true</literal>나 <literal>false</literal>로 명시적으로 지정하면 
        항상 우선시되고 패턴패칭 규칙이 적용되지 않는다.</para>

      <para>이러한 기법들은 자동연결로 다른 빈에 주입하면 안되는 빈에 유용한다. 이는 
        제외된 빈이 스스로 자동연결을 사용해서 설정할 수 없다는 것을 의미하지는 않는다. 
        더 적절히 말하면 빈 자신은 다른 빈에 자동연결하기 위한 후보가 아니다.</para>

      <!--Last paragraph unclear to me. Is my edit ok? Revise as necessary.-->
    </section>
  </section>

  <section id="beans-factory-method-injection">
    <title>메서드 주입</title>

    <para>대부분의 어플리케이션 시나리오에서 컨테이너 내의 대부분의 빈은 <link
      linkend="beans-factory-scopes-singleton">싱글톤</link>이다. 싱글톤 빈이 다른 
      싱글톤 빈과 협력해야 하거나 싱글톤이 아닌 빈이 싱글톤이 아닌 다른 빈과 협력해야 할 때 
      보통 빈은 다른 빈의 프로퍼티로 정의해서 의존성을 다룬다. 빈의 라이프 사이클이 다를 때 
      한가지 문제점이 생긴다. 싱글톤 빈 A가 싱글톤이 아닌(프로토타입) 빈 B를 사용해야 한다고 
      가정해 보자. 아마 각 메서듣 호출은 A에서 발생한다. 컨테이너는 싱글톤 빈 A를 딱 한번만 
      생성하므로 프로퍼티를 설정할 기회도 딱 한번만 있다. 컨테이너는 빈 B가 필요할 때마다 빈 
      B의 새로운 인스턴스를 가진 빈 A를 제공할 수 없다.</para>

    <para>해결책은 제어의 역전(inversion of control)보다 선행하는 것이다. 
      <interfacename>ApplicationContextAware</interfacename> 인터페이스를 구현하거나 
      빈 A가 빈 B를 필요로 할 때마다 컨테이너가 빈 B의 인스턴스(보통은 new)를 요청하도록 
      <link linkend="beans-factory-client">getBean("B")을 호출하게 만듦으로써</link> 
      <link linkend="beans-factory-aware">빈 A가 컨테이너를 인지하도록</link> 할 수 
      있다. 다음은 이러한 방법의 예이다.</para>

    <programlisting language="java"><lineannotation>// 어떤 프로세싱을 수행하기 위해 상태가 있는 커맨드 스타일의 클래스를 사용하는 클래스</lineannotation>
package fiona.apple;

<lineannotation>// 스프링 API 임포트</lineannotation>
import org.springframework.beans.BeansException;
import org.springframework.context.Applicationcontext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

 private ApplicationContext applicationContext;

 public Object process(Map commandState) {
    <lineannotation>// 적절한 <interfacename>Command</interfacename>의 새로운 인스턴스를 붙잡는다</lineannotation>
    Command command = createCommand();
    <lineannotation>// (원컨대 완전히 새로운) <interfacename>Command</interfacename> 인스턴스에 상태를 설정한다</lineannotation>
    command.setState(commandState);
    return command.execute();
 }

 protected Command createCommand() {
    <lineannotation>// 스프링 API 의존성에 주의해라!</lineannotation>
    return this.applicationContext.getBean("command", Command.class);
 }

 public void setApplicationContext(ApplicationContext applicationContext)
                                                                  throws BeansException {
    this.applicationContext = applicationContext;
 }
}</programlisting>

    <para>앞의 예제는 비즈니스 코드가 스프링 프레임워크를 인지하고 있고 결합되어 있기 때문에 
      바람직하지 않다. 스프링 IoC 컨테이너에서 약간 고급 기능 중 하나인 메서드 주입은 깔끔한 
      방법으로 이러한 유즈케이스를 다룰 수 
      있다.<!--Why give an example that is not desirable? Unclear whether this is an illustration of true method injection.--></para>

    <sidebar>
      <para><ulink url="http://blog.springsource.com/2004/08/06/method-injection/"
        >이 블로그 글</ulink>에서 메서드 주입을 만든 동기에 대해서 더 자세히 읽을 수 있다.</para>
    </sidebar>

    <section id="beans-factory-lookup-method-injection">
      <title>메서드 주입 검색</title>

      <!--Deleted a box here that doesn't seem to have much info; I moved the blog entry link above. -->

      <para>메서드 주입 검색은 컨테이너에서 또 다른 이름있는 빈에 대해 검색 결과를 리턴하도록 
        컨테이너가 <emphasis>컨테이너가 관리하는 빈의</emphasis>메서드를 오버라이드한다. 
        이전 섹션에서 설명한 시나리오처럼 검색은 보통 프로토타입 빈과 관계된다. 스프링 프레임워크는 
        메서드를 오버라이드 하는 서브클래스를 동적으로 생성하기 위해 CGLIB 라이브러리에서 
        바이트코드 생성을 사용해서 이 메서드 주입을 
        구현한다.<!--Note was plain text; I made it a note and moved it up.--></para>

      <note>
        <para>이 동적으로 서브클래스를 만드는 작업을 하려면 클래스패스에 CGLIB jar파일을 
          두어야 한다. 스프링 프레임워크가 서브클래스를 생성하는 클래스는 
          <literal>final</literal>이 될 수 없고 오버라이드 되는 메서드도 
          <literal>final</literal>이 될 수 없다. 또한 <literal>abstract</literal> 
          메서드가 있는 클래스를 테스트하려면 개발자가 직접 클래스의 서브클래스를 만들고 
          <literal>abstract</literal> 메서드의 스텁(stub) 구현을 제공해야 한다. 마지막으로 
          메서드 주입의 타겟이 되는 객체들은 직렬화 될 수 없다.</para>
      </note>

      <para>이전 코드 예제에서 <classname>CommandManager</classname> 클래스를 보면 
        스프링 컨테이너가 <methodname>createCommand()</methodname> 메서드의 구현을 
        동적으로 오버라이드한다는 것을 알 수 있다. 수정한 예제에서 볼 수 있듯이 
        <classname>CommandManager</classname> 클래스는 스프링에 대한 어떤 의존성도 
        갖지 않을 것이다. </para>

      <programlisting language="java">package fiona.apple;

<lineannotation>// 더는 스프링을 임포트하지 않는다! </lineannotation>

public abstract class CommandManager {

 public Object process(Object commandState) {
    <lineannotation>// 적절한 <interfacename>Command</interfacename>의 새로운 인스턴스르 붙잡는다</lineannotation>
    Command command = createCommand();
    <lineannotation>// (원컨대 완전히 새로운) <interfacename>Command</interfacename> 인스턴스에 상태를 설정한다</lineannotation>
    command.setState(commandState);
    return command.execute();
 }

  <lineannotation>// 괜찮지만... 이 메서드의 구현은 어디에 있는가?</lineannotation>
 protected abstract Command createCommand();
}</programlisting>

      <para>주입되는 메서드가 있는는 클라이언트 클래스에서(이 경우에는 
        <classname>CommandManager</classname>) 주입되는 메서드는 다음과 같은 형식의 
        시그니처여야 한다.</para>

      <programlisting language="xml">&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(<lineannotation>no-arguments</lineannotation>);</programlisting>

      <para>메서드가 <literal>abstract</literal>이라면 동적으로 생성된 서브클래스가 메서드를 
        구현한다. <literal>abstract</literal>가 아니라면 동적으로 생성된 서브클래스는 원래의 
        클래스에서 정의된 구현 메서드를 오버라이드한다. 예를 들면 다음과 같다.</para>

      <programlisting language="xml"><lineannotation>&lt;!-- 상태가 있는 빈은 프로포타입으로 배포된다. (싱글톤이 아닙) --&gt;</lineannotation>
&lt;bean id="command" class="fiona.apple.AsyncCommand" scope="prototype"&gt;
<lineannotation>&lt;!-- 여기에 주입하는 의존성을 필요한만큼 적는다 --&gt;</lineannotation>
&lt;/bean&gt;

<lineannotation>&lt;!-- <literal>commandProcessor</literal>는 <literal>statefulCommandHelper</literal>를 사용한다 --&gt;</lineannotation>
&lt;bean id="commandManager" class="fiona.apple.CommandManager"&gt;
&lt;lookup-method name="createCommand" bean="command"/&gt;
&lt;/bean&gt;</programlisting>

      <para>이 빈은 <emphasis>command</emphasis>빈의 새로운 인스턴스가 필요할 때마다 
        자신의 <methodname>createCommand()</methodname> 메서드를 호출하는 
        <emphasis>commandManager</emphasis>이다. <literal>command</literal> 빈이 
        실제로 필요하다면 프로토타입으로 배포해야 한다. <literal>command</literal> 빈이 
        <link linkend="beans-factory-scopes-singleton">싱글톤</link>으로 배포된다면 
        <literal>command</literal> 빈은 항상 같은 인스턴스가 리턴될 것이다.</para>

      <tip>
        <para>호기심 많은 독자라면 <classname>ServiceLocatorFactoryBean</classname> 
          (<literal>org.springframework.beans.factory.config</literal> 패키지에 있다)가 
          사용된다는 것을 찾아낼 것이다. ServiceLocatorFactoryBean에서 사용한 접근은 다른 
          유틸리티 클래스인 <classname>ObjectFactoryCreatingFactoryBean</classname>에서 
          사용한 접근과 유사하다. 하지만 ServiceLocatorFactoryBean는 스프링에 특화된 검색 
          인터페이스와는 반대되는 자신만의 검색 인터페이스를 지정할 수 있다. 이 클래스들에 대해서는 
          자바독을 참고하고 ServiceLocatorFactoryBean에 대한 추가적인 정보는 이 <ulink
          url="http://blog.arendsen.net/index.php/2006/10/05/on-the-servicelocatorfactorybean-dlas-and-the-sustainability-of-code-and-design/"
          >블로그 글</ulink>을 참고해라.</para>
      </tip>
    </section>

    <section id="beans-factory-arbitrary-method-replacement">
      <title>임의의 메서드 교체</title>

      <para>검색 메서드 주입보다 덜 유용한 메서드 주입의 형태는 관리하는 빈에서 임의의 
        메서드를 다른 메서드 구현으로 교체하는 것이다. 사용자들은 이 기능이 필요할 때까지 
        이 섹션의 남은 부분은 읽지 않아도 
        좋다.<!--Delete this section? See preceding sentence.--></para>

      <para>XML 기반의 설정 메타데이터에서 배포된 빈에 대해 이미 존재하는 메서드 구현을 
        다른 메서드로 교체하기 위해 <literal>replaced-method</literal> 요소를 사용할 수 
        있다. 다음 클래스와 오버라이드 할 computeValue 메서드를 보자.</para>

      <programlisting language="java">public class MyValueCalculator {

public String computeValue(String input) {
  <lineannotation>// 다른 실제 코드...</lineannotation>
}

<lineannotation>// 다른 메서드들...</lineannotation>

}</programlisting>

      <para><interfacename>org.springframework.beans.factory.support.MethodReplacer</interfacename>
        를 구현한 클래스는 새로운 메서드 정의를 제공한다.</para>

      <programlisting language="java"><lineannotation>/** <classname>MyValueCalculator</classname>에 존재하는 <methodname>computeValue(String)</methodname> 구현을 
  오버라이드하는데 사용된다는 것을 의미한다.
*/</lineannotation>
public class ReplacementComputeValue implements MethodReplacer {

  public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
      <lineannotation>// 입력값을 가져오고 작업을 수행하고 계산된 결과를 돌려준다</lineannotation>
      String input = (String) args[0];
      ...
      return ...;
  }
}</programlisting>

      <para>원래의 클래스를 배포하고 메서드 오버라이드를 지정하는 빈 정의는 다음과 
        같을 것이다.</para>

      <programlisting language="xml">&lt;bean id="myValueCalculator" class="x.y.z.MyValueCalculator"&gt;

<lineannotation>&lt;!-- 임의의 메서드 교체 --&gt;</lineannotation>
&lt;replaced-method name="computeValue" replacer="replacementComputeValue"&gt;
  &lt;arg-type&gt;String&lt;/arg-type&gt;
&lt;/replaced-method&gt;
&lt;/bean&gt;

&lt;bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/&gt;</programlisting>

      <para>오버라이드 되는 메서드의 메서드 시그니처를 가리키는 
        <literal>&lt;replaced-method/&gt;</literal> 요소내에서 다수의 
        <literal>&lt;arg-type/&gt;</literal> 요소를 사용할 수 있다. 아규먼트에 대한 
        시그니처는 메서드가 오버라이드 되고 클래스에 다수의 변수수가 존재할 때만 필요하다. 
        간편하게 아규먼트에 대한 스트링 타입은 완전히 정규화된 타입이름의 일부만 적어도 된다. 
        예를 들어 다음은 모든 <classname>java.lang.String</classname>과 매치된다.</para>

      <programlisting language="java">    java.lang.String
  String
  Str</programlisting>

      <para>대게 아규먼트의 수는 선택가능한 범위내에서 구별하기에 충분하기 때문에 이 
        단축키는 아규먼트의 타입과 매치되는 가장 짧은 문자열만 입력함으로써 타이핑의 양을 
        줄일 수 있다.</para>
    </section>
  </section>
</section>
