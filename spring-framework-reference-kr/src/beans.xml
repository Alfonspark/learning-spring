<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="beans">
  <title>IoC 컨테이너</title>

  <section id="beans-introduction">
    <title>Spring IoC 컨테이너와 빈즈(beans)의 도입</title>

    <para>이번 챕터는 제어의 역전 (IoC) <footnote><para>
      <xref linkend="background-ioc"/> 참고.</para></footnote> 원리에 대한 스프링 
      프레임워크의 구현체에 대해 설명한다. IoC는 <emphasis>의존성 주입</emphasis> (DI)
      으로도 알려다. 이는 객체가 함께 동작해야 하는 의존성을 정의하는 처리 과정이다. IoC는 
      생성자 아규먼트나 팩토리 메서드의 아규먼트 또는 객체 인스턴스 후에 설정된 프로퍼티나 팩토리 
      메서드에서 리턴받은 값으로 정의한다. 그다음 컨테이너는 빈이 생성될 때 의존성을 
      <emphasis>주입</emphasis>한다. 이 처리 과정은 빈 스스로 인스턴스화 하는 과정을 
      제어하거나 직접 클래스의 생성자를 사용해서 의존성을 정의하거나 또는 
      <emphasis>서비스 로케이터</emphasis> 패턴 같은 메니즘과 근본적으로 정반대이므로 
      <emphasis>제어의 역전</emphasis> (IoC)이라고 이름 붙였다.</para>

    <!--I copied and pasted preceding from "Injecting Dependencies" to give background on IoC, since that's what chapter is about.
The footnote should x-ref to first section in that chapter but I can't find the file. The current xref doesn't work.-->

    <para><literal>org.springframework.beans</literal>와 
      <literal>org.springframework.context</literal> 패키지는 스프링 프레임워크 IoC 
      컨테이너의 기반이다. <interfacename><ulink
      url="http://static.springframework.org/spring/docs/3.0.x/javadoc-api/org/springframework/beans/factory/BeanFactory.html"
      >BeanFactory</ulink></interfacename> 인터페이스는 어떤 타입의 객체도 다룰 수 있는 
      향상된 설정 메카니즘을 제공한다. <literal><ulink
      url="http://static.springframework.org/spring/docs/3.0.x/javadoc-api/org/springframework/context/ApplicationContext.html"
      >Applicatio커nContext</ulink></literal>는 <interfacename>BeanFactory</interfacename>의 
      서브 인터페이스다. ApplicationContext는 스프링의 AOP기능, 메시지 리소스 핸들링
      (국제화(i18n)를 사용하려고), 이벤트 발생, 웹 어플리케이션의 <interfacename>
      WebApplicationContext</interfacename>같은 어플리케이션 계층에서 지정한 컨텍스트와 
      더 쉽게 통합할 수 있게 한다.</para>

    <para>간단히 말하면 <interfacename>BeanFactory</interfacename>는 설정 프레임워크와 
      기본적인 기능을 제공하고 <interfacename>ApplicationContext</interfacename>는 
      에 엔터프라이즈급에 가까운 기능을 추가한다. <interfacename>ApplicationContext
      </interfacename>는 <interfacename>BeanFactory</interfacename>의 슈퍼셋이고 
      이 챕터에서는 전적으로 스프링 IoC 컨테이너를 설명하는 데만 사용한다.
      <!--API spec says ApplicationContext is a subinterface of BeanFactory, so is it right to call it a superset?--><classname>ApplicationContext</classname> 대신 
      <classname>BeanFactory</classname>를 사용하는 방법에 대해 더 자세한 내용을 알고 
      싶다면 <xref linkend="beans-beanfactory"/>를 참고해라.</para>

    <para>스프링에서 어플리케이션의 중추가 되고 스프링 IoC <firstterm>컨테이너</firstterm>가
      관리하는 객체를 <firstterm>빈(bean)</firstterm>이라고 부른다. 빈은 인스턴스화 되고 
      결집한 객체로 스프링 IoC 컨테이너가 관리한다. 빈은 어플리케이션에서 수많은 객체 중 
      하나일 뿐이다. 컨테이너가 사용한 <firstterm>설정 메타데이터</firstterm>는 빈과 
      빈 사이의 <firstterm>의존성</firstterm>에 반영된다.</para>
  </section>

  <section id="beans-basics">
    <title>컨테이너 개요</title>
    
    <para><classname>org.springframework.context.ApplicationContext</classname>
      인터페이스는 스프링 IoC 컨테이너를 나타내며 앞에서 언급한 빈을 인스턴스화하고 설정하고 
      조합하는 데 책임이 있다. 컨테이너는 어떤 객체를 인스턴스로 만들고 설정하고 조합해야 하는지를 
      설정 메타데이터에서 알아낸다. 설정 메타데이터는 XML이나 자바 어노테이션, 자바 코드로 
      나타낸다. 설정 메타데이터는 어플리케이션을 구성하는 객체들을 나타내고 그러한 객체들 사이의 
      풍부한 상호 의존성을 나타낸다.</para>
    
    <para><classname>ApplicationContext</classname> 인터페이스의 다양한 구현체는 
      스프링 밖에서 제공된다. 단독 어플리케이션에서는 일반적으로 <ulink
      url="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html"
      ><classname>ClassPathXmlApplicationContext</classname></ulink>나 <ulink
      url="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html"
      ><classname>FileSystemXmlApplicationContext</classname></ulink>의 인스턴스를 
      생성한다.
      <!-- MLP: Beverly to review --> XML이 설정 메타데이터를 정의하는 보편적인 포맷이 
      되었지만, 자바 어노테이션이나 메타데이터 형식의 코드로 컨테이너에 설정을 알려줄 수 있다. 
      이러한 추가적인 메타데이터 포맷을 선언적으로 지원하도록 하는 소량의 XML 설정만 제공하면 
      된다.</para>
    
    <para>대부분의 어플리케이션 시나리오에서 스프링 IoC 컨테이너의 인스턴스를 만드는 명시적인 
      사용자 코드는 필요하지 않다. 예를 들어 웹 어플리케이션 시나리오에서 어플리케이션의 
      <literal>web.xml</literal>에서 8줄 정도의 J2EE 웹 디스크립터 XML만으로도 보통 
      충분할 것이다.(<xref linkend="context-create"/> 참고) 이클립스 기반의 개발환경인 
      <ulink url="http://www.springsource.com/produts/sts">SpringSource Tool 
      Suite</ulink>나 <ulink url="http://www.springsource.org/roo">Spring Roo</ulink>를 
      사용한다면 이러한 설정은 몇 번의 마우스 클릭이나 키보드 입력만으로도 생성할 수 있다.</para>
    
    <para>다음 다이어그은 스프링이 어떻게 어떻게 동작하는지 보여준다. 어플리케이션의 
      클래스들은 설정 메타 데이터와 결합한다. 그래서 <classname>ApplicationContext
      </classname>이 생성되고 인스턴스화 되면 완전히 설정이 완료되고 실행가능한 시스템이나 
      어플리케이션이 준비된다.</para>

    <para><mediaobject>
      <imageobject>
        <imagedata align="center" fileref="images/container-magic.png"
          format="PNG"/>
      </imageobject>

      <caption><para>Spring IoC 컨테이너</para></caption>
      </mediaobject></para>

    <section id="beans-factory-metadata">
      <title>설정 메타데이터(Configuration metadata)</title>

      <para>앞의 다이어그램에서 봤듯이 스프링 IoC 컨테이너는 <emphasis>설정 메타데이터
        </emphasis> 형식을 받아들인다. 이 설정 메타데이터를 통해 어플리케이션 개발자는 
        스프링 컨테이너가 어플리케이션의 객체를 어떻게 인스턴스화하고 설정하고 조합해야 
        하는지 지시할 수 있다.</para>

      <para>설정 메타데이터는 전통적으로 간단하고 직관적인 XML 포맷을 사용한다. 이 
        챕터에서도 스프링 IoC 컨테이너의 핵심 개념과 기능을 설명하기 위해서 XML을 사용한다.</para>

      <note>
        <para>XML기반의 메타데이터는 설정 메타데이터를 위한 유일한 형식이 <emphasis>아니다.
          </emphasis> 스프링 IoC 컨테이너 자체도 실제 작성된 설정 메타데이터의 형식과 
          <emphasis>완전히</emphasis> 분리되어 있다.</para>
      </note>

      <para>스프링 컨테이너에 다른 형식의 메타데이터를 사용하는 방법에 대해서는 다음을 
        참고해라.</para>

      <itemizedlist>
        <listitem>
          <para><link linkend="beans-annotation-config">Annotation-based
            configuration</link>: 스프링 2.5에서 도입된 어노테이션 기반의 설정 
            메타데이터 지원.</para>
        </listitem>

        <listitem>
          <para><link linkend="beans-java">Java-based configuration</link>:
            스프링 3.0을 시작하면서 <ulink url="http://www.springsource.org/javaconfig">
            Spring JavaConfig 프로젝트</ulink>의 많은 기능이 스프링 프레임워크의 
            핵심부분이 되었다. 그러므로 XML파일 대신에 자바로 어플리케이션 클래스에 대한 
            빈을 외부에서 정의할 수 있다. 이 기능을 사용하려면 <interfacename>
            @Configuration</interfacename>, <interfacename>@Bean</interfacename>, 
            <interfacename>@Import</interfacename>, <interfacename>@DependsOn
            </interfacename> 봐라.</para>
        </listitem>
      </itemizedlist>

      <para>스프링의 설정은 컨테이너가 반드시 관리해야 하는 최소한 하나 이상의 빈 정의로 
        이루어진다. XML기반의 설정 메타데이터는 최상위 <literal>&lt;beans/&gt;</literal> 
        엘리먼트 안에 <literal>&lt;bean/&gt;</literal> 엘리먼트로 이러한 빈을 
        설정한다.</para>

      <para>이러한 빈 정의들은 어플리케이션을 구성하는 실제 객체들과 대응된다. 일반적으로 
        서비스계층 객체, 데이터 접근 객체(DAO), Struts <interfacename>Action
        </interfacename> 인스턴스같은 프리젠테이션 객체, Hibernate <interfacename>
        SessionFactories</interfacename>같은 인프라스트럭처 객체, JMS 
        <interfacename>Queues</interfacename>등을 정의한다. 보통 이는 보통 도메인 
        객체를 생성하고 로드하는 DAO와 비즈니스 로직에 대한 책임이 있기 때문에 컨테이너에서 
        세분화된 도메인 객체를 설정하지 않는다. 하지만 IoC 컨테이너의 제어범위 밖에서 생성된 
        객체를 설정하기 위해 AspectJ를 스프링과 통합할 수 있다.
        <link linkend="aop-atconfigurable">Using AspectJ to dependency-inject 
        domain objects with Spring</link>를 참고해라.</para>

      <para>다음 예제는 XML기반의 설정데이터의 기본구조를 보여준다.</para>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;

  &lt;bean id="..." class="..."&gt;
    &lt;!-- collaborators and configuration for this bean go here --&gt;
  &lt;/bean&gt;

  &lt;bean id="..." class="..."&gt;
    &lt;!-- collaborators and configuration for this bean go here --&gt;
  &lt;/bean&gt;

  &lt;!-- more bean definitions go here --&gt;

&lt;/beans&gt;</programlisting>

      <para><literal>id</literal> 속성은 개별 빈 정의를 구분하기 위해 사용하는 문자열이다. 
        <literal>class</literal> 속성은 빈의 타입을 정의하고 정규화된(fully qualified) 
        클래스 명을 사용한다. id 속성의 값은 협력 객체를 참조한다. 협력 객체를 참조하는 
        XML은 이 예제에 없다. 더 자세한 정보는 <link 
        linkend="beans-dependencies">Dependencies</link>를 참고해라.</para>
    </section>

    <section id="beans-factory-instantiation">
      <title>컨테이너의 인스턴스화</title>

      <para>스프링 IoC 컨테이너의 인스턴스화는 이해하기 쉽다. 
        <interfacename>ApplicationContext</interfacename> 생성자에 제공한 위치 경로는 
        사실 리소스에 대한 문자열이다. 컨테이너는 이 경로로 로컬파일 시스템 같은 다양한 
        외부리소스나 자바 <literal>CLASSPATH</literal> 등에서 설정 메타데이터를 로드한다.</para>

      <programlisting language="java">ApplicationContext context =
    new ClassPathXmlApplicationContext(new String[] {"services.xml", "daos.xml"});</programlisting>

      <note>
        <para>스프링의 IoC 컨테이너를 공부하고 나면 <xref linkend="resources"/>에서 
          설명하는 스프링의 <interfacename>Resource</interfacename>에 대해서 
          궁금해질 것이다. <interfacename>Resource</interfacename>는 URI 문법으로 
          정의된 위치에서 입스트림을 읽는 편리한 메니즘을 제공한다. 특히, 
          <classname>Resource</classname> 경로는 <xref linkend="resources-app-ctx"/>에서 
          설명하는 어플리케이션 컨텐스트를 구성하는 데 사용한다.</para>
      </note>

      <para>다음 예제는 서비스 계층 객체 <literal>(services.xml)</literal>의 
        설정파일이다.</para>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;

  &lt;!-- 서비 --&gt;

  &lt;bean id="petStore"
        class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl"&gt;
    &lt;property name="accountDao" ref="accountDao"/&gt;
    &lt;property name="itemDao" ref="itemDao"/&gt;
    &lt;!-- 이 빈에 대한 추가적인 협력 객체나 설정은 여기에 작성한다 --&gt;
  &lt;/bean&gt;

  &lt;!-- 서비스에 대한 추가적인 빈 정의는 여기에 작성한다 --&gt;

&lt;/beans&gt;
</programlisting>

      <para>다음 예제는 데이터 접근 객체인 <literal>daos.xml</literal> 파일이다.</para>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;

  &lt;bean id="accountDao"
      class="org.springframework.samples.jpetstore.dao.ibatis.SqlMapAccountDao"&gt;
    &lt;!-- 이 빈에 대한 추가적인 협력 객체나 설정은 여기에 작성한다 --&gt;
  &lt;/bean&gt;

  &lt;bean id="itemDao" class="org.springframework.samples.jpetstore.dao.ibatis.SqlMapItemDao"&gt;
    &lt;!-- 이 빈에 대한 추가적인 협력 객체나 설정은 여기에 작성한다 --&gt;
  &lt;/bean&gt;

  &lt;!-- 데이터 접근 객체에 대한 추가적인 빈 정의는 여기에 작성한다 --&gt;

&lt;/beans&gt;</programlisting>
      
      <para>앞의 예제에서 서비스계층은 <classname>PetStoreServiceImpl</classname> 
        클래스로 이루어져 있고 <classname>SqlMapAccountDao</classname>와 SqlMapItemDao 
        타입의 두 데이터 접근 객체들은 <ulink url="http://ibatis.apache.org/">iBatis</ulink> 
        객체/관계 매핑(Object/Relational mapping) 프레임워크에 기반을 둔다. <literal>property
        name</literal> 요소는 JavaBean 프로퍼티의 이름을 참조한다. <literal>ref</literal> 
        요소는 또 다른 빈 정의의 이름을 참조한다. id와 ref 요소의 결합은 협력 객체들 
        사이의 의존성을 나타낸다. 객체의 의존성을 설정하는 방법에 대한 자세한 내용은 
        <link linkend="beans-dependencies">Dependencies</link>를 참고해라.</para>

      <section id="beans-factory-xml-import">
        <title>XML기반의 설정 메타데이터 구성</title>

        <para>빈 정의를 여러 XML 파일에 하는 것은 유용할 수 있다. 때때로 개별 XML 설정파일은 
          아키텍처상의 논리적인 계층이나 모듈을 나타낸다.</para>

        <para>어플리케이션 컨텍스트 생성자를 이러한 XML 파일들로부터 빈 정의를 
          로드하는데 사용할 수 있다. 이 생성자는 이전 섹션에서 보여준 것처럼 여러 
          <interfacename>Resource</interfacename>의 위치를 받을 수 있다. 아니면 
          하나 이상의 <literal>&lt;import/&gt;</literal> 요소를 사용해서 다른 파일의 
          빈 정의를 로드할 수 있다. 예를 들면 다음과 같다.</para>

        <programlisting language="xml">&lt;beans&gt;

    &lt;import resource="services.xml"/&gt;
    &lt;import resource="resources/messageSource.xml"/&gt;
    &lt;import resource="/resources/themeSource.xml"/&gt;

    &lt;bean id="bean1" class="..."/&gt;
    &lt;bean id="bean2" class="..."/&gt;

&lt;/beans&gt;</programlisting>

        <para>앞의 예제에서는 <literal>services.xml</literal>,
          <literal>messageSource.xml</literal>, <literal>themeSource.xml</literal>
          의 3개 파일에서 외부 빈 정의를 로드했다. 모든 위치 경로는 임포트하는 파일의 
          상대경로이므로 <literal>services.xml</literal>는 반드시 같은 디렉터리에 
          있거나 같은 클래스패스 경로에 있어야 한다. 그리고 <literal>messageSource.xml
          </literal>와 <literal>themeSource.xml</literal>는 임포트하는 파일 하위에 
          <literal>resources</literal> 위치에 있어야 한다. 이 예제에서 보듯이 맨 앞의 
          슬래시(/)는 무시되고 경로는 상대경로가 되므로 맨 앞에 슬래시를 사용하지 않는 것이 
          더 좋은 형식이다. 임포트된 파일의 내용은 최상위에 <literal>&lt;beans/&gt;</literal>가 
          있는 스프링 스키마나 DTD를 따르는 유효한 XML 빈 정의여야 한다.</para>

        <note>
          <para>"../"를 사용해서 부모 디렉터리의 파일을 참조하는 것도 가능하지만 
            별로 권하지 않는다. 부모 디렉터리를 참조하면 현재 어플리케이션 밖에 있는 파일에 
            대한 의존성을 만든다. 특히 이러한 참조는 "가장 가까운" 클래스패스 루트를 선택하고 
            루트의 부모 디렉터리를 검색하는 런타임 처리인 "classpath:" URL(예를 들면 
            "classpath:../services.xml")에서는 
            사용하지 말아야 한다. 클래스패스 설정을 변경하면 다른 디렉리나 잘못된 
            디렉터리를 선택할 수 있다.</para>

          <para>항상 상대경로 대신 정규화된(fully qualified) 리소스 경로를 사용할 수 있다. 
            예를 들면 "file:C:/config/services.xml"나 "classpath:/config/services.xml"와 
            같은 형식이다. 하지만 절대경로를 사용하면 어플리케이션 설정이 특정 절대경로에 
            대한 깊은 결합도가 생긴다는 것을 알아야 한다. 보통 이러한 절대 경로를 우회하는 
            방법을 더 선호한다. 예를 들면 "${...}" 플레이스홀더를 사용해서 런타임시에 
            JVM 시스템 프로퍼티로 교체한다.</para>
        </note>
      </section>
    </section>

    <section id="beans-factory-client">
      <title>컨테이너의 사용</title>

      <para><interfacename>ApplicationContext</interfacename>는 여러 빈의 등록과 
        빈의 의존성을 유지하는 향상된 팩토리 기능을 제공하는 인터페이스다. <methodname>T
        getBean(Stringname, Class&lt;T&gt; requiredType)</methodname> 메서드를 
        사용하면 빈의 인스턴스를 얻을 수 있다.</para>

      <para><interfacename>ApplicationContext</interfacename>는 다음과 같이 빈 정의를 
        읽고 빈에 접근할 수 있게 한다.</para>

      <programlisting language="java">// 생성과 설정 빈
ApplicationContext context =
    new ClassPathXmlApplicationContext(new String[] {"services.xml", "daos.xml"});

// 설정된 인스턴스 획득
PetStoreServiceImpl service = context.getBean("petStore", PetStoreServiceImpl.class);

// 설정된 인스턴스 사용
List userList service.getUsernameList();
</programlisting>

      <para><methodname>getBean()</methodname>를 사용해서 빈의 인스턴스를 얻는다. 
        <interfacename>ApplicationContext</interfacename> 인터페이스에는 빈을 
        얻어오는 몇 가지 메서드가 더 있지만, 이상적으로는 어플리케이션 코드는 이러한 메서드를 
        사용하지 말아야 한다. 사실 어플리케이션 코드는 <methodname>getBean()</methodname> 
        메서드를 전혀 호출하지 말아야 한다. 그래서 스프링 API에 대한 의존성을 전혀 갖지 
        말아야 한다. 예를 들어 웹 프레임워크에 대한 스프링의 통합은 컨트롤러와 JSF로 관리되는 
        빈처럼 여러 가지 웹 프레임워크 클래스에 대한 의존성 주입을 제공한다.</para>
    </section>
  </section>

  <section id="beans-definition">
    <title>빈(Bean) 개요</title>
    
    <para>스프링 IoC 컨테이너는 하나 이상의 <emphasis>beans</emphasis>을 관리한다. 
      이러한 빈은 XML <literal>&lt;bean/&gt;</literal> 정의 같은 컨테이너에 제공한 
      설정 메타데이터로 생성된다.</para>

    <para>컨테이너 내부에서 이러한 빈 정의는 <interfacename>BeanDefinition</interfacename> 
      객체로 나타나고 이 객체는 (다른 정보들과 함께) 다음의 메타데이터를 포함하고 있다.</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>패키지에 최적화된(package-qualified) 클래스 명:</emphasis> 보통 정의된 빈의 
          실제 구현클래스이다.</para>
      </listitem>

      <listitem>
        <para>빈의 행동에 대한 설정 요소들. 컨테이너에서 빈이 어떻게 동작해야 하는가에 대한 
          상태.(범위, 라이프사이클 콜백 등등)</para>
      </listitem>

      <listitem>
        <para>빈이 동작하는 데 필요한 다른 빈들에 대한 참조. 이러한 참조들을 
          <emphasis>협력객체(collaborators)</emphasis>나 
          <emphasis>의존성(dependencies)</emphasis>이라고 부른다.</para>
      </listitem>

      <listitem>
        <para>새로 생성된 객체에 설정해야 하는 그 외 설정값. 예를 들면 커넥션 풀을 관리하는 
          빈에서 사용해야 하는 커넥션의 수나 풀의 용량제한 등이다.</para>
      </listitem>
    </itemizedlist>

    <para>이 메타데이터는 각 빈 정의를 구성하는 프로퍼티 세트로 변환된다.</para>

    <table id="beans-factory-bean-definition-tbl">
      <title>빈 정의</title>

      <tgroup cols="2">
        <colspec colname="c1" colwidth="2*"/>

        <colspec colname="c2" colwidth="4*"/>

        <thead>
          <row>
            <entry>프로프티</entry>

            <entry>설명한 곳</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>class</entry>

            <entry><para> <xref linkend="beans-factory-class"/> </para></entry>
          </row>

          <row>
            <entry>name</entry>

            <entry><para> <xref linkend="beans-beanname"/> </para></entry>
          </row>

          <row>
            <entry>scope</entry>

            <entry><para> <xref linkend="beans-factory-scopes"/> </para></entry>
          </row>

          <row>
            <entry>constructor arguments</entry>

            <entry><para> <xref linkend="beans-factory-collaborators"/>
              </para></entry>
          </row>

          <row>
            <entry>properties</entry>

            <entry><para> <xref linkend="beans-factory-collaborators"/>
              </para></entry>
          </row>

          <row>
            <entry>autowiring mode</entry>

            <entry><para> <xref linkend="beans-factory-autowire"/>
              </para></entry>
          </row>

          <row>
            <entry>lazy-initialization mode</entry>

            <entry><para> <xref linkend="beans-factory-lazy-init"/>
              </para></entry>
          </row>

          <row>
            <entry>initialization method</entry>

            <entry><para> <xref
              linkend="beans-factory-lifecycle-initializingbean"/>
              </para></entry>
          </row>

          <row>
            <entry>destruction method</entry>

            <entry><para> <xref linkend="beans-factory-lifecycle-disposablebean"
              /> </para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>어떻게 특정 빈을 생성하는가에 대한 정보를 담고 있는 빈 정의에 대해 추가로 
      <interfacename>ApplicationContext</interfacename> 구현체도 사용자가 컨테이너 
      밖에서 생성해서 이미 존재하는 객체들을 등록할 수 있다. <methodname>getBeanFactory()
      </methodname> 메서드로 어플리케이션 컨텍스트의 BeanFactory에 접근해서 이러한 객체들을 
      등록한다. <methodname>getBeanFactory()</methodname> 메서드는 BeanFactory를 구현한 
      <classname>DefaultListableBeanFactory</classname>를 리턴한다. 
      <classname>DefaultListableBeanFactory</classname>는 
      <methodname>registerSingleton(..)</methodname>와
      <methodname>registerBeanDefinition(..)</methodname> 메서드로 이러한 등록을 지원한다. 
      하지만 일반적인 어플리케이션은 메타데이터 빈 정의에서 정의된 빈으로만 동작한다.</para>

    <section id="beans-beanname">
      <title>빈 이름짓기</title>

      <para>모든 빈에는 하나 이상의 식별자가 있다. 이러한 식별자는 빈을 제공하는 컨테이너 
        내에서 반드시 유일해야 한다. 보통 빈에는 단 하나의 식별자가 있지만 하나 이상이 필요하다면 
        추가적인 식별자로 별칭(alias)을 생각해 볼 수 있다.</para>

      <para>XML기반의 설정 메타데이터에서 <literal>id</literal>나 <literal>name</literal> 
        속성으로 빈의 식별자를 명시한다. <literal>id</literal> 속성으로 정확하게 하나의 id를 
        지정할 수 있다. 관례적으로 이 이름은 문자와 숫자로 작성하지만 ('myBean', 'fooService' 등등) 
        특수문자도 사용할 수 있다. 빈에 별도의 별칭을 사용하고 싶다면 <literal>name</literal> 
        속성으로 지정하면 되고 여러 개를 입력할 때는 콤마(<literal>,</literal>)나 세미콜론
        (<literal>;</literal>)이나 공백으로 구분한다. 변경사항 문서를 보면 스프링 3.1 이전의 
        버전에서는 <literal>id</literal> 속성을 사용할 수 있는 문자를 제한하기 위해 
        <literal>xsd:ID</literal>로 사용했다. 스프링 3.1에서는 <literal>xsd:string
        </literal>을 사용한다. XML 파서를 사용하지 않더라도 여전히 컨테이너가 빈 아이디가 유일해야 
        한다는 조건을 강제한다.</para>

      <para>빈에 id나 name을 반드시 제공해야 하는 것은 아니다. id나 name을 명시하지 않는다면 
        컨테이너는 빈에 유일한 이름을 부여한다. 하지만 <literal>ref</literal> 요소나 
        <link lang="" linkend="beans-servicelocator">Service Locator</link> 스타일의 
        검색을 사용해서 빈을 이름으로 참조하고 싶다면 이름을 반드시 지정해야 한다. name을 
        지정하지 않는 이유는 <link linkend="beans-inner-beans">내부 빈</link>
        과 <link linkend="beans-factory-autowire">협력객체 오토와이어링</link>를 
        사용하는 것과 연관이 있다.</para>

      <sidebar>
        <title>빈 작명 관례</title>
        
        <para>빈에 이름을 지을 때는 인스턴스의 필드 이름에 대한 표준 자바 관례를 사용한다. 
          즉, 빈 이름은 소문자로 시작하고 카멜케이스를 사용한다. 예를 들어 
          <literal>'accountManager'</literal>, <literal>'accountService'</literal>, 
          <literal>'userDao'</literal>, <literal>'loginController'</literal>
          등이 된다.(홑따옴표는 생략한다)</para>

        <para>빈의 이름을 일관성 있게 지으면 설정을 읽기 쉽고 이해하기 쉽다. 스프링 AOP를 
          사용한다면 이름과 관련된 빈의 세트에 어드바이스(advice)를 적용할 때 큰 도움이 
          된다.</para>
      </sidebar>

      <section id="beans-beanname-alias">
        <title>외부에서 정의된 빈의 별칭짓기</title>

        <para>빈 정의에서 <literal>id</literal> 속성에서 명시한 이름과 조합하거나 
          <literal>name</literal> 속성에 여러 이름을 작성해서 빈에 하나 이상의 이름을 
          작성할 수 있다. 이러한 이름들은 같은 빈에 대한 별칭이다. 별칭은 
          컴포넌트 자체에 명시한 빈 이름을 사용해서 공통 의존성을 참조하는 각각의 컴포넌트를 
          어플리케이션에서 사용하는 상황 등에서 유용하다.</para>
        
        <para>빈이 실제로 정의된 곳에 모든 별칭을 명시하는 것이 항상 적절한 것은 아니다. 
          때로는 다른 곳에서 정의된 빈에 대해서 별칭을 지정하는 것이 적절한 때도 있다. 이는 
          설정이 자신만의 객체 정의의 세트가 있는 여러 서브시스템에 분리된 대형 
          시스템에서 일반적이다. XML 기반의 설정 메타데이터에서 외부에서 정의된 빈에 
          별칭을 부여하기 위해 <literal>&lt;alias/&gt;</literal>를 사용할 수 있다.</para>

        <programlisting language="xml">&lt;alias name="fromName" alias="toName"/&gt;</programlisting>
        
        <para>이 예제의 설정을 사용하면 같은 컨테이너에서 <literal>fromName</literal>라는 
          이름의 빈을 <literal>toName</literal>로도 참조할 수 있다.</para>

        <!-- MLP: Beverly to review -->

        <para>예를 들어 서브시스템 A의 설정 메타데이터는 'subsystemA-dataSource'라는 이름으로 
          DataSource를 참조한다. 서브시스템 B의 설정 메타데이터는 'subsystemB-dataSource'
          라는 이름으로 DataSource를 참조한다. 이 두 서브시스템을 사용해서 메인 어플리케이션을 
          구성했을 때 메인 어플리케이션은 'myApp-dataSource'라는 이름으로 DataSource를 
          참조한다. 이 3가지 이름이 같은 객체를 참조하게 하려면 MyAPP 설정 메타데이터에 다음의 
          별칭 정의를 추가해야 한다.</para>

        <programlisting language="xml">&lt;alias name="subsystemA-dataSource" alias="subsystemB-dataSource"/&gt;
&lt;alias name="subsystemA-dataSource" alias="myApp-dataSource" /&gt;</programlisting>
        
        <para>이제 각 컴포넌트와 메인 어플리케이션은 유일하면서 다른 어떤 정의와도 
          충돌하지 않는다는 보장을 받은 이름을 통해 데이터소스를 참조할 수 있다. 
          물론 같은 빈을 참조한다.</para>
      </section>
    </section>

    <section id="beans-factory-class">
      <title>빈의 인스턴스화</title>
      
      <para>본질적으로 빈 정의는 하나 이상의 객체를 생성하는 방법이다. 컨테이너는 요청이 
        발생했을 때 이름있는 빈에 대한 방법을 검색하고 실제 객체를 생성하는(또는 획득하는)
        빈 정의로 은닉화된 설정 메타데이터를 사용한다.</para>
      
      <para>XML기반의 설정 메타데이터를 사용하면 <literal>&lt;bean/&gt;</literal> 요소의 
        <literal>class</literal> 속성에서 인스턴스화 된 객체의 타입(또는 클래스)를 명시한다. 
        이 <literal>class</literal> 속성은 내부적으로는 <interfacename>BeanDefinition
        </interfacename> 인스턴스의 <classname>Class</classname> 프로퍼티다. 
        <literal>class</literal> 속성은 강제적이다. (예외적인 상황은 <xref
        linkend="beans-factory-class-instance-factory-method"/>와 <xref
        linkend="beans-child-bean-definitions"/>를 참고해라.) 두 가지 방법의 하나로 
        <classname>Class</classname> 프로퍼티를 사용한다. <itemizedlist>
        <listitem>
          <para>보통은 컨테이너 스스로 빈의 생성자를 리플렉트하게 호출함으로써 직접 빈을 
            생성하는 경우에 생성되는 빈의 클래스를 명시한다. 약간은 <code>new</code> 
            오퍼레이터를 사용하는 자바 코드와 비슷하다.</para>
        </listitem>
        </itemizedlist></para>

      <itemizedlist>
        <listitem>
          <para>객체를 생성하기 위해 호출될 <literal>static</literal> 팩토리 메서드가 
            있는 실제 클래스를 명시한다. 컨테이너가 빈을 생성하려고 클래스에서 
            <literal>static</literal>, <emphasis>factory</emphasis> 메서드를 
            호출하는 경우는 일반적이지는 않다. <literal>static</literal> 팩토리 메서드의 
            호출에서 리턴받은 객체의 타입은 같은 클래스나 다른 클래스와 완전히 같을 것이다.</para>
        </listitem>
      </itemizedlist>

      <sidebar>
        <title>내부 클래스명</title>

        <para><literal>static</literal> 중첩클래스에 대한 빈 정의를 설정하고 싶다면 
          내부 클래스의 <emphasis>binary</emphasis> 이름을 사용해야 한다.</para>

        <para>예를 들어 <literal>com.example</literal> 패키지에 
          <classname>Foo</classname>라는 클래스가 있고 이 <literal>com.example</literal> 
          클래스에는 <classname>Bar</classname>라는 <literal>static</literal> 내부 
          클래스가 있다면 빈 정의의 <literal>'class'</literal> 속성의 값은 다음과 같을 
          것이다.</para>

        <para><classname>com.example.Foo$Bar</classname></para>

        <para>이름에서 <literal>$</literal> 문자는 바깥쪽 클래스 이름과 내부 클래스 이름을 
          구분하기 위해 사용한다.</para>
      </sidebar>

      <section id="beans-factory-class-ctor">
        <title>생성자를 이용한 인스턴스화</title>

        <para>생성자로 빈을 생성하면 일반적인 모든 클래스는 스프링과 함께 사용할 수 있다. 
          어떤 특정한 인터페이스를 구현하거나 특정한 스타일로 코딩할 필요가 없다. 그냥 빈 
          클래스를 명시하는 것만으로도 충분하다. 하지만 빈을 명시하려고 사용하는 IoC의 종류에 
          따라 기본 생성자(비어있는 생성자)가 필요할 수도 있다.</para>

        <para>스프링 IoC 컨테이너는 관리하고자 하는 거의 <emphasis>모든</emphasis> 
          클래스를 관리할 수 있다. 진짜 JavaBean만 관리할 수 있다는 제약 같은 건 없다. 
          많은 스프링 사용자들은 기본 생성자(아규먼트가 없는)만 있는 실제 JavaBean에 
          프로퍼티에 대한 적절한 setter와 getter를 사용하는 방법을 선호한다. 물론 
          컨테이너에서 예외적으로 빈 스타일이 아닌 클래스도 사용할 수 있다. 예를 들어 
          JavaBean 스펙을 전혀 따르지 않는 레거시 커넥션풀을 사용하더라도 스프링이 
          잘 관리할 수 있다.</para>

        <para>XML기반의 설정 메타데이터를 사용하면 다음과 같이 빈 클래스를 명시할 수 
          있다.</para>

        <programlisting language="xml">&lt;bean id="exampleBean" class="examples.ExampleBean"/&gt;

&lt;bean name="anotherExample" class="examples.ExampleBeanTwo"/&gt;</programlisting>

        <para>생성자에 아규먼트를 전달하거나(필요하다면) 객체가 생성된 후에 인스턴스에 프로퍼티를 
          설정하는 방법에 대해 자세히 알고 싶다면 <link
          linkend="beans-factory-collaborators">의존성 주입</link>을 참고해라.</para>
      </section>

      <section id="beans-factory-class-static-factory-method">
        <title>정적 팩토리 메서드를 이용한 인스턴스화</title>

        <para>정적 팩토리 메서드로 생성하는 빈을 정의할 때 <literal>static</literal> 팩토리 
          메서드가 있는 클래스를 지정하는 <literal>class</literal> 속성과 팩토리 
          메서드의 이름을 지정하는 <literal>factory-method</literal> 속성을 사용한다. 
          이 팩토리 메서드를 호출하면(뒤에서 설명할 선택적인 아규먼트로) 생성자로 생성한 
          빈과 동일하게 취급하는 살아 있는 객체를 리턴받는다. 레거시 코드에서 <literal>static
          </literal> 팩토리를 호출하는 것이 이러한 빈 정의의 한가지 사용법이다.</para>

        <para>다음 빈 정의는 팩토리 메서드를 호출해서 빈이 생성될 것이라는 지정한다. 
          이 빈 정의는 리턴되는 객체의 타입(클래스)은 지정하지 않고 클래스의 팩토리 메서드만 
          지정했다. 이 예제에서 <methodname>createInstance()</methodname> 메서드는 
          반드시 <emphasis>정적</emphasis> 메서드여야 한다.</para>

        <programlisting language="xml">&lt;bean id="clientService"
      class="examples.ClientService"
      factory-method="createInstance"/&gt;</programlisting>

        <programlisting language="java">public class ClientService {
  private static ClientService clientService = new ClientService();
  private ClientService() {}

  public static ClientService createInstance() {
    return clientService;
  }
}</programlisting>

        <para>팩토리 메서드에 (선택적인) 아규먼트를 전달하고 팩토리에서 리턴된 객체의 
          인스턴스에 프로퍼티를 설정하는 메커니즘에 대한 자세한 내용은 <link
          linkend="beans-factory-properties-detailed">의존성과 세부 설정
          </link>을 참고해라.</para>
      </section>

      <section id="beans-factory-class-instance-factory-method">
        <title>인스턴스 팩토리 메서드를 이용한 인스턴스화</title>
        
        <para><link linkend="beans-factory-class-static-factory-method">정적 팩토리 
          메서드</link>를 통한 인스턴스화와 비슷한 인스턴스 팩토리 메서드를 이용한 인스턴스화는 
          새로운 빈을 생성하기 위해 컨테이너에 존재하는 빈의 정적이 아닌 메서드를 호출한다. 
          이 메커니즘을 사용하려면 <literal>class</literal> 속성을 비워두고 <literal>
          factory-bean</literal> 속성에 현재 (또는 부모나 조상) 컨테이너에서 객체를 생성하기 
          위해 호출하는 인스턴스 메서드를 가지고 있는 빈의 이름을 지정한다. <literal>
          factory-method</literal> 속성에 팩토리 메서드의 이름을 설정한다.</para>

        <programlisting language="xml"><lineannotation>&lt;!-- <methodname>createInstance()
        </methodname>를 호출하는 메서드를 담고 있는 팩토리 빈 --&gt;</lineannotation>
&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt;
  <lineannotation>&lt;!-- 이 로케이터 빈으로 필요한 의존성을 주입한다 --&gt;</lineannotation>
&lt;/bean&gt;

<lineannotation>&lt;!-- 팩토리 빈을 통해 생성될 빈 --&gt;</lineannotation>
&lt;bean id="clientService"
      factory-bean="serviceLocator"
      factory-method="createClientServiceInstance"/&gt;</programlisting>

        <programlisting language="java">public class DefaultServiceLocator {
  private static ClientService clientService = new ClientServiceImpl();
  private DefaultServiceLocator() {}

  public ClientService createClientServiceInstance() {
    return clientService;
  }
}</programlisting>

        <para>하나의 팩토리 클래스는 다음과 같이 하나 이상의 팩토리 메서드를 가질 수도 
          있다.</para>

        <programlisting language="xml">
&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt;
  <lineannotation>&lt;!-- 이 로케이터 빈으로 필요한 의존성을 주입한다 --&gt;</lineannotation>
&lt;/bean&gt;
&lt;bean id="clientService"
      factory-bean="serviceLocator"
      factory-method="createClientServiceInstance"/&gt;

&lt;bean id="accountService"
      factory-bean="serviceLocator"
      factory-method="createAccountServiceInstance"/&gt;</programlisting>

        <programlisting language="java">public class DefaultServiceLocator {
  private static ClientService clientService = new ClientServiceImpl();
  private static AccountService accountService = new AccountServiceImpl();

  private DefaultServiceLocator() {}

  public ClientService createClientServiceInstance() {
    return clientService;
  }

  public AccountService createAccountServiceInstance() {
    return accountService;
  }
}</programlisting>

        <para>이 접근은 팩토리 빈 스스로 의존성 주입 (DI)를 통해 관리되고 설정될 수 
          있다는 것을 보여준다. <link
          linkend="beans-factory-properties-detailed"><link
          linkend="beans-factory-properties-detailed">의존성과 세부 설정</link>
          </link>을 참고해라.</para>

        <note>
          <para>스프링 문서에서 <emphasis>팩토리 빈</emphasis>은 스프링 컨테이너에 
            설정된 빈을 참조한다. 이 빈은 <link
            linkend="beans-factory-class-instance-factory-method"
            >인스턴스</link>나 <link
            linkend="beans-factory-class-static-factory-method">정적</link> 
            팩토리 메서드를 통해 객체를 생성하는 빈이다. 반면에 <interfacename>
            FactoryBean</interfacename> (대문자에 주의해라)은 스프링 고유의 
            <link linkend="beans-factory-extension-factorybean">
            <interfacename>FactoryBean</interfacename> </link>을 참조한다.</para>
        </note>
      </section>
    </section>
  </section>

  <xi:include href="beans-dependencies.xml"
    xmlns:xi="http://www.w3.org/2001/XInclude"/>

  <xi:include href="beans-scopes.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>

  <xi:include href="beans-customizing.xml"
    xmlns:xi="http://www.w3.org/2001/XInclude"/>

  <section id="beans-child-bean-definitions">
    <title>Bean definition inheritance</title>

    <para>A bean definition can contain a lot of configuration information,
      including constructor arguments, property values, and container-specific
      information such as initialization method, static factory method name, and
      so on. A child bean definition inherits configuration data from a parent
      definition. The child definition can override some values, or add others,
      as needed. Using parent and child bean definitions can save a lot of
      typing. Effectively, this is a form of templating.</para>

    <para>If you work with an <interfacename>ApplicationContext</interfacename>
      interface programmatically, child bean definitions are represented by the
      <classname>ChildBeanDefinition</classname> class. Most users do not work
      with them on this level, instead configuring bean definitions
      declaratively in something like the
      <classname>ClassPathXmlApplicationContext</classname>. When you use
      XML-based configuration metadata, you indicate a child bean definition by
      using the <literal>parent</literal> attribute, specifying the parent bean
      as the value of this attribute.</para>

    <programlisting language="xml">&lt;bean id="inheritedTestBean" abstract="true"
    class="org.springframework.beans.TestBean"&gt;
  &lt;property name="name" value="parent"/&gt;
  &lt;property name="age" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithDifferentClass"
      class="org.springframework.beans.DerivedTestBean"
      <emphasis role="bold">parent="inheritedTestBean"</emphasis> init-method="initialize"&gt;

  &lt;property name="name" value="override"/&gt;
  <lineannotation>&lt;!-- the age property value of 1 will be inherited from  parent --&gt;</lineannotation>

&lt;/bean&gt;</programlisting>

    <para>A child bean definition uses the bean class from the parent definition
      if none is specified, but can also override it. In the latter case, the
      child bean class must be compatible with the parent, that is, it must
      accept the parent's property values.</para>

    <para>A child bean definition inherits constructor argument values, property
      values, and method overrides from the parent, with the option to add new
      values. Any initialization method, destroy method, and/or
      <literal>static</literal> factory method settings that you specify will
      override the corresponding parent settings.</para>

    <para>The remaining settings are <emphasis>always</emphasis> taken from the
      child definition: <emphasis>depends on</emphasis>, <emphasis>autowire
      mode</emphasis>, <emphasis>dependency check</emphasis>,
      <emphasis>singleton</emphasis>, <emphasis>scope</emphasis>, <emphasis>lazy
      init</emphasis>.</para>

    <para>The preceding example explicitly marks the parent bean definition as
      abstract by using the <literal>abstract</literal> attribute. If the parent
      definition does not specify a class, explicitly marking the parent bean
      definition as <literal>abstract</literal> is required, as follows:</para>

    <programlisting language="xml">&lt;bean id="inheritedTestBeanWithoutClass" abstract="true"&gt;
    &lt;property name="name" value="parent"/&gt;
    &lt;property name="age" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
    parent="inheritedTestBeanWithoutClass" init-method="initialize"&gt;
  &lt;property name="name" value="override"/&gt;
  <lineannotation>&lt;!-- age will inherit the value of <literal>1</literal> from the parent bean definition--&gt;</lineannotation>
&lt;/bean&gt;</programlisting>

    <para>The parent bean cannot be instantiated on its own because it is
      incomplete, and it is also explicitly marked as
      <literal>abstract</literal>. When a definition is
      <literal>abstract</literal> like this, it is usable only as a pure
      template bean definition that serves as a parent definition for child
      definitions. Trying to use such an <literal>abstract</literal> parent bean
      on its own, by referring to it as a ref property of another bean or doing
      an explicit <methodname>getBean()</methodname> call with the parent bean
      id, returns an error. Similarly, the container's internal
      <methodname>preInstantiateSingletons()</methodname> method ignores bean
      definitions that are defined as abstract.</para>

    <note>
      <para><literal>ApplicationContext</literal> pre-instantiates all
        singletons by default. Therefore, it is important (at least for
        singleton beans) that if you have a (parent) bean definition which you
        intend to use only as a template, and this definition specifies a class,
        you must make sure to set the <emphasis>abstract</emphasis> attribute to
        <emphasis>true</emphasis>, otherwise the application context will
        actually (attempt to) pre-instantiate the <literal>abstract</literal>
        bean.</para>
    </note>
  </section>

  <xi:include href="beans-extension-points.xml"
    xmlns:xi="http://www.w3.org/2001/XInclude"/>

  <xi:include href="beans-annotation-config.xml"
    xmlns:xi="http://www.w3.org/2001/XInclude"/>

  <xi:include href="beans-classpath-scanning.xml"
    xmlns:xi="http://www.w3.org/2001/XInclude"/>
    
  <xi:include href="beans-standard-annotations.xml"
    xmlns:xi="http://www.w3.org/2001/XInclude"/>

  <xi:include href="beans-java.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>

  <section id="context-load-time-weaver">
    <title>Registering a <interfacename>LoadTimeWeaver</interfacename></title>

    <para>The <literal>context</literal> namespace introduced in Spring 2.5
      provides a <literal>load-time-weaver</literal>
      element.<!--Need to explain purpose of LoadTimeWeaver? Is this section ok here? --></para>

    <programlisting language="xml">&lt;beans&gt;

     &lt;context:load-time-weaver/&gt;

&lt;/beans&gt;</programlisting>

    <para>Adding this element to an XML-based Spring configuration file
      activates a Spring <interfacename>LoadTimeWeaver</interfacename> for the
      <interfacename>ApplicationContext</interfacename>. Any bean within that
      <interfacename>ApplicationContext</interfacename> may implement
      <interfacename>LoadTimeWeaverAware</interfacename>, thereby receiving a
      reference to the load-time weaver instance. This is particularly useful in
      combination with <link linkend="orm-jpa">Spring's JPA support</link> where
      load-time weaving may be necessary for JPA class transformation. Consult
      the <classname>LocalContainerEntityManagerFactoryBean</classname> Javadoc
      for more detail. For more on AspectJ load-time weaving, see <xref
      linkend="aop-aj-ltw"/>.</para>
  </section>

  <xi:include href="beans-context-additional.xml"
    xmlns:xi="http://www.w3.org/2001/XInclude"/>

  <section id="beans-beanfactory">
    <title>The BeanFactory</title>

    <para>The <classname>BeanFactory</classname> provides the underlying basis
      for Spring's IoC functionality but it is only used directly in integration
      with other third-party frameworks and is now largely historical in nature
      for most users of Spring. The <classname>BeanFactory</classname> and
      related interfaces, such as <classname>BeanFactoryAware</classname>,
      <classname>InitializingBean</classname>,
      <classname>DisposableBean</classname>, are still present in Spring for the
      purposes of backward compatibility with the large number of third-party
      frameworks that integrate with Spring. Often third-party components that
      can not use more modern equivalents such as <code>@PostConstruct</code> or
      <code>@PreDestroy</code> in order to remain compatible with JDK 1.4 or to
      avoid a dependency on JSR-250.</para>

    <para>This section provides additional background into the differences
      between the <interfacename>BeanFactory</interfacename> and
      <interfacename>ApplicationContext</interfacename> and how one might access
      the IoC container directly through a classic singleton lookup.</para>

    <section id="context-introduction-ctx-vs-beanfactory">
      <title><interfacename>BeanFactory</interfacename> or
        <interfacename>ApplicationContext</interfacename>?</title>

      <para>Use an <interfacename>ApplicationContext</interfacename> unless you
        have a good reason for not doing so.</para>

      <para>Because the <interfacename>ApplicationContext</interfacename>
        includes all functionality of the
        <interfacename>BeanFactory</interfacename>, it is generally recommended
        over the <interfacename>BeanFactory</interfacename>, except for a few
        situations such as in an <classname>Applet</classname> where memory
        consumption might be critical and a few extra kilobytes might make a
        difference. However, for most typical enterprise applications and
        systems, the <interfacename>ApplicationContext</interfacename> is what
        you will want to use. Spring 2.0 and later makes
        <emphasis>heavy</emphasis> use of the <link
        linkend="beans-factory-extension-bpp"
        ><interfacename>BeanPostProcessor</interfacename> extension point</link>
        (to effect proxying and so on). If you use only a plain
        <interfacename>BeanFactory</interfacename>, a fair amount of support
        such as transactions and AOP will not take effect, at least not without
        some extra steps on your part. This situation could be confusing because
        nothing is actually wrong with the configuration.</para>

      <para>The following table lists features provided by the
        <interfacename>BeanFactory</interfacename> and
        <interfacename>ApplicationContext</interfacename> interfaces and
        implementations.</para>

      <table id="context-introduction-ctx-vs-beanfactory-feature-matrix"
        pgwide="1">
        <title>Feature Matrix</title>

        <tgroup cols="3">
          <colspec align="left"/>

          <thead>
            <row>
              <entry align="center">Feature</entry>

              <entry align="center"
                ><interfacename>BeanFactory</interfacename></entry>

              <entry align="center"
                ><interfacename>ApplicationContext</interfacename></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para>Bean instantiation/wiring</para></entry>

              <entry align="center"><para>Yes</para></entry>

              <entry align="center"><para>Yes</para></entry>
            </row>

            <row>
              <entry><para>Automatic
                <interfacename>BeanPostProcessor</interfacename>
                registration</para></entry>

              <entry align="center"><para>No</para></entry>

              <entry align="center"><para>Yes</para></entry>
            </row>

            <row>
              <entry><para>Automatic
                <interfacename>BeanFactoryPostProcessor</interfacename>
                registration</para></entry>

              <entry align="center"><para>No</para></entry>

              <entry align="center"><para>Yes</para></entry>
            </row>

            <row>
              <entry><para>Convenient
                <interfacename>MessageSource</interfacename> access (for
                i18n)</para></entry>

              <entry align="center"><para>No</para></entry>

              <entry align="center"><para>Yes</para></entry>
            </row>

            <row>
              <entry><para><interfacename>ApplicationEvent</interfacename>
                publication</para></entry>

              <entry align="center"><para>No</para></entry>

              <entry align="center"><para>Yes</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>To explicitly register a bean post-processor with a
        <interfacename>BeanFactory</interfacename> implementation, you must
        write code like this:</para>

      <programlisting language="java">ConfigurableBeanFactory factory = new XmlBeanFactory(...);

<lineannotation>// now register any needed <interfacename>BeanPostProcessor</interfacename> instances</lineannotation>
MyBeanPostProcessor postProcessor = new MyBeanPostProcessor();
factory.addBeanPostProcessor(postProcessor);

<lineannotation>// now start using the factory</lineannotation></programlisting>

      <para>To explicitly register a
        <classname>BeanFactoryPostProcessor</classname> when using a
        <interfacename>BeanFactory</interfacename> implementation, you must
        write code like this:</para>

      <programlisting language="java">XmlBeanFactory factory = new XmlBeanFactory(new FileSystemResource("beans.xml"));

<lineannotation>// bring in some property values from a <classname>Properties</classname> file</lineannotation>
PropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));

<lineannotation>// now actually do the replacement</lineannotation>
cfg.postProcessBeanFactory(factory);</programlisting>

      <para>In both cases, the explicit registration step is inconvenient, which
        is one reason why the various
        <interfacename>ApplicationContext</interfacename> implementations are
        preferred above plain <interfacename>BeanFactory</interfacename>
        implementations in the vast majority of Spring-backed applications,
        especially when using <literal>BeanFactoryPostProcessors</literal> and
        <classname>BeanPostProcessors</classname>. These mechanisms implement
        important functionality such as property placeholder replacement and
        AOP.</para>
    </section>

    <section id="beans-servicelocator">
      <title>Glue code and the evil singleton</title>

      <para>It is best to write most application code in a dependency-injection
        (DI) style, where that code is served out of a Spring IoC container, has
        its own dependencies supplied by the container when it is created, and
        is completely unaware of the container. However, for the small glue
        layers of code that are sometimes needed to tie other code together, you
        sometimes need a singleton (or quasi-singleton) style access to a Spring
        IoC container. For example, third-party code may try to construct new
        objects directly (<literal>Class.forName()</literal> style), without the
        ability to get these objects out of a Spring IoC container.
        <!--Can you reword the phrase singleton style access, above and next parragraph? Seems awkward.-->If
        the object constructed by the third-party code is a small stub or proxy,
        which then uses a singleton style access to a Spring IoC container to
        get a real object to delegate to, then inversion of control has still
        been achieved for the majority of the code (the object coming out of the
        container). Thus most code is still unaware of the container or how it
        is accessed, and remains decoupled from other code, with all ensuing
        benefits. EJBs may also use this stub/proxy approach to delegate to a
        plain Java implementation object, retrieved from a Spring IoC container.
        While the Spring IoC container itself ideally does not have to be a
        singleton, it may be unrealistic in terms of memory usage or
        initialization times (when using beans in the Spring IoC container such
        as a Hibernate <interfacename>SessionFactory</interfacename>) for each
        bean to use its own, non-singleton Spring IoC container.</para>

      <para>Looking up the application context in a service locator style is
        sometimes the only option for accessing shared Spring-managed
        components, such as in an EJB 2.1 environment, or when you want to share
        a single ApplicationContext as a parent to WebApplicationContexts across
        WAR files. In this case you should look into using the utility class
        <ulink
        url="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/context/access/ContextSingletonBeanFactoryLocator.html"
        ><classname>ContextSingletonBeanFactoryLocator</classname></ulink>
        locator that is described in this <ulink
        url="http://blog.springsource.com/2007/06/11/using-a-shared-parent-application-context-in-a-multi-war-spring-application/"
        >SpringSource team blog entry</ulink>.</para>
    </section>
  </section>
</chapter>
