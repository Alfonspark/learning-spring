<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
 "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="jmx">
  <title>JMX</title>

  <section id="jmx-introduction">
    <title>소개</title>

    <para>스프링은 스프링 애플리케이션을 JMX 인프라에 쉽고 투명하게 통합할 수 있도록
    지원한다.</para>

    <sidebar>
      <title>JMX?</title>

      <para>이번 장은 JMX를 소개하는 장이 아니므로 왜 JMX가 필요한가에 대해서는 설명하지
      않는다(또는 JMX가 무엇의 약자인지) JMX를 처음 본다면 이 장 마지막의
      <xref linkend="jmx-resources" />를 봐라.</para>
    </sidebar>

    <para>특히 스프링의 JMX 지원은 네 가지 핵심 기능을 제공한다.</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>어떤</emphasis> 스프링 빈이라도 JMX MBean으로 자동
        등록</para>
      </listitem>

      <listitem>
        <para>빈 관리 인터페이스를 제어하는 유연한 메커니즘</para>
      </listitem>

      <listitem>
        <para>선언적으로 원격(JSR-160 커넥터)에 MBean을 노출</para>
      </listitem>

      <listitem>
        <para>로컬/원격 MBean 리소스를 간단하게 프록시 함</para>
      </listitem>
    </itemizedlist>

    <para>이 기능들은 애플리케이션 컴포넌트가 스프링이나 JMX 인터페이스 혹은 클래스에
    의존하지 않고 동작하도록 설계되었다. 사실 애플리케이션 클래스 대부분은 스프링의 JMX
    좋은 기능을 위해서 스프링이나 JMX를 인지할 필요가 없다.</para>
  </section>

  <section id="jmx-exporting">
    <title>빈을 JMX에 내보내기</title>

    <para><classname>MBeanExporter</classname>이 스프링 JMX 프레임워크의 핵심 클래스다.
    <classname>MBeanExporter</classname>이 스프링 빈을 가져와서 JMX
    <interfacename>MBeanServer</interfacename>에 등록한다. 예시로 다음 클래스를
    생각해 보자.</para>

    <programlisting language="java"><![CDATA[package org.springframework.jmx;

public class JmxTestBean implements IJmxTestBean {

    private String name;
    private int age;
    private boolean isSuperman;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public int add(int x, int y) {
        return x + y;
    }

    public void dontExposeMe() {
        throw new RuntimeException();
    }
}]]></programlisting>

    <para>이 빈의 프로퍼티와 메서드를 MBean의 속성과 오퍼레이션으로 노출하려면 다음과 같이
    설정파일에 <classname>MBeanExporter</classname> 클래스의 인스턴스를 설정하고 빈을
    전달하면 된다.</para>

    <programlisting language="xml"><![CDATA[<beans>

  ]]><lineannotation>&lt;!-- 내보내려면 이 빈을 지연초기화 하지 <emphasis role="bold">않아야</emphasis> 한다 --&gt;</lineannotation><![CDATA[
  <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"]]> <emphasis
        role="bold">lazy-init="false"</emphasis><![CDATA[>
    <property name="beans">
      <map>
        <entry key="bean:name=testBean1" value-ref="testBean"/>
      </map>
    </property>
  </bean>

  <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

</beans>]]></programlisting>

    <para>위 설정 예시에서 적절한 빈 정의는 <literal>exporter</literal> 빈이다.
    <literal>beans</literal> 프로퍼티가 빈 중에 정확히 어떤 빈을 JMX
    <interfacename>MBeanServer</interfacename>에 내보내야 하는지
    <classname>MBeanExporter</classname>에 알려준다. 기본 설정에서
    <literal>beans</literal> <interfacename>Map</interfacename>의 각 요소의 키를
    해당 값이 참조하는 빈의 <classname>ObjectName</classname>으로 사용한다.
    <xref linkend="jmx-naming"/>에서 설명했듯이 이 동작은 변경할 수 있다.</para>

    <para>이 설정에서 <literal>testBean</literal> 빈은
    <classname>ObjectName</classname> <literal>bean:name=testBean1</literal>의
    MBean으로 노출한다. 기본적으로 빈의 모든 <emphasis>public</emphasis> 프로퍼티는
    속성(attribute)로 노출하고 <emphasis>public</emphasis> 메서드
    (<classname>Object</classname> 클래스에서 상속받은 메서드 포함)는 오퍼레이션으로
    노출한다.</para>

    <section id="jmx-exporting-mbeanserver">
      <title><interfacename>MBeanServer</interfacename> 생성</title>

      <para>위의 설정은 하나의(유일한) <interfacename>MBeanServer</interfacename>가
      동작하고 있는 환경에서 애플리케이션이 돌아가고 있다고 가정한다. 이럴 때 스프링은 돌아가고
      있는 <interfacename>MBeanServer</interfacename>을 찾아내서 (찾았다면) 해당 서버에
      빈을 등록하려고 할 것이다. Tomcat이나 IBM WebSphere처럼
      <interfacename>MBeanServer</interfacename>를 가진 컨테이너에서 애플리케이션을
      돌리는 경우 이 동작이 유용하다.</para>

      <para>하지만 독립적인 환경이나 <interfacename>MBeanServer</interfacename>를
      제공하지 않는 컨테이너를 사용하는 경우에는 이 접근을 사용하지 않는다. 설정에
      <classname>org.springframework.jmx.support.MBeanServerFactoryBean</classname>
      클래스의 인스턴스를 추가해서 선언적으로 <interfacename>MBeanServer</interfacename>
      인스턴스를 생성해서 이 문제를 해결할 수 있다. <classname>MBeanExporter</classname>의
      <literal>server</literal> 프로퍼티를
      <classname>MBeanServerFactoryBean</classname>이 반환한
      <interfacename>MBeanServer</interfacename> 값으로 설정해서 특정
      <interfacename>MBeanServer</interfacename>를 사용한다는 것을 보장할 수도 있다.
      예를 들면 다음과 같다.</para>

      <programlisting language="xml"><![CDATA[<beans>

  <bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"/>

  ]]><lineannotation>&lt;!--
    내보내기가 동작하도록 이 빈을 최대한 미리 인스턴스화할 필요가 있다;
    즉 이 빈은 지연 초기화로 지정하지 <emphasis role="bold">않아야</emphasis> 한다.
  --&gt;</lineannotation><![CDATA[
  <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="bean:name=testBean1" value-ref="testBean"/>
      </map>
    </property>
    <property name="server" ref="mbeanServer"/>
  </bean>

  <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

</beans>]]></programlisting>

      <para>여기서 <classname>MBeanServerFactoryBean</classname>이
      <interfacename>MBeanServer</interfacename>의 인스턴스를 생성했고 server 프로퍼티로
      <classname>MBeanExporter</classname>에 전달했다. 자신의
      <interfacename>MBeanServer</interfacename> 인스턴스를 전달했을 때
      <classname>MBeanExporter</classname>가 동작하고 있는
      <interfacename>MBeanServer</interfacename>를 찾지 않고 전달받은
      <interfacename>MBeanServer</interfacename> 인스턴스를 사용할 것이다. 이 부분이
      제대로 동작하려면 클래스패스에 JMX 구현체가 당연히 있어야 한다.</para>
    </section>

    <section id="jmx-mbean-server">
      <title>이미 존재하는 <interfacename>MBeanServer</interfacename>의 재사용</title>

      <para>서버를 지정하지 않으면 자동으로 <classname>MBeanExporter</classname>가
      돌아가고 있는 <interfacename>MBeanServer</interfacename>를 탐지하려고 할 것이다.
      딱 하나의 <interfacename>MBeanServer</interfacename> 인스턴스만 사용하는 대부분의
      환경에서는 잘 동작할 것이지만 여러 인스턴스가 존재한다면 익스포터가 잘못된 서버를 선택할 수도
      있다. 이럴 때 사용할 인스턴스를 나타내는
      <interfacename>MBeanServer</interfacename> <literal>agentId</literal>를
      사용해야 한다.</para>

      <programlisting language="xml"><![CDATA[<beans>
   <bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean">
     ]]><lineannotation>&lt;!-- 제일 먼저 찾을 서버를 지정한다 --&gt;</lineannotation><![CDATA[
     <property name="locateExistingServerIfPossible" value="true"/>
     ]]><lineannotation>&lt;!-- 주어진 agentId로 <interfacename>MBeanServer</interfacename> 인스턴스를 찾는다 --&gt;</lineannotation><![CDATA[
     <property name="agentId" value="]]><emphasis><![CDATA[<MBeanServer instance agentId>]]></emphasis><![CDATA["/>
   </bean>

   <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
     <property name="server" ref="mbeanServer"/>
   ...
   </bean>
</beans>]]></programlisting>

      <para>기존의 <interfacename>MBeanServer</interfacename>가 검색 메서드로 얻은
      동적(혹은 모르는) <literal>agentId</literal>를 가진 경우는
      <link linkend="beans-factory-class-static-factory-method">factory-method</link>를
      사용해야 한다.</para>

      <programlisting language="xml"><![CDATA[<beans>
   <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
     <property name="server">
       ]]><lineannotation>&lt;!-- 커스텀 <literal>MBeanServerLocator</literal> --&gt;</lineannotation><![CDATA[
       <bean class="platform.package.MBeanServerLocator" factory-method="locateMBeanServer"/>
     </property>

     ]]><lineannotation>&lt;!-- 다른 빈 정의 --&gt;</lineannotation><![CDATA[

   </bean>
</beans>]]></programlisting>
    </section>

    <section id="jmx-exporting-lazy">
      <title>지연 초기화된 MBean</title>

      <para>지연 초기화로 설정된 <classname>MBeanExporter</classname>로 지연 초기화된
      빈을 설정하는 경우 <classname>MBeanExporter</classname>이 해당 규약을 깨뜨리지
      <emphasis role="bold">않을</emphasis> 것이고 빈을 인스턴스화하지 않을 것이다. 대신
      <classname>MBeanExporter</classname>는
      <interfacename>MBeanServer</interfacename>에 프록시를 등록하고 프록시에서 첫 호출이
      발생할 때까지 컨테이너에서 빈을 가져오는 것을 미룰 것이다.</para>
    </section>

    <section id="jmx-exporting-auto">
      <title>MBean의 자동 등록</title>

      <para><classname>MBeanExporter</classname>로 익스포트했고 유효한 MBean인 모든 빈은
      스프링이 추가로 개입하지 않고 그대로 <interfacename>MBeanServer</interfacename>에
      등록된다. <literal>autodetect</literal> 프로퍼티를 <literal>true</literal>로
      설정해서 <classname>MBeanExporter</classname>가 자동으로 MBean을 탐지할 수
      있다.</para>

      <programlisting language="xml"><![CDATA[<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
  <property name="autodetect" value="true"/>
</bean>

<bean name="spring:mbean=true" class="org.springframework.jmx.export.TestDynamicMBean"/>]]></programlisting>

      <para>이 예제에서 <literal>spring:mbean=true</literal>인 빈은 이미 유효한 JMX
      MBean이고 스프링이 자동으로 등록할 것이다. 기본적으로 JMX에 자동탐지돼서 등록한 빈은
      <classname>ObjectName</classname>을 빈 이름으로 사용한다. 이 동작은
      <xref linkend="jmx-naming" />에서 설명한 대로 변경할 수 있다.</para>
    </section>

    <section id="jmx-exporting-registration-behavior">
      <title>등록과정의 제어</title>

      <para>스프링 <classname>MBeanExporter</classname>가
      <literal>'bean:name=testBean1'</literal>이라는
      <classname>ObjectName</classname>으로
      <interfacename>MBeanServer</interfacename>에 <classname>MBean</classname>을
      등록하려고 하는 시나리오를 생각해 보자. <classname>MBean</classname> 인스턴스가 이미
      같은 <classname>ObjectName</classname>으로 등록되어 있다면 기본 동작은 실패한다.
      (<exceptionname>InstanceAlreadyExistsException</exceptionname>를
      던진다.)</para>

      <para><classname>MBean</classname>을
      <interfacename>MBeanServer</interfacename>에 등록했을 때 일어나는 동작을 제어할 수
      있다. 스프링의 JMX 지원으로 등록과정에서 <classname>MBean</classname>이 이미 같은
      <classname>ObjectName</classname>으로 등록되었다는 점을 발견했을 때 등록 동작을
      제어할 수 있는 세 가지 등록 동작을 이용할 수 있다. 이 등록 동작은 다음 표에
      정리되어 있다.</para>

      <table id="jmx-registration-behaviors">
          <title>등록 동작</title>

          <tgroup cols="2">
            <colspec align="left" />

            <colspec colnum="1" colwidth="*" />

            <colspec colnum="2" colwidth="*" />

            <thead>
              <row>
                <entry align="center">등록 동작</entry>

                <entry align="center">설명</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><para><literal>REGISTRATION_FAIL_ON_EXISTING</literal></para></entry>

                <entry><para> 기본 등록 동작이다. <classname>MBean</classname>
                인스턴스가 같은 <classname>ObjectName</classname>으로 이미 등록되어
                있다면 등록하려던 <classname>MBean</classname>을 등록하지 않고
                <exceptionname>InstanceAlreadyExistsException</exceptionname>를
                던질 것이다. 존재하는 <classname>MBean</classname>에는 영향을 주지
                않는다. </para></entry>
              </row>

              <row>
                <entry><para><literal>REGISTRATION_IGNORE_EXISTING</literal></para></entry>

                <entry><para> <classname>MBean</classname> 인스턴스가 같은
                <classname>ObjectName</classname>으로 이미 등록되어 있다면 등록하려던
                <classname>MBean</classname>을 등록하지 <emphasis>않는다</emphasis>.
                기존의 <classname>MBean</classname>에는 영향을 주지 않고
                <exceptionname>Exception</exceptionname>도 던지지 않는다. </para>
                <para> 이 동작은 공유된
                <interfacename>MBeanServer</interfacename>에서 여러 애플리케이션이
                공통적인 <classname>MBean</classname>을 공유할 때 유용하다.
                </para></entry>
              </row>

              <row>
                <entry><para><literal>REGISTRATION_REPLACE_EXISTING</literal></para></entry>

                <entry><para> <classname>MBean</classname> 인스턴스가 같은
                <classname>ObjectName</classname>으로 이미 등록되어 있다면 미리
                등록되어 있던 <classname>MBean</classname>이 등록 해지되고 새로운
                <classname>MBean</classname>이 해당 위치에 등록될 것이다. (이전의
                인스턴스를 새로운 <classname>MBean</classname>이 효율적으로 바꿔치기
                한다.) </para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

      <para>위의 값은 <classname>MBeanRegistrationSupport</classname>
      클래스(<classname>MBeanExporter</classname> 클래스는 이 슈퍼클래스에서
      파생된 클래스다.)에 상수로 정의되어 있다. 기존 등록동작을 바꾸고자 한다면
      <classname>MBeanExporter</classname> 정의에서
      <literal>registrationBehaviorName</literal> 프로퍼티의 값을
      변경하면 된다.</para>

      <para>다음 예제는 기본 등록 동작을
      <literal>REGISTRATION_REPLACE_EXISTING</literal>로 변경이 어떻게
      영향을 주는지 보여준다.</para>

      <programlisting language="xml"><![CDATA[<beans>

    <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
        <property name="beans">
            <map>
                <entry key="bean:name=testBean1" value-ref="testBean"/>
            </map>
        </property>
        <property name="registrationBehaviorName" value="REGISTRATION_REPLACE_EXISTING"/>
    </bean>

    <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
        <property name="name" value="TEST"/>
        <property name="age" value="100"/>
    </bean>

</beans>]]></programlisting>
    </section>
  </section>

  <section id="jmx-interface">
    <title>빈의 관리 인터페이스 제어하기</title>

    <para>이전 예제에서 빈의 관리(management) 인터페이스로 약간의 제어를 했다. 익스포트한
    <emphasis>모든</emphasis> <emphasis>public</emphasis> 프로퍼티와 메서드는
    JMX 속성과 동작으로 각각 노출된다. 익스포트한 빈의 어떤 프로퍼티와 메서드가 JMX 속성과
    동작으로 노출되는지 세밀하게 제어하기 위해서 스프링 JMX는 빈의 관리 인터페이스를 제어하는
    광범위하고 확장 가능한 메커니즘을 제공한다.</para>

    <section id="jmx-interface-assembler">
      <title><interfacename>MBeanInfoAssembler</interfacename> 인터페이스</title>

      <para>내부적으로 <classname>MBeanExporter</classname>는 노출될 각 빈의 관리
      인터페이스를 정의하는 역할을 하는
      <classname>org.springframework.jmx.export.assembler.MBeanInfoAssembler</classname>
      인터페이스의 구현체에 위임한다. 기본 구현체인
      <classname>org.springframework.jmx.export.assembler.SimpleReflectiveMBeanInfoAssembler</classname>는
      모든 퍼블릭 프로퍼티와 메서드를 노출하는(이전 예제에서 본 것처럼) 관리 인터페이스를 정의한다.
      스프링은 소스수준의 메타데이터나 다른 임의의 인터페이스를 사용해서 생성한 관리 인터페이스를
      제어할 수 있는 <interfacename>MBeanInfoAssembler</interfacename>
      인터페이스의 두 구현체를 추가적으로 제공한다.</para>
    </section>

    <section id="jmx-interface-metadata">
      <title>소스 수준의 메타데이터 사용하기 (JDK 5.0 어노테이션)</title>

      <para><classname>MetadataMBeanInfoAssembler</classname>를 사용해서 소스
      수준의 메타데이터를 사용하는 빈에 대한 관리 인터페이스를 정의할 수 있다. 메타데이터는
      <classname>org.springframework.jmx.export.metadata.JmxAttributeSource</classname>
      인터페이스로 캡슐화해서 읽는다. 스프링 JMX는 JDK 5.0 어노테이션
      (<classname>org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource</classname>)을 사용하는 기본 구현체를 제공한다.
      <classname>MetadataMBeanInfoAssembler</classname>가 제대로 동작하기 위해서는
      <classname>JmxAttributeSource</classname> 인터페이스의 구현체 인스턴스로
      설정<emphasis>해야 한다</emphasis>.(기본값이 존재하지
      <emphasis>않는다</emphasis>.)</para>

      <para>JMX로 내보내도록 빈을 표시하려면 빈 클래스에
      <classname>ManagedResource</classname> 어노테이션을 붙여야 한다.
      동작(operation)으로 노출하려는 각 메서드는
      <classname>ManagedOperation</classname> 어노테이션을 붙여야 하고 노출하려는
      각 프로퍼티는 <classname>ManagedAttribute</classname> 어노테이션을 붙여야
      한다. 프로퍼티에 어노테이션을 붙일 때는 읽기 전용이나 쓰기 전용 속성을 만들기 위해서
      getter나 setter의 어노테이션을 생략할 수 있다.</para>

      <para>아래 예제는 앞에서 본 <classname>JmxTestBean</classname>
        클래스의 어노테이션을 사용한 버전이다.</para>
      <programlisting language="java"><![CDATA[package org.springframework.jmx;

import org.springframework.jmx.export.annotation.ManagedResource;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedAttribute;

@ManagedResource(objectName="bean:name=testBean4", description="My Managed Bean", log=true,
    logFile="jmx.log", currencyTimeLimit=15, persistPolicy="OnUpdate", persistPeriod=200,
    persistLocation="foo", persistName="bar")
public class AnnotationTestBean implements IJmxTestBean {

  private String name;
  private int age;

  @ManagedAttribute(description="The Age Attribute", currencyTimeLimit=15)
  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    this.age = age;
  }

  @ManagedAttribute(description="The Name Attribute",
      currencyTimeLimit=20,
      defaultValue="bar",
      persistPolicy="OnUpdate")
  public void setName(String name) {
    this.name = name;
  }

  @ManagedAttribute(defaultValue="foo", persistPeriod=300)
  public String getName() {
    return name;
  }

  @ManagedOperation(description="Add two numbers")
  @ManagedOperationParameters({
    @ManagedOperationParameter(name = "x", description = "The first number"),
    @ManagedOperationParameter(name = "y", description = "The second number")})
  public int add(int x, int y) {
    return x + y;
  }

  public void dontExposeMe() {
    throw new RuntimeException();
  }
}]]></programlisting>

      <para>이 예제에서 <classname>JmxTestBean</classname> 클래스에
      <classname>ManagedResource</classname> 어노테이션이 붙어있는 것을 볼 수 있고
      이 <classname>ManagedResource</classname> 어노테이션은 여러 가지 프로터티들로
      설정되어 있다. <classname>MBeanExporter</classname>가 생성하는 MBean의 다양한
      관점을 설정하는데 이러한 프로퍼티를 설정할 수 있고 더 자세한 내용은 나중에
      <xref linkend="jmx-interface-metadata-types" />부분에서 설명한다.</para>

      <para><literal>age</literal>와 <literal>name</literal> 프로퍼티도
      <classname>ManagedAttribute</classname> 어노테이션이 붙을 것을 볼 수 있는데
      여기서 <literal>age</literal>에는 getter에만 어노테이션이 붙어 있다. 이
      어노테이션을 붙임으로써 두 프로퍼티 모두 관리 인터페이스의 속성으로 포함되지만
      <literal>age</literal>는 읽기 전용이다.</para>

      <para>마지막으로 <literal>add(int, int)</literal> 메서드에는
      <classname>ManagedOperation</classname> 어노테이션이 붙어있지만
      <literal>dontExposeMe()</literal> 메서드에는 붙어있지 않다. 그래서 관리
      인터페이스는 <classname>MetadataMBeanInfoAssembler</classname>를
      사용할 때 <literal>add(int, int)</literal> 오퍼레이션만 가진다.</para>

      <para><classname>MetadataMBeanInfoAssembler</classname>를 사용하는
      <classname>MBeanExporter</classname>를 설정하는 방법이 아래 설정에
      나와 있다.</para>
      <programlisting language="xml"><![CDATA[<beans>
    <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
        <property name="assembler" ref="assembler"/>
        <property name="namingStrategy" ref="namingStrategy"/>
        <property name="autodetect" value="true"/>
    </bean>

    <bean id="jmxAttributeSource"
          class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/>

    ]]><lineannotation>&lt;!-- 어노테이션의 메타데이터를 사용해서 관리 인터페이스를 생성할 것이다 --&gt;</lineannotation><![CDATA[
    <bean id="assembler"
          class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler">
        <property name="attributeSource" ref="jmxAttributeSource"/>
    </bean>

    ]]><lineannotation>&lt;!-- 어노테이션에서 <classname>ObjectName</classname>을 선택할 것이다 --&gt;</lineannotation><![CDATA[
    <bean id="namingStrategy"
          class="org.springframework.jmx.export.naming.MetadataNamingStrategy">
        <property name="attributeSource" ref="jmxAttributeSource"/>
    </bean>

    <bean id="testBean" class="org.springframework.jmx.AnnotationTestBean">
        <property name="name" value="TEST"/>
        <property name="age" value="100"/>
    </bean>
</beans>]]></programlisting>


      <para>여기서 <classname>MetadataMBeanInfoAssembler</classname> 빈이
      <classname>AnnotationJmxAttributeSource</classname> 클래스의 인스턴스로
      설정되었고 assembler 프로퍼티로 <classname>MBeanExporter</classname>에 전달되는
      것을 볼 수 있다. 이것이 스프링이 노출한 MBean의 메타데이터 주도 관리 인터페이스의 장점을
      취하는 데 필요한 전부이다.</para>
    </section>

    <section id="jmx-interface-metadata-types">
      <title>소스 수준의 메타데이터 타입</title>

      <para>다음 소스 수준의 메타데이터 타입을 스프링 JMX에서 사용할 수 있다.</para>

      <para><table id="jmx-metadata-types">
          <title>소스 수준의 메타데이터 타입</title>

          <tgroup cols="3">
            <colspec align="left" />

            <colspec colname="spycolgen1" colnum="1" colwidth="*" />

            <colspec colname="spycolgen2" colnum="2" colwidth="*" />

            <thead>
              <row>
                <entry align="center">목적</entry>

                <entry align="center">어노테이션</entry>

                <entry align="center">어노테이션 타입</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><classname>Class</classname>의 모든 인스턴스를 JMX가 관리하는 리소스로 표시한다.</entry>

                <entry><literal>@ManagedResource</literal></entry>

                <entry>Class</entry>
              </row>

              <row>
                <entry>메서드를 JMX 동작으로 표시한다.</entry>

                <entry><literal>@ManagedOperation</literal></entry>

                <entry>Method</entry>
              </row>

              <row>
                <entry>getter나 setter를 JMX 속성의 절반으로 표시한다.</entry>

                <entry><classname>@ManagedAttribute</classname></entry>

                <entry>Method (getter와 setter 전용)</entry>
              </row>

              <row>
                <entry>동작(operation) 파라미터에 대한 디스크립션을 정의한다.</entry>

                <entry><classname>@ManagedOperationParameter</classname>와
                <classname>@ManagedOperationParameters</classname></entry>

                <entry>Method</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para>소스 수준의 메타데이터 타입에서 다음 설정 파라미터를 사용할 수 있다.</para>

      <para><table id="jmx-metadata-parameters">
          <title>소스 수준의 메타데이터 파라미터</title>

          <tgroup cols="3">
            <colspec align="left" />

            <colspec colname="spycolgen1" colnum="1" colwidth="*" />

            <colspec colname="spycolgen2" colnum="2" colwidth="*" />

            <thead>
              <row>
                <entry align="center">파라미터</entry>

                <entry align="center">설명</entry>

                <entry align="center">적용 대상</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><classname>ObjectName</classname></entry>

                <entry>관리하는 리소스의 <classname>ObjectName</classname>을
                결정하기 위해서 <classname>MetadataNamingStrategy</classname>가
                사용한다.</entry>

                <entry><classname>ManagedResource</classname></entry>
              </row>

              <row>
                <entry><literal>description</literal></entry>

                <entry>리소스, 속성, 동작의 디스크립션을 설정한다.</entry>

                <entry><classname>ManagedResource</classname>,
                <classname>ManagedAttribute</classname>,
                <classname>ManagedOperation</classname>,
                <classname>ManagedOperationParameter</classname></entry>
              </row>

              <row>
                <entry><literal>currencyTimeLimit</literal></entry>

                <entry><literal>currencyTimeLimit</literal> 디스크립터 필드의
                값을 설정한다</entry>

                <entry><classname>ManagedResource</classname>,
                <classname>ManagedAttribute</classname></entry>
              </row>

              <row>
                <entry><literal>defaultValue</literal></entry>

                <entry><literal>defaultValue</literal> 디스크립터 필드의 값을
                설정한다</entry>

                <entry><classname>ManagedAttribute</classname></entry>
              </row>

              <row>
                <entry><literal>log</literal></entry>

                <entry><literal>log</literal> 디스크립터 필드의 값을
                설정한다</entry>

                <entry><classname>ManagedResource</classname></entry>
              </row>

              <row>
                <entry><literal>logFile</literal></entry>

                <entry><literal>logFile</literal> 디스크립터 필드의 값을
                설정한다</entry>

                <entry><classname>ManagedResource</classname></entry>
              </row>

              <row>
                <entry><literal>persistPolicy</literal></entry>

                <entry><literal>persistPolicy</literal> 디스크립터 필드의 값을
                설정한다</entry>

                <entry><classname>ManagedResource</classname></entry>
              </row>

              <row>
                <entry><literal>persistPeriod</literal></entry>

                <entry><literal>persistPeriod</literal> 디스크립터 필드의 값을
                설정한다</entry>

                <entry><classname>ManagedResource</classname></entry>
              </row>

              <row>
                <entry><literal>persistLocation</literal></entry>

                <entry><literal>persistLocation</literal> 디스크립터 필드의 값을
                설정한다</entry>

                <entry><classname>ManagedResource</classname></entry>
              </row>

              <row>
                <entry><literal>persistName</literal></entry>

                <entry><literal>persistName</literal> 디스크립터 필드의 값을
                설정한다</entry>

                <entry><classname>ManagedResource</classname></entry>
              </row>

              <row>
                <entry><literal>name</literal></entry>

                <entry>동작(operation) 파라미터의 표시 이름을 설정한다</entry>

                <entry><literal>ManagedOperationParameter</literal></entry>
              </row>

              <row>
                <entry><literal>index</literal></entry>

                <entry>동작 파라미터의 인덱스를 설정한다</entry>

                <entry><literal>ManagedOperationParameter</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section id="jmx-interface-autodetect">
      <title><classname>AutodetectCapableMBeanInfoAssembler</classname>
      인터페이스</title>

      <para>더 간단한 설정을 위해서 스프링은
      <interfacename>MBeanInfoAssembler</interfacename> 인터페이스를 확장해서
      MBean 리소스를 자동탐지를 지원하려고
      <classname>AutodetectCapableMBeanInfoAssembler</classname> 인터페이스를
      도입했다. <classname>AutodetectCapableMBeanInfoAssembler</classname>
      인스턴스로 <classname>MBeanExporter</classname>를 설정하면 JMX에 노출하기 위해
      빈에 "투표(vote)"할 수 있다.</para>

      <para><classname>AutodetectCapableMBeanInfo</classname> 인터페이스의
      유일한 구현체인 <classname>MetadataMBeanInfoAssembler</classname>는
      <classname>ManagedResource</classname> 속성으로 표시된 모든 빈을 포함하도록
      투표한다. 이 경우 기본 접근은 다음과 같은 설정의 빈 이름을
      <classname>ObjectName</classname>으로 사용하는 것이다.</para>

      <programlisting language="xml"><![CDATA[<beans>

  <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    ]]><lineannotation>&lt;!-- 어떤 <literal>'beans'</literal>도 명시적으로 선언하지 않았다. --&gt;</lineannotation><![CDATA[
    <property name="autodetect" value="true"/>
    <property name="assembler" ref="assembler"/>
  </bean>

  <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

  <bean id="assembler" class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler">
    <property name="attributeSource">
        <bean class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/>
    </property>
  </bean>

</beans>]]></programlisting>

      <para>이 설정에서 어떤 빈도 <classname>MBeanExporter</classname>에 전달하지 않았다.
      하지만 <classname>ManagedResource</classname> 속성으로 표시되었고
      <classname>MetadataMBeanInfoAssembler</classname>가
      <classname>ManagedResource</classname>를 탐지해서 포함하도록 투표하므로
      <classname>JmxTestBean</classname>가 등록될 것이다. 이 접근방법의 유일한 문제점은
      <classname>JmxTestBean</classname>의 이름이 비즈니스적인 의미를 갖게 되었다는 점이다.
      <xref linkend="jmx-naming" />에서 정의된 것처럼
      <classname>ObjectName</classname>를 생성하는 기본 동작을 변경해서 이 문제를 해결할
      수 있다.</para>
    </section>

    <section id="jmx-interface-java">
      <title>자바 인터페이스를 사용한 관리 인터페이스 정의</title>

      <para><classname>MetadataMBeanInfoAssembler</classname>에 추가로 스프링도
      인터페이스 컬렉션에 정의된 메서드 세트에 기반을 둬서 노출되는 메서드와 프로퍼티에 제약을 가할 수
      있는 <classname>InterfaceBasedMBeanInfoAssembler</classname>를 포함하고
      있다.</para>

      <para>MBean을 노출하는 표준 메커니즘이 인터페이스와 간단한 작명 계획을 사용하기는 하지만
      <classname>InterfaceBasedMBeanInfoAssembler</classname>는 작명 관례에
      대한 요구사항을 제거해서 이 기능을 확장함으로써 하나 이상의 인터페이스를 사용하고 빈이
      MBean 인터페이스를 구현하지 않아도 되게 한다.</para>

      <para>앞에서 본 <classname>JmxTestBean</classname> 클래스에 대한 관리
      인터페이스를 정의할 때 이 인터페이스의 사용을 고려해 봐라.</para>

      <programlisting language="java"><![CDATA[public interface IJmxTestBean {

  public int add(int x, int y);

  public long myOperation();

  public int getAge();

  public void setAge(int age);

  public void setName(String name);

  public String getName();
}]]></programlisting>

      <para>이 인터페이스는 JMX MBean의 동작과 속성으로 노출될 메서드와 프로퍼티를 정의한다.
      아래 코드는 관리 인터페이스의 정의로 이 인터페이스를 사용하도록 스프링 JMX를 설정하는
      방법을 보여준다.</para>

      <programlisting language="xml"><![CDATA[<beans>

  <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="bean:name=testBean5" value-ref="testBean"/>
      </map>
    </property>
    <property name="assembler">
      <bean class="org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler">
        <property name="managedInterfaces">
          <value>org.springframework.jmx.IJmxTestBean</value>
        </property>
      </bean>
    </property>
  </bean>

  <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

</beans>]]></programlisting>

      <para>모든 빈에 대한 관리 인터페이스를 생성할 때
      <interfacename>IJmxTestBean</interfacename> 인터페이스를 사용하도록 설정한
      <classname>InterfaceBasedMBeanInfoAssembler</classname>를 볼 수 있다.
      <classname>InterfaceBasedMBeanInfoAssembler</classname>가 처리한 빈은
      JMX 관리 인터페이스를 생성하는 데 사용하는 인터페이스를 구현할 필요가 없다는 점을 이해하는
      것이 중요하다.</para>

      <para>위의 경우 모든 빈에 대한 모든 관리 인터페이스를 생성하는데
      <interfacename>IJmxTestBean</interfacename> 인터페이스를 사용한다. 많은 경우
      이는 원하는 동작이 아니고 빈마다 다른 인터페이스를 사용하길 원할 것이다. 이러면
      <literal>interfaceMappings</literal> 프로퍼티로(각 엔트리는 빈의 이름이고 엔트리의
      값은 해당 빈에 사용할 인터페이스 이름을 콤마로 구분한 목록이다.)
      <classname>InterfaceBasedMBeanInfoAssembler</classname>
      <classname>Properties</classname> 인스턴스를 전달할 수 있다.</para>

      <para><literal>managedInterfaces</literal>와
      <literal>interfaceMappings</literal> 프로퍼티로 지정한 관리 인터페이스가 없으면
      <classname>InterfaceBasedMBeanInfoAssembler</classname>가 빈에 반영되고
      관리인터페이스를 생성하는 해당 빈이 구현한 모든 인터페이스를 사용할 것이다.</para>
    </section>

    <section id="jmx-interface-methodnames">
      <title>
      <classname>MethodNameBasedMBeanInfoAssembler</classname> 사용하기</title>

      <para><classname>MethodNameBasedMBeanInfoAssembler</classname>로 JMX가
      속성과 동작으로 노출할 메서드명의 목록을 지정할 수 있다. 아래 코드는 이에 대한 설정 예시를
      보여 준다.</para>

      <programlisting language="xml"><![CDATA[<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="bean:name=testBean5" value-ref="testBean"/>
      </map>
    </property>
    <property name="assembler">
      <bean class="org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssembler">
        <property name="managedMethods">
          <value>add,myOperation,getName,setName,getAge</value>
        </property>
      </bean>
    </property>
</bean>]]></programlisting>

      <para>이 코드에서 <literal>add</literal>와 <literal>myOperation</literal>
      메서드가 JMX 동작으로 노출되고 <literal>getName()</literal>,
      <literal>setName(String)</literal>, <literal>getAge()</literal>는 JMX
      속성으로 노출되는 것을 볼 수 있다. 위 코드에서 메서드는 JMX에 노출되는 빈에 매핑된다. 빈과
      빈(bean-by-bean)의 메서드 노출을 제어하려면 빈 이름을 메서드 이름의 목록에 매핑하기 위해
      <classname>MethodNameMBeanInfoAssembler</classname>의
      <literal>methodMappings</literal> 프로퍼티를 사용해라.</para>
    </section>
  </section>

  <section id="jmx-naming">
    <title>빈의 <classname>ObjectName</classname> 제어</title>

    <para>내부적으로 <classname>MBeanExporter</classname>는
    <classname>ObjectNamingStrategy</classname> 구현체에 등록하는 각 빈의
    <classname>ObjectName</classname>을 가져오는 전략을 위임한다. 기본 구현체
    <classname>KeyNamingStrategy</classname>는 <literal>beans</literal>
    <interfacename>Map</interfacename>의 키를 <classname>ObjectName</classname>로
    사용한다. 그리고 <classname>KeyNamingStrategy</classname>는
    <literal>beans</literal> <interfacename>Map</interfacename>의 키를
    <classname>Properties</classname>의 항목에 매핑해서
    <classname>ObjectName</classname>을 처리할 수 있다.
    <classname>KeyNamingStrategy</classname>외에도 스프링은 두 가지
    <classname>ObjectNamingStrategy</classname> 구현체를 더 제공하고 있다.
    <classname>IdentityNamingStrategy</classname>는 빈의 JVM 아이디(identity)에
    기반해서 <classname>ObjectName</classname>을 만들고
    <classname>MetadataNamingStrategy</classname>은 소스 수준의 메타데이터를 사용해서
    <classname>ObjectName</classname>를 얻는다.</para>

    <section id="jmx-naming-properties">
      <title><classname>Properties</classname>에서 <classname>ObjectName</classname> 읽어오기</title>

      <para>자신만의 <classname>KeyNamingStrategy</classname> 인스턴스를 설정해서 빈의
      키를 사용하는 대신 <classname>Properties</classname> 인스턴스에서
      <classname>ObjectName</classname>을 읽어오도록 구성할 수 있다.
      <classname>KeyNamingStrategy</classname>는 빈 키에 대응되는 키를 가진
      <classname>Properties</classname>의 요소를 찾으려고 할 것이다. 일치하는 항목이 없거나
      <classname>Properties</classname> 인스턴스가 <literal>null</literal>이라면
      빈 키 자체를 사용한다.</para>

      <para>아래 코드는 <classname>KeyNamingStrategy</classname>의 설정 예시를
      보여준다.</para>

      <programlisting language="xml"><![CDATA[<beans>

  <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="testBean" value-ref="testBean"/>
      </map>
    </property>
    <property name="namingStrategy" ref="namingStrategy"/>
  </bean>

  <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

  <bean id="namingStrategy" class="org.springframework.jmx.export.naming.KeyNamingStrategy">
    <property name="mappings">
      <props>
        <prop key="testBean">bean:name=testBean1</prop>
      </props>
    </property>
    <property name="mappingLocations">
      <value>names1.properties,names2.properties</value>
    </property>
  </bean>

</beans>]]></programlisting>

      <para>여기서 <classname>KeyNamingStrategy</classname> 인스턴스는 매핑 프로퍼티와
      매핑 프로퍼티에 정의된 경로에 있는 프로퍼티 파일로 정의된
      <classname>Properties</classname> 인스턴스와 합쳐진
      <classname>Properties</classname> 인스턴스로 구성된다. 이 구성에서
      <literal>testBean</literal> 빈은 <classname>ObjectName</classname>
      <literal>bean:name=testBean1</literal>을 받을 것이다. 이는 이 값이
      <classname>Properties</classname> 인스턴스에서 빈 키에 대응되는 키를 가진
      항목이기 때문이다.</para>

      <para><classname>Properties</classname> 인스턴스에 항목이 없다면 빈 키의 이름을
      <classname>ObjectName</classname>으로 사용한다.</para>
    </section>

    <section id="jmx-naming-metadata">
      <title><classname>MetadataNamingStrategy</classname>의 사용</title>

      <para><classname>MetadataNamingStrategy</classname>는
      <classname>ObjectName</classname>을 사용하기 위해 각 빈의
      <classname>ManagedResource</classname>속성의 <literal>objectName</literal>
      프로퍼티를 사용한다. 아래 코드는
      <classname>MetadataNamingStrategy</classname>의 설정 예시를 보여준다.</para>

      <programlisting language="xml"><![CDATA[<beans>

  <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="testBean" value-ref="testBean"/>
      </map>
    </property>
    <property name="namingStrategy" ref="namingStrategy"/>
  </bean>

  <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

  <bean id="namingStrategy" class="org.springframework.jmx.export.naming.MetadataNamingStrategy">
    <property name="attributeSource" ref="attributeSource"/>
  </bean>

  <bean id="attributeSource"
      class="org.springframework.jmx.export.metadata.AttributesJmxAttributeSource"/>

</beans>]]></programlisting>

      <para><classname>ManagedResource</classname> 속성에 제공된
      <literal>objectName</literal>이 없다면 <classname>ObjectName</classname>은
      <emphasis>[fully-qualified-package-name]:type=[short-classname],name=[bean-name]</emphasis>의
      형식으로 생성될 것이다. 예를 들어 다음 빈에 생성된 <classname>ObjectName</classname>은
      <emphasis>com.foo:type=MyClass,name=myBean</emphasis>가 될 것이다.
      </para>

      <programlisting language="xml"><![CDATA[<bean id="myBean" class="com.foo.MyClass"/>]]></programlisting>

    </section>

    <section id="jmx-context-mbeanexport">
      <title><literal>&lt;context:mbean-export/&gt;</literal> 요소</title>
      <para>Java 5 이상을 사용한다면 <classname>MBeanExporter</classname>의 편리한 하위
      클래스 <classname>AnnotationMBeanExporter</classname>를 사용할 수 있다. 이 하위
      클래스의 인스턴스를 정의하면 표준 자바 어노테이션 기반의 메타데이터를 항상 사용할 것이므로
      (자동탐지도 항상 활성화된다.) <literal>namingStrategy</literal>,
      <literal>assembler</literal>, <literal>attributeSource</literal> 설정이
      더는 필요 없다. 게다가 스프링의 '<literal>context</literal>' 네임스페이스가 지원하는
      더 간단한 문법도 가능하다. <classname>MBeanExporter</classname> 빈을 정의하는 대신
      다음의 요소를 지정하면 된다.</para>

      <programlisting language="xml"><![CDATA[<context:mbean-export/>]]></programlisting>

      <para>필요하다면 특정 MBean 서버에 대한 참조를 제공할 수도 있고
      <literal>defaultDomain</literal> 속성
      (<classname>AnnotationMBeanExporter</classname>의 프로퍼티)은 생성된 Mbean
      <classname>ObjectNames</classname>의 도메인의 대체 값을 받는다. 이전
      <link linkend="jmx-naming-metadata"><classname>MetadataNamingStrategy</classname></link>
      부분에서 설명한 대로 이는 정규화된 패키지 명에 사용한다.
      </para>

      <programlisting language="xml"><![CDATA[<context:mbean-export server="myMBeanServer" default-domain="myDomain"/>]]></programlisting>.

      <note>
        <para>빈(bean) 클래스에서 JMX 어노테이션의 자동탐지와 함께 인터페이스 기반의 AOP 프록시는 사용하지
        말아라. 인터페이스 기반의 프록시는 대상 클래스를 '숨기고' JMX가 관리하는 리소스 어노테이션도 숨긴다.
        그러므로 이러면 대상 클래스(target-class) 프록시를 사용해야 한다.
        <literal>&lt;aop:config/&gt;</literal>나
        <literal>&lt;tx:annotation-driven/&gt;</literal> 등의 'proxy-target-class' 플래그를
        설정하더라도 JMX 빈은 구동 시 이를 경고 없이 무시할 것이다.</para>
      </note>

    </section>
  </section>

  <section id="jmx-jsr160">
    <title>JSR-160 커넥터</title>

    <para>리모트 접근을 위해서 스프링 JMX 모듈은 서버 측과 클라이언트 측 커넥터를 생성하는
    <literal>org.springframework.jmx.support</literal> 패키지에서
    <classname>FactoryBean</classname>의 두 가지 구현체를 제공한다. </para>

    <section id="jmx-jsr160-server">
      <title>서버측 커넥터</title>

      <para>스프링 JMX가 JSR-160 <classname>JMXConnectorServer</classname>를
      생성해서 구동하고 노출하게 하려면 다음 설정을 사용해라.</para>

      <programlisting language="xml">&lt;bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean"/&gt;</programlisting>

      <para>기본적으로 <literal>ConnectorServerFactoryBean</literal>는
      <classname>JMXConnectorServer</classname>을
      <literal>"service:jmx:jmxmp://localhost:9875"</literal>에 바인딩해서 생성한다.
      그러므로 <literal>serverConnector</literal> 빈은
      <interfacename>MBeanServer</interfacename>를 localhost의 JMXMP 프로토콜과
      9875 포트로 노출한다. JMXMP 프로토콜은 JSR-160 명세에 선택사항으로 나와 있다. 현재로서는
      주요 오픈 소스 JMX 구현체인 MX4J와 J2SE 5.0이 제공하는 구현체가 JMXMP를 지원하지
      <emphasis>않는다</emphasis>.</para>

      <para>다른 URL을 지정해서 <classname>JMXConnectorServer</classname> 자체를
      <interfacename>MBeanServer</interfacename>에 등록하려면
      <literal>serviceUrl</literal>과 <classname>ObjectName</classname>
      프로퍼티를 각각 사용해라.</para>

      <programlisting language="xml"><![CDATA[<bean id="serverConnector"
      class="org.springframework.jmx.support.ConnectorServerFactoryBean">
  <property name="objectName" value="connector:name=rmi"/>
  <property name="serviceUrl"
            value="service:jmx:rmi://localhost/jndi/rmi://localhost:1099/myconnector"/>
</bean>]]></programlisting>

      <para><classname>ObjectName</classname> 프로퍼티를 설정하면 스프링이 해당
      <classname>ObjectName</classname>의
      <interfacename>MBeanServer</interfacename>에 커넥터를 자동으로 등록할 것이다.
      다음 예제는 JMXConnector 생성 시
      <classname>ConnectorServerFactoryBean</classname>에 전달할 수 있는 전체
      파라미터를 보여주고 있다.</para>

      <programlisting language="xml"><![CDATA[<bean id="serverConnector"
      class="org.springframework.jmx.support.ConnectorServerFactoryBean">
  <property name="objectName" value="connector:name=iiop"/>
  <property name="serviceUrl"
               value="service:jmx:iiop://localhost/jndi/iiop://localhost:900/myconnector"/>
  <property name="threaded" value="true"/>
  <property name="daemon" value="true"/>
  <property name="environment">
    <map>
      <entry key="someKey" value="someValue"/>
    </map>
  </property>
</bean>]]></programlisting>

      <para>RMI에 기반을 둔 커넥터를 사용한다면 이름 등록과정이 완료된 후 시작되도록 검색
      서비스(tnameserv나 rmiregistry)가 필요하다. RMI로 원격 서비스를 내보내도록 스프링을
      사용하고 있다면 스프링은 이미 RMI 레지스트리를 생성했을 것이다. RIM로 원격서비스를 내보내도록
      하고 있지 않다면 다음의 설정을 사용해서 간단하게 레지스트리를 시작할 수 있다.</para>

      <programlisting language="xml"><![CDATA[<bean id="registry" class="org.springframework.remoting.rmi.RmiRegistryFactoryBean">
  <property name="port" value="1099"/>
</bean>]]></programlisting>
    </section>

    <section id="jmx-jsr160-client">
      <title>클라이언트측 커넥터</title>

      <para>원격 JSR-160를 사용하는 <interfacename>MBeanServer</interfacename>에
      <classname>MBeanServerConnection</classname>를 생성하려면 다음과 같이
      <classname>MBeanServerConnectionFactoryBean</classname>를 사용해라.</para>

      <programlisting language="xml"><![CDATA[<bean id="clientConnector" class="org.springframework.jmx.support.MBeanServerConnectionFactoryBean">
  <property name="serviceUrl" value="service:jmx:rmi://localhost/jndi/rmi://localhost:1099/jmxrmi"/>
</bean>]]></programlisting>
    </section>

    <section id="jmx-jsr160-protocols">
      <title>Burlap/Hessian/SOAP에서의 JMX</title>

      <para>JSR-160은 클라이언트와 서버 간의 통신을 수행하는 방법에 확장 포인트를 허용하고 있다.
      앞의 예제는 JSR-160 명세에 명시된 의무적인 RMI 기반의 구현체(IIOP와 JRMP)와 (선택적인)
      JMXMP를 사용하고 있다. 다른 프로바이더나 JMX 구현체
      (<ulink url="http://mx4j.sourceforge.net">MX4J</ulink>와 같은)를 사용해서
      HTTP나 SSL등을 사용하는 SOAP, Hessian, Burlap 같은 프로토콜의 장점을 취할 수
      있다.</para>

      <programlisting language="xml"><![CDATA[<bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean">
  <property name="objectName" value="connector:name=burlap"/>
  <property name="serviceUrl" value="service:jmx:burlap://localhost:9874"/>
</bean>]]></programlisting>

      <para>앞의 예제에서는 MX4J 3.0.0을 사용했다. 자세한 내용은 MX4J 공식 문서를 참고해라.</para>
    </section>
  </section>

  <section id="jmx-proxy">
    <title>프록시를 통한 MBean 접근</title>

    <para>스프링 JMX에서는 로컬이나 원격 <interfacename>MBeanServer</interfacename>에
    등록된 MBean 호출을 다시 라우팅하는 프록시를 생성할 수 있다. 이러한 프록시는 MBean과 상호작용할
    수 있는 표준 자바 인터페이스를 제공한다. 다음 코드는 로컬
    <interfacename>MBeanServer</interfacename>에서 동작 중인 MBean에 대한 프록시를
    구성하는 방법을 보여준다.</para>

    <programlisting language="xml"><![CDATA[<bean id="proxy" class="org.springframework.jmx.access.MBeanProxyFactoryBean">
    <property name="objectName" value="bean:name=testBean"/>
    <property name="proxyInterface" value="org.springframework.jmx.IJmxTestBean"/>
</bean>]]></programlisting>

    <para><classname>ObjectName</classname>:
    <literal>bean:name=testBean</literal>으로 등록된 MBean에 프록시가 생성된 것을 볼
    수 있다. 프록시가 구현하는 인터페이스들은 <literal>proxyInterfaces</literal> 프로퍼티로
    제어하고 이 인터페이스들의 메서드와 프로퍼티를 MBean의 동작과 속성으로 매핑하는 규칙은
    <classname>InterfaceBasedMBeanInfoAssembler</classname>에서 사용한 규칙과
    동일하다.</para>

    <para><classname>MBeanProxyFactoryBean</classname>은
    <classname>MBeanServerConnection</classname>로 접근할 수 있는 모든 MBean에 대해서
    프록시를 생성할 수 있다. 기본적으로 로컬 <interfacename>MBeanServer</interfacename>를
    사용하지만 이를 오버라이드해서 원격 MBean을 가리키는 프록시에 대한 원격
    <interfacename>MBeanServer</interfacename>를 가리키는
    <classname>MBeanServerConnection</classname>를 제공할 수 있다.</para>

    <programlisting language="xml"><![CDATA[<bean id="clientConnector"
      class="org.springframework.jmx.support.MBeanServerConnectionFactoryBean">
  <property name="serviceUrl" value="service:jmx:rmi://remotehost:9875"/>
</bean>

<bean id="proxy" class="org.springframework.jmx.access.MBeanProxyFactoryBean">
  <property name="objectName" value="bean:name=testBean"/>
  <property name="proxyInterface" value="org.springframework.jmx.IJmxTestBean"/>
  <property name="server" ref="clientConnector"/>
</bean>]]></programlisting>

    <para>위 예제에서 <classname>MBeanServerConnectionFactoryBean</classname>를
    사용하는 원격 머신을 가리키는 <classname>MBeanServerConnection</classname>를 생성한
    것을 볼 수 있다. <literal>server</literal> 프로퍼티로 이
    <classname>MBeanServerConnection</classname>을
    <classname>MBeanProxyFactoryBean</classname>에 전달한다. 생성한 프록시는 이
    <classname>MBeanServerConnection</classname>를 사용해서 모든 호출을
    <interfacename>MBeanServer</interfacename>로 보낼 것이다.</para>
  </section>

  <section id="jmx-notifications">
    <title>알림(Notification)</title>

    <para>스프링의 JMX는 JMX 알림도 광범위하게 지원하고 있다.</para>

    <section id="jmx-notifications-listeners">
      <title>알림에 대한 리스너 등록</title>

      <para>스프링의 JMX는 다수의 MBean(이는 스프링의
      <classname>MBeanExporter</classname>가 내보낸 MBean과 다른 메커니즘으로 등록된
      MBean을 포함한다.)을 가진 다수의 <classname>NotificationListeners</classname>을
      아주 쉽게 등록할 수 있도록 지원한다. 예제를 통해서 대상 MBean의 속성이 변경될 때마다 알림을
      받는(<classname>Notification</classname>으로) 시나리오를 생각해 보자.</para>

      <programlisting language="java"><![CDATA[package com.example;

import javax.management.AttributeChangeNotification;
import javax.management.Notification;
import javax.management.NotificationFilter;
import javax.management.NotificationListener;

public class ConsoleLoggingNotificationListener
               implements NotificationListener, NotificationFilter {

    public void handleNotification(Notification notification, Object handback) {
        System.out.println(notification);
        System.out.println(handback);
    }

    public boolean isNotificationEnabled(Notification notification) {
        return AttributeChangeNotification.class.isAssignableFrom(notification.getClass());
    }
}]]></programlisting>

      <programlisting language="xml"><![CDATA[<beans>

  <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="bean:name=testBean1" value-ref="testBean"/>
      </map>
    </property>
    <property name="notificationListenerMappings">
      <map>
        <entry key="bean:name=testBean1">
          <bean class="com.example.ConsoleLoggingNotificationListener"/>
        </entry>
      </map>
    </property>
  </bean>

  <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

</beans>]]></programlisting>

		<para>위 설정에서 대상 MBean(<literal>bean:name=testBean1</literal>)이 JMX
    <classname>Notification</classname>를 브로드캐스트할 때마다
    <literal>notificationListenerMappings</literal> 프로퍼티에 리스너로 등록한
    <classname>ConsoleLoggingNotificationListener</classname> 빈이 알림을 받을
    것이다. <classname>ConsoleLoggingNotificationListener</classname> 빈은
    <classname>Notification</classname>의 응답으로 적절한 모든 액션을 받을 수
    있다.</para>

    <para>내보낸 빈과 리스너간의 연결로 빈 이름을 직접 사용할 수도 있다.</para>

		<programlisting language="xml"><![CDATA[<beans>

  <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="bean:name=testBean1" value-ref="testBean"/>
      </map>
    </property>
    <property name="notificationListenerMappings">
      <map>
        <entry key="]]><emphasis role="bold">testBean</emphasis><![CDATA[">
          <bean class="com.example.ConsoleLoggingNotificationListener"/>
        </entry>
      </map>
    </property>
  </bean>

  <bean id="]]><emphasis role="bold">testBean</emphasis><![CDATA[" class="org.springframework.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

</beans>]]></programlisting>

    <para><classname>MBeanExporter</classname>가 내보내는 모든 빈에 하나의
    <classname>NotificationListener</classname> 인스턴스를 등록하고 싶다면
    <literal>notificationListenerMappings</literal> 프로퍼티 맵의 엔트리에 키로
    <literal>'*'</literal> (따옴표 없이)를 와일드카드로 사용할 수 있다. 예를 들면 다음과 같다.</para>

		<programlisting language="xml"><![CDATA[<property name="notificationListenerMappings">
  <map>
    <entry key="*">
      <bean class="com.example.ConsoleLoggingNotificationListener"/>
    </entry>
  </map>
</property>]]></programlisting>

      <para>반대로 해야 한다면(즉, MBean에 다수의 리스너를 등록한다면)
      <literal>notificationListeners</literal> 리스트 프로퍼티(그리고
      <literal>notificationListenerMappings</literal> 프로퍼티에 대한 설정에)를 대신
      사용해야 한다. 이때 단일 MBean의 <classname>NotificationListener</classname>를
      설정하는 대신 <classname>NotificationListenerBean</classname> 인스턴스를 설정해라.
      <classname>NotificationListenerBean</classname>은
      <classname>NotificationListener</classname>와
      <classname>ObjectName</classname>(또는
      <classname>ObjectNames</classname>)을 은닉화하고 이는
      <interfacename>MBeanServer</interfacename>에 등록된다.
      <classname>NotificationListenerBean</classname>은
      <classname>NotificationFilter</classname>와 고급 JMX 알림 시나리오에서 사용할
      수 있는 임의의 handback 객체 같은 다수의 프로퍼티들도 은닉화한다.</para>

      <para><classname>NotificationListenerBean</classname> 인스턴스를 사용할 때의
      설정은 이전에 본 설정과 크게 다르지 않다.</para>

      <programlisting language="xml"><![CDATA[<beans>

  <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="bean:name=testBean1" value-ref="testBean"/>
      </map>
    </property>
    <property name="notificationListeners">
        <list>
            <bean class="org.springframework.jmx.export.NotificationListenerBean">
                <constructor-arg>
                    <bean class="com.example.ConsoleLoggingNotificationListener"/>
                </constructor-arg>
                <property name="mappedObjectNames">
                    <list>
                        <value>bean:name=testBean1</value>
                    </list>
                </property>
            </bean>
        </list>
    </property>
  </bean>

  <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

</beans>]]></programlisting>

      <para>위의 예제는 첫 알림 예제와 같다. <classname>Notification</classname>이
      발생할 때마다 handback 객체를 주고 해당
      <classname>NotificationFilter</classname>로 관련 없는
      <classname>Notifications</classname>을 필터링하기를 원한다고 해보자. (handback
      객체가 무엇이고 <classname>NotificationFilter</classname>가 무엇인지에 대해서는
      JMX 명세서(1.2)의 <literal>'The JMX Notification Model'</literal> 부분을
      참고하기 바란다.)</para>

      <programlisting language="xml"><![CDATA[<beans>

  <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="bean:name=testBean1" value-ref="testBean1"/>
        <entry key="bean:name=testBean2" value-ref="testBean2"/>
      </map>
    </property>
    <property name="notificationListeners">
        <list>
            <bean class="org.springframework.jmx.export.NotificationListenerBean">
                <constructor-arg ref="customerNotificationListener"/>
                <property name="mappedObjectNames">
                    <list>
                        ]]><lineannotation>&lt;!-- 별개의 두 MBean에서 받은 알림을 처리한다 --&gt;</lineannotation><![CDATA[
                        <value>bean:name=testBean1</value>
                        <value>bean:name=testBean2</value>
                    </list>
                </property>
                <property name="handback">
                    <bean class="java.lang.String">
                        <constructor-arg value="This could be anything..."/>
                    </bean>
                </property>
                <property name="notificationFilter" ref="customerNotificationListener"/>
            </bean>
        </list>
    </property>
  </bean>

  ]]><lineannotation>&lt;!-- <interfacename>NotificationListener</interfacename>와 <interfacename>NotificationFilter</interfacename> 인터페이스를 구현한다 --&gt;</lineannotation><![CDATA[
  <bean id="customerNotificationListener" class="com.example.ConsoleLoggingNotificationListener"/>

  <bean id="testBean1" class="org.springframework.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

  <bean id="testBean2" class="org.springframework.jmx.JmxTestBean">
    <property name="name" value="ANOTHER TEST"/>
    <property name="age" value="200"/>
  </bean>

</beans>]]></programlisting>
    </section>

    <section id="jmx-notifications-publishing">
      <title>알림 발행하기</title>

      <para>스프링은 <classname>Notifications</classname>을 받기 위한 등록뿐 아니라
      <classname>Notifications</classname>을 보내기 위한 등록도 지원한다.</para>

      <note>
        <para>이 부분은 <classname>MBeanExporter</classname>를 통해 MBean으로 노출된
        스프링이 관리하는 빈에 대해서만 관련된 부분이다. 이미 존재하거나 사용자가 정의한 모든
        MBean은 표준 JMX API를 사용해서 알림을 발행해야 한다.</para>
      </note>

      <para>스프링의 JMX 알림 발행 지원에서 핵심 인터페이스는
      <classname>NotificationPublisher</classname> 인터페이스다.
      (<literal>org.springframework.jmx.export.notification</literal> 패키지에
      정의되어 있다.) <classname>MBeanExporter</classname> 인스턴스를 통해서 MBean으로
      내보내질 모든 빈은 <classname>NotificationPublisher</classname> 인스턴스에 접근할
      수 있도록 <classname>NotificationPublisherAware</classname> 인터페이스를 구현할
      수 있다. <classname>NotificationPublisherAware</classname> 인터페이스는 해당
      빈이 <classname>Notifications</classname>을 발행하는 데 사용할 수 있는 간단한 setter
      메서드로 구현한 빈에 <classname>NotificationPublisher</classname> 인스턴스를
      제공한다.</para>

      <para><classname>NotificationPublisher</classname> 클래스의 Javadoc에 나온 대로
      <classname>NotificationPublisher</classname> 메커니즘으로 이벤트를 발행하면서
      관리되고 있는 빈은 어떤 알림 리스너 등에 대해서도 상태관리를 책임지지
      <emphasis>않는다</emphasis>. 스프링의 JMX 지원은 JMX 인프라스트럭처와 관련된 모든
      이슈의 처리를 담당한다. 애플리케이션 개발자가 해야 하는 일은
      <classname>NotificationPublisherAware</classname> 인터페이스를 구현하고 제공된
      <classname>NotificationPublisher</classname> 인스턴스를 사용해서 이벤트를 발행하는
      것뿐이다. 관리되는 빈이 <interfacename>MBeanServer</interfacename>에 등록된
      <emphasis>후에</emphasis> <classname>NotificationPublisher</classname>가
      설정된다는 점에 주의해라.</para>

      <para><classname>NotificationPublisher</classname> 인스턴스의 사용은 아주
      직관적이다. 그냥 <classname>Notification</classname> 인스턴스(또는
      <classname>Notification</classname>의 적절한 하위클래스의 인스턴스)를 만들고 발행할
      이벤트와 관련된 데이터로 알림을 만든 후
      <classname>NotificationPublisher</classname> 인스턴스의
      <methodname>sendNotification(Notification)</methodname>를 호출해서
      <classname>Notification</classname>을 전달하면 된다.</para>

      <para>아래의 간단한 예제를 보자. 이 시나리오에서 내보내진
      <classname>JmxTestBean</classname> 인스턴스는
      <literal>add(int, int)</literal>가 호출될 때마다
      <classname>NotificationEvent</classname>를 발행할 것이다.</para>

      <programlisting language="java"><![CDATA[package org.springframework.jmx;

import org.springframework.jmx.export.notification.NotificationPublisherAware;
import org.springframework.jmx.export.notification.NotificationPublisher;
import javax.management.Notification;

public class JmxTestBean implements IJmxTestBean, NotificationPublisherAware {

    private String name;
    private int age;
    private boolean isSuperman;
    private NotificationPublisher publisher;

    ]]><lineannotation>// 다른 getter와 setter는 생략했다</lineannotation><![CDATA[

    public int add(int x, int y) {
        int answer = x + y;
        this.publisher.sendNotification(new Notification("add", this, 0));
        return answer;
    }

    public void dontExposeMe() {
        throw new RuntimeException();
    }

    public void setNotificationPublisher(NotificationPublisher notificationPublisher) {
        this.publisher = notificationPublisher;
    }
}]]></programlisting>

      <para><classname>NotificationPublisher</classname> 인터페이스와 관련된 부분이
      모두 잘 동작한다는 점이 스프링의 JMX 지원을 좋은 점중 하나다. 하지만 클래스가 스프링과 JMX에
    모두 의존성을 갖게 된다는 단점이 있다. 언제나 그렇듯이 이에 대한 조언은 현실적인 조언뿐이다.
    <classname>NotificationPublisher</classname>이 제공하는 기능이 필요하고 스프링과 JMX에
    대한 의존성을 받아들일 수 있다면 사용해도 좋다.</para>
    </section>
  </section>

  <section id="jmx-resources">
    <title>추가 자료</title>

    <para>이번 장에서는 JMX에 대한 추가자료와 관련된 링크를 제공한다.</para>

    <itemizedlist>
      <listitem>
        <para>Sun사의 <ulink url="http://java.sun.com/products/JavaManagement/">JMX 홈페이지</ulink></para>
      </listitem>

      <listitem>
        <para><ulink url="http://jcp.org/aboutJava/communityprocess/final/jsr003/index3.html">JMX 명세서</ulink> (JSR-000003)</para>
      </listitem>

      <listitem>
        <para><ulink url="http://jcp.org/aboutJava/communityprocess/final/jsr160/index.html">JMX 원격 API 명세서</ulink> (JSR-000160)</para>
      </listitem>

      <listitem>
        <para><ulink url="http://mx4j.sourceforge.net/">MX4J
        홈페이지</ulink> (다양한 JMX 명세에 대한 오픈소스 구현체)</para>
      </listitem>

      <listitem>
        <para><ulink url="http://java.sun.com/developer/technicalArticles/J2SE/jmx.html">JMX 시작하기</ulink> - Sun에서 만든 소개글.</para>
      </listitem>
    </itemizedlist>
  </section>
</chapter>
