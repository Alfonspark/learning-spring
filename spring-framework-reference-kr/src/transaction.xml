<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="transaction">
  <title>트랜잭션 관리</title>

  <section id="transaction-intro">
    <title>스프링 프레임워크의 트랜잭션 관리 소개</title>

    <para>스프링 프레임워크를 사용하는 주목할 만한 이유중 하나가 광범위한 트랜잭션 지원이다. 
    스프링 프레임워크는 다음의 이점을 주는 트랜잭션 관리의 일관성있는 추상화를 제공한다.</para>

    <itemizedlist>
      <listitem>
        <para>Java Transaction API (JTA), JDBC, Hibernate, Java Persistence
        API (JPA), Java Data Objects (JDO)같은 여러 가지 트랜잭션 API간에 일관성있는 
        프로그래밍 모델</para>
      </listitem>

      <listitem>
        <para><link linkend="transaction-declarative">선언적인 트랜잭션 관리</link> 
        지원.</para>
      </listitem>

      <listitem>
        <para><link
        linkend="transaction-programmatic">프로그래밍적인</link> 트랜잭션 관리에 대해
        JTA 같은 복잡한 트랜잭션 API보다 더 간단한 API.</para>
      </listitem>

      <listitem>
        <para>스프링의 데이터 접근 추상화와의 뛰어난 통합.</para>
      </listitem>
    </itemizedlist>

    <para>스프링 프레임워크 트랜잭션의 가치와 기술을 다음의 섹션들에서 설명한다.(이번 장은 베스트 
    프렉티스, 어플리케이션 서버 통합, 일반적인 문제에 대한 해결책에 대한 설명도 포함하고 있다.)</para>

    <itemizedlist>
      <listitem>
        <para><link linkend="transaction-motivation">스프링 프레임워크의 트랜잭션 지원 
        모델의 장점</link>에서는 EJB의 컨테이너가 관리하는 트랜잭션(Container-Managed 
        Transactions, CMT)이나 하이버네이트같은 소유권이 있는 API(proprietary API)를 통해서 
        로컬 트랜잭션을 유도하도록 선택하는 대신에 스프링 프레임워크의 트랜잭션 추상화를 
        <emphasis>왜</emphasis> 사용해야 하는지 설명한다.</para>

        <!--The section (formerly called Motivation) does not mention Hibernate. It talks about local and global. TR: REVISED, PLS REVIEW added 'local' to the sentence-->
      </listitem>

      <listitem>
        <para><link linkend="transaction-strategies">스프링 프레임워크의 트랜잭션 추상화 
        이해하기</link>에서는 핵심 클래스를 설명하고 다양한 소스의 
        <interfacename>DataSource</interfacename> 인스턴스를 어떻게 설정하고 
        획득하는지 설명한다.</para>
      </listitem>

      <listitem>
        <para><link linkend="tx-resource-synchronization">리소스와 트랜잭션 
        동기화하기</link>에서는 리소스를 생성하고 재사용하고 적절히 정리하는 것을 어플리케이션 코드가 
        어떻게 보장하는지 설명한다.<!--Added above link and bullet item. TR: OK--></para>
      </listitem>

      <listitem>
        <para><link linkend="transaction-declarative">선언적인 트랜잭션 관리</link>에서는 
        선언적인 트랜잭션 관리에 대한 지원을 설명한다.</para>
      </listitem>

      <listitem>
        <para><link linkend="transaction-programmatic">프로그래밍적인 트랜잭션 
        관리</link>에서는 프로그래밍적인(즉, 명시적으로 코딩해서) 트랜잭션 관리에 대한 
        지원을 다룬다.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="transaction-motivation">
    <title>스프링 프레임워크의 트랜잭션 지원 모델의 장점<!--Renamed section to make it more to the point. TR: OK--></title>

    <para>전통적으로 Java EE 개발자들은 트랜잭션 관리의 두가지 선택권을 가졌다. 
    <emphasis>전역(global)</emphasis>이나 <emphasis>지역(local)</emphasis> 두가지 
    선택권 모두 난해한 제약을 가지고 있다. 전역 트랜잭션 관리와 지역 트랜잭션 관리는 다음 두 섹션에서 
    살펴보고 그 뒤에는 스프링 프레임워크의 트랜잭션 관리 지원이 전역과 지역 트랜잭션 모델의 제약사항을 
    어떻게 다루는지에 대한 설명이 이어진다.</para>

    <!--Gave global, local, and spring models their own sections. These need to be called out at a higher level, esp. Spring advantage! TR: OK-->

    <section>
      <title>전역 트랜잭션</title>

      <para>전역 트랜잭션은 보통 관계형 데이터베이스와 메시지 큐같은 여러가지 트랜잭션이 적용된 리소스로 
      작업할 수 있게 한다.어플리케이션 서버는 사용하기 어려운 API를 가진 JTA를 사용해서 전역 트랜잭션을 
      관리한다(부분적으로 예외모델 때문에). 게다가 보통 JNDI에서 JTA 
      <interfacename>UserTransaction</interfacename>을 얻어야 한다. 즉, JTA를 사용하기 위해 
      JNDI를 사용해야할 필요<emphasis>도</emphasis> 있다. JTA가 보통 어플리케이션 서버 환경에서만 
      사용할 수 있는 것처럼 전역 트랜잭션을 사용하면 분명히 어플리케이션 코드의 재사용 가능성을 
      제한한다.</para>

      <para>이전에 전역 트랜잭션을 사용하는데 선호하는 방법은 EJB <emphasis>CMT</emphasis> 
      (<emphasis>Container Managed Transaction</emphasis>)를 사용하는 것이었다. CMT는 
      <emphasis role="bold">선언적인 트랜잭션 관리</emphasis> (<emphasis role="bold">
      프로그래밍적인 트랜잭션 관리</emphasis>와는 구분되는)의 형식이다. 물론 EJB를 사용하면 JNDI의 
      사용해야 함에도 불구하고 EJB CMT는 트랜잭션과 관련된 JNDI 검색의 필요성을 제거한다. 대부분을 
      제거하지만 트랜잭션을 관리하는 자바 코드를 전혀 작성하지 않아도 되는 것은 아니다. 또한, EJB에서 
      비즈니스 로직을 구현하기로 한 경우에만 이용할 수 있다.(최소한 트랜잭션이 적용된 EJB 퍼사드(facade) 
      뒤에서) 특히 선언적인 트랜잭션 관리에 대한 설득력있는 대안임에도 불구하고 보통 EJB의 안좋은 점은 
      꽤 많다.(매력적인 제안은 아니다.)</para>
    </section>

    <section>
      <title>지역 트랜잭션</title>

      <para>지역 트랜잭션은 JDBC 연결과 연관된 트랜잭션같은 리소스에 한정적이다. 지역 트랜잭션은 
      사용하기가 더 쉽지만 중요한 단점을 가지고 있다. 지역 트랜잭션은 트랜잭션이 적용된 여러 리소스에 
      걸쳐서 동작할 수 없다. 예를 들어 JDBC 연결을 사용하는 트랜잭션을 관리하는 코드는 전역 JTA 
      트랜잭션 내에서 실행될 수 없다. 어플리케이션 서버가 트랜잭션 관리에 포함되지 않기 때문에 여러 
      리소스에 걸쳐서 정확함을 보장할 수 없다. (대부분의 어플리케이션이 하나의 트랜잭션 리소스를 
      사용한다는 것은 전혀 가치가 없다.) 또다른 단점은 지역 트랜잭션이 프로그래밍 모델에 
      침투적이라는 것이다.</para>
    </section>

    <section>
      <title>스프링 프레임워크의 일관성있는 프로그래밍 모델</title>

      <para>스프링은 전역 트랜잭션과 지역 트랜잭셩의 이러한 단점들을 해결한다. 스프링은 어플리케이션 
      개발자가 <emphasis>어떤 환경에서도</emphasis> <emphasis>일관적인</emphasis> 
      프로그래밍 모델을 사용하도록 해준다. 코드는 한번 작성하고 여러 환경에서 여러가지 트랜잭션 
      관리 전략의 이점을 얻을 수 있다. 스프링 프레임워크는 선언적인 트랜잭션 관리와 프로그래밍적인 
      트랜잭션 관리 둘다 제공한다. 대부분의 사용자들은 대부분에 경우에 권장하는 선언적인 트랜잭션 
      관리를 더 선호한다.</para>

      <!--Do you need to specify that Spring allows you to work with *multiple* transactional resourcess (as global transactions do)? TR: OK AS IS-->

      <para>프로그래밍적인 트랜잭션 관리에서 개발자들은 어떤 의존하는 트랜잭션 인프라에서라도 실행되는 
      스프링 프레임워크 트랜잭션 추상화로 작업한다. <!--Re preceding statement, does this mean that next section re transaction abstraction applies only to programmatic tx management?If so--><!--shouldn't the next section be subsection of *Programmatic transaction management* section? However, there is a sentence in the next--><!--section that reads *regardless of whether you opt for declarative or prog. tx man. defining correct PlatformTransactionManager impl. is--><!--absolutely essential.* This is followed by discussion of that impl. So I'm not sure what goes where.

TR: OK AS IS - I think it's fine as is - the concepts apply to both programmatic and declarative transactions
-->선호하는 선언적인 모델에서는 개발자들은 보통 트랜잭션 관리와 관련된 약간의 코드를 작성하거나 전혀 
      작성하지 않으므로 스프링 프레임워크의 트랜잭션 API나 다른 트랜잭션 API에 의존하지 
      않는다.</para>

      <sidebar>
        <title>트랜잭션 관리를 위해서 어플리케이션 서버가 필요한가?</title>

        <para>스프링 프레임워크의 트랜잭션 관리 지원은 엔터프라이즈 자바 어플리케이션이 어플리케이션 
        서버를 필요로 하는 경우와 같은 전통적인 규칙을 바꾸었다.</para>

        <para>특히, EJB를 통한 선언적인 트랜잭션에 어플리케이션 서버가 필요없다. 사실 어플리케이션   
        서버가 강력한 JTA 기능을 가지고 있지만 스프링 프레임워크의 선언적인 트랜잭션이 EJB CMT보다 
        더 강력하고 더 생산적인 프로그래밍 모델을 제공하도록 할 수 있다.</para>

        <para>일반적으로 많은 어플리케이션의 요구사항은 아니지만 어플리케이션이 여러 리소스에 걸쳐서 
        트랜잭션을 다루어야 할 때만 어플리케이션 서버의 JTA 기능이 필요하다. 많은 하이엔드 어플리케이션은 
        대신에 높은 확장성을 가진 하나의 데이터베이스를 사용한다.(오라클 RAC같은) <ulink 
        url="http://www.atomikos.com/">Atomikos Transactions</ulink>와 <ulink 
        url="http://jotm.objectweb.org/">JOTM</ulink>같은 단독 트랜잭션 매니저는 또다른 
        선택사항이다. 물론 Java Message Service (JMS)와 J2EE Connector Architecture 
        (JCA)같은 다른 어플리케이션 서버 기능이 필요할 것이다.</para>

        <para>스프링 프레임워크는 <emphasis>어플리케이션을 완전히 로딩된 어플리케이션 서버에 
        확장할 때 선택권을 준다.</emphasis> JDBC 연결에 지역 트랜잭션으로 코드를 작성하는 것이 
        EJB CMT나 JTA의 유일한 대안이어서 전역이면서 컨테이너가 관리하는 트랜잭션내에서 실행되는 
        코드가 필요할 때 대대적 변경을 해야하던 시절은 갔다. 스프링 프레임워크에서는 코드가 아니라 
        설정 파일의 빈 정의 중 일부만 변경하면 된다.</para>

        <!--CLarify last sentence. Only what kind of configuration has to change? 
TR: REVISED, PLS REVIEW - changed to say "some of the bean definitions in your configuration file"-->
      </sidebar>
    </section>
  </section>

  <section id="transaction-strategies">
    <title>스프링 프레임워크의 트랜잭션 추상화 이해하기<!--If this section applies only to prog. tx management, we should say that up front. Add info? 
TR: OK AS IS - It's relevant for declarative tx as well--></title>

    <para>스프링 트랜잭션 추상화의 핵심은 <emphasis>트랜잭션 전략</emphasis>의 개념이다. 
    트랜잭션 전략은 
    <interfacename>org.springframework.transaction.PlatformTransactionManager</interfacename> 
    인터페이스가 정의한다.</para>

    <programlisting language="java">public interface PlatformTransactionManager {

  TransactionStatus getTransaction(TransactionDefinition definition)
    throws TransactionException;

  void commit(TransactionStatus status) throws TransactionException;

  void rollback(TransactionStatus status) throws TransactionException;
}</programlisting>

    <para>어플리케이션 코드에서 <link 
    linkend="transaction-programmatic-ptm">프로그래밍적으로</link> 사용할 수 있더라도 이는 
    주로 서비스 프로바이더 인터페이스(service provider interface, SPI)다. <!--Write out SPI with SPI in parentheses. SPI stands for a number of different things.And does logic of sentence make sense? 
TR: REVISED, PLS REVIEW - spelled SPI out and added a bit of clarification at the end-->
    <interfacename>PlatformTransactionManager</interfacename>가 <emphasis>인터페이스</emphasis>이기 
    때문에 필요하다면 쉽게 모킹하거나 스터빙(stub)할 수 있다. 이는 JNDI같은 검색 전략에 의존하지 않는다. 
    <interfacename>PlatformTransactionManager</interfacename> 구현체는 스프링 프레임워크 
    IoC 컨테이너의 다른 객체(또는 빈)처럼 정의한다. 이러한 이점은 JTA로 작업할 때조차도 스프링 프레임워크 
    트랜잭션을 훌륭한 추상화로 만들어준다. 트랜잭션이 적용된 코드는 JTA를 직접 사용하는 것보다 훨씬 쉽게 
    테스트할 수 있다.</para>

    <para>다시 스프링 철학과 일치하도록 <interfacename>PlatformTransactionManager</interfacename> 
    인터페이스의 어떤 메서드라도 던질 수 있는 <exceptionname>TransactionException</exceptionname>은 
    <emphasis>언체크드(unchecked)</emphasis>이다. (즉, 이는 
    <exceptionname>java.lang.RuntimeException</exceptionname> 클래스를 확장한다.) 
    트랜잭션 인프라스트럭처의 실패는 거의 예외없이 치명적이다. 어플리케이션 코드가 트랜잭션 실패를 실제로 
    복구할 수 있는 드문 경우에 어플리케이션 개발자는 여전히 
    <exceptionname>TransactionException</exceptionname>를 잡아서 다룰 수 있다. 개발자가 
    이렇게 하도록 <emphasis>강제하지</emphasis> 않는다는 것이 두드러진 점이다.</para>

    <para><methodname>getTransaction(..)</methodname> 메서드는 
    <interfacename>TransactionDefinition</interfacename> 파라미터에 따라 
    <interfacename>TransactionStatus</interfacename> 객체를 반환한다. 반환된 
    <interfacename>TransactionStatus</interfacename>는 새로운 트랜잭션을 나타내거나 
    현재 콜스택에 존재하는 트랜잭션 중 일치하는 것이 있다면 존재하는 트랜잭션을 나타날 수 있다. 후자의 
    경우는 Java EE 트랜잭션 컨텍스트처럼 <interfacename>TransactionStatus</interfacename>가 
    실행 <emphasis role="bold">스레드</emphasis>와 연결되었다는 것을 암시한다.<!--Previous sentences were difficult to follow because of all the parenthetical phrases.Revise if necessary. TR: OK AS IS--></para>

    <para><interfacename>TransactionDefinition</interfacename> 인터페이스는 다음을 
    지정한다.</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">격리(Isolation)</emphasis>: 해당 트랜잭션이 다른 
        트랜잭션의 작업과 격리되는 정도. 예를 들어 해당 트랜잭션이 다른 트랜잭션에서 아직 커밋되지 
        않은 쓰기작업을 볼 수 있는가?</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">전파(Propagation)</emphasis>: 보통 트랜잭션 
        범위내에서 실행되는 모든 코드는 해당 크랜잭션에서 실행될 것이다. 하지만 트랜잭션 컨텍스트가 
        이미 존재하는 경우 트랜잭션이 적용된 메서드가 실행할 때의 동작을 지정하는 옵션이 
        있다. <!--Correct to say you have options? A human has to specify what the behavior will be, right? TR: REVISED, PLS REVIEW-->
        예를 들어 코드를 존재하는 트랜잭션 (일반적인 경우)에서 계속 실행할 수 있다. 또는 존재하는 
        트랜잭션을 일시정지하고 새로운 트랜잭션을 생성할 수도 있다. <emphasis>스프링은 EJB CMT에서 
        익숙한 모든 트랜잭션 전파 옵션을 제공한다.</emphasis> 스프링의 트랜잭션 전파의 의미를 
        읽어보려면 <xref linkend="tx-propagation" />를 참고해라.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">시간만료(Timeout)</emphasis>: 시간이 
        만료되기 전에 해당 트랜잭션이 얼마나 오랫동안 실행되고 의존 트랜잭션 인프라스트럭처가 
        자동으로 롤백하는 지를 나타낸다.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">읽기 전용 상태(Read-only status)</emphasis>: 코드가 
        데이터를 읽기는 하지만 수정하지는 않는 경우 읽기 전용 트랜잭션을 사용할 수 있다. 읽기 전용 트랜잭션은 
        하이버네이트를 사용하는 경우처럼 몇가지 경우에 유용한 최적화가 될 수 있다.</para>

        <!--describes status but we could say 'reads but does not modify' I added that it describes status. OK? Elaborate on purpose?
TR:REVISED, PLS REVIEW-->
      </listitem>
    </itemizedlist>

    <para>이러한 설정은 표준 트랜잭션 개념을 반영한다. 필요하다면 트랜잭션 격리 수준과 다른 핵심 
    트랜잭션 개념에 대한 설명을 참고해라. 스프링 프레임워크나 다른 트랜잭션 관리 솔루션을 사용할 때 
    이러한 개념을 이해하는 것이 핵심이다.</para>

    <para><interfacename>TransactionStatus</interfacename> 인터페이스는 트랜잭션 
    실행을 제어하고 트랜잭션 상태를 조회하는 트랜잭션 코드에 대한 간단한 방법을 제공한다. 이 개념은 
    모든 트랜잭션 API에 일반적이므로 익숙해져야 한다.</para>

    <programlisting language="java">public interface TransactionStatus extends SavepointManager {

    boolean isNewTransaction();

    boolean hasSavepoint();

    void setRollbackOnly();

    boolean isRollbackOnly();

    void flush();

    boolean isCompleted();

}</programlisting>

    <para>스프링에서 선언적인 트랜잭션 관리나 프로그래밍적인 트랜잭션 관리 중에 어느 것을 선택했는지에 
    관계없이 제대로된 <interfacename>PlatformTransactionManager</interfacename> 구현체를 
    정의하는 것이 정말로 가장 중요하다. 보통은 의존성 주입으로 이 구현체를 정의한다.</para>

    <!--Do you need a link to an explanation of DI?
    TR: OK AS IS - at this point in the text, I don't think you would need that
    -->

    <para><interfacename>PlatformTransactionManager</interfacename> 구현체는 
    일반적으로 JDBC, JTA, Hibernate 등과 같은 동작하는 환경에 대한 지식을 필요로 한다. 다음의 
    예제는 어떻게 지역 <interfacename>PlatformTransactionManager</interfacename> 
    구현체를 정의할 수 있는지 보여준다.(이 예제는 평범한 JDBC에서 동작한다.)</para>

    <para>JDBC <interfacename>DataSource</interfacename>를 정의한다.</para>

    <programlisting language="xml">&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
  &lt;property name="driverClassName" value="${jdbc.driverClassName}" /&gt;
  &lt;property name="url" value="${jdbc.url}" /&gt;
  &lt;property name="username" value="${jdbc.username}" /&gt;
  &lt;property name="password" value="${jdbc.password}" /&gt;
&lt;/bean&gt;</programlisting>

    <para>관련된 <interfacename>PlatformTransactionManager</interfacename> 빈 정의는 
    <interfacename>DataSource</interfacename> 정의에 대한 참조를 가질 것이다. 
    이는 다음과 같을 것이다.</para>

    <programlisting language="xml">&lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
  &lt;property name="dataSource" ref="dataSource"/&gt;
&lt;/bean&gt;</programlisting>

    <para>Java EE 컨테이너에서 JTA를 사용하면 JNDI로 획득한 컨테이너 
    <interfacename>DataSource</interfacename>를 스프링의 
    <classname>JtaTransactionManager</classname>와 결합해서 사용한다. 
    JTA와 JNDI 검색예제는 다음과 같을 것이다.</para>

    <!--Indicate what the following example demonstrates.What is its purpose? TR: REVISED, PLS REVIEW-->

    <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:jee="http://www.springframework.org/schema/jee"
     xsi:schemaLocation="
     http://www.springframework.org/schema/beans 
     http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
     http://www.springframework.org/schema/jee 
     http://www.springframework.org/schema/jee/spring-jee-3.0.xsd"&gt;

  &lt;jee:jndi-lookup id="dataSource" jndi-name="jdbc/jpetstore"/&gt; 

  &lt;bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager" /&gt;
  
  <lineannotation>&lt;!-- 다른 <literal>&lt;bean/&gt;</literal> 정의는 여기에 정의한다 --&gt;</lineannotation>

&lt;/beans&gt;</programlisting>

    <para><classname>JtaTransactionManager</classname>는 컨테이너의 전역 트랜잭션 
    관리 인프라스트럭처를 사용하기 때문에 <interfacename>DataSource</interfacename>나 
    다른 특정 리소스에 대해서 알 필요가 없다.</para>

    <note>
      <para>위의 <literal>dataSource</literal> 빈의 정의는 <literal>jee</literal> 
      네임스페이스의 <literal>&lt;jndi-lookup/&gt;</literal> 태그를 사용한다. 스키마기반 
      설정에 대한 더 자세한 정보는 <xref linkend="xsd-config" />를 참고하고 
      <literal>&lt;jee/&gt;</literal> 태그에 대한 자세한 정보는 
      <xref linkend="xsd-config-body-schemas-jee" /> 부분을 참고해라.</para>
    </note>

    <para>다음 예제에서 보듯이 하이버네이트 지역 트랜잭션도 쉽게 사용할 수 있다. 이 경우에 
    어플리케이션 코드가 하이버네이트 <interfacename>Session</interfacename> 인스턴스를 
    획득하기 위해서 사용할 하이버네이트 <classname>LocalSessionFactoryBean</classname>를 
    정의해야 한다.</para>

    <para><interfacename>DataSource</interfacename> 빈 정의는 앞에서 본 지역 JBDC 
    예제와 유사하므로 다음 예제에는 나와있지 않다.</para>

    <!-- TR: added the following clarification rather than embed it in the text above-->

    <note>
      <para>JTA가 아닌 트랜잭션 관리자가 사용하는 <interfacename>DataSource</interfacename>가 
      JNDI로 검색되고 Java EE 컨테이너가 관리된다면 Java EE 컨테이너가 아닌 스프링 프레임워크가 
      트랜잭션을 관리할 것이므로 <interfacename>DataSource</interfacename>는 트랜잭션이 
      적용되지 않을 것이다.</para>
    </note>

    <para>이 클래스의 <literal>txManager</literal>는 
    <classname>HibernateTransactionManager</classname> 타입이다. 
    <classname>DataSourceTransactionManager</classname>가 
    <interfacename>DataSource</interfacename>에 대한 참조를 필요로 하는 것과 같은 
    방법으로 <classname>HibernateTransactionManager</classname>는 
    <interfacename>SessionFactory</interfacename>에 대한 참조를 필요로 한다.</para>

    <programlisting language="xml">&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;
  &lt;property name="dataSource" ref="dataSource" /&gt;
  &lt;property name="mappingResources"&gt;
  &lt;list&gt;
    &lt;value&gt;org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml&lt;/value&gt;
  &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="hibernateProperties"&gt;
    &lt;value&gt;
      hibernate.dialect=${hibernate.dialect}
    &lt;/value&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="txManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
  &lt;property name="sessionFactory" ref="sessionFactory" /&gt;
&lt;/bean&gt;</programlisting>

    <para>하이버네이트와 Java EE 컨테이너가 관리하는 JTA 트랜잭션을 사용한다면 앞에서 제공한 
    JDBC에 대한 JTA 예제와 같은 <classname>JtaTransactionManager</classname>를 
    사용해야 한다.<!--Use it to do what? Below, this *what* is identical to JTA config
     TR: REVISED, PLS REVIEW - I clarified this a bit
    --></para>

    <programlisting language="xml">&lt;bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;</programlisting>

    <note>
      <para>JTA를 사용한다면 트랜잭션 관리자 정의는 JDBC, Hibernate, JPA나 다른 지원 기술 등 
      어떤 데이터접근 기술을 사용한지와 상관없이 같을 것이다. 이는 JTA 트랜잭션이 트랜잭션이 적용된 
      어떤 리소스와도 동작하는 전역 트랜잭션이기 때문이다.</para>
    </note>

    <para>이러한 모든 경우에 어플리케이션 코드는 변경할 필요가 없다. 지역 트랜잭션을 전역 트랜잭션으로 
    바꾸거나 전역 트랜잭션을 지역 트랜잭션을 바꾸어야 하더라도 그냥 설정을 변경해서 트랜잭션을 어떻게 
    관리하는지만 변경할 수 있다.</para>
  </section>

  <section id="tx-resource-synchronization">
    <title>리소스와 트랜잭션 동기화하기</title>

    <para>이제 어떻게 다른 트랜잭션 관리자들을 생성하고 어떻게 이 관리자들이 트랜잭션과 
    동기화해야하는 관련 리소스에 연결되는 지(예를 들어 JDBC 
    <interfacename>DataSource</interfacename>에 
    <classname>DataSourceTransactionManager</classname>이나 하이버네이트 
    <interfacename>SessionFactory</interfacename>에 
    <classname>HibernateTransactionManager</classname> 등등)가 명확해 질 것이다. 
    이번 섹션에서는 JDBC, 하이버네이트, JDO같은 퍼시스턴스 API를 직접 혹은 간접적으로 사용하는 
    어플리케이션 코드가 이러한 리소스들이 적절히 생성되고 재사용되고 정리된다는 것을 어떻게 보장하는지 
    설명한다. 그리고 이번 섹션에서는 관련 <interfacename>PlatformTransactionManager</interfacename>를 
    통해서 어떻게 트랜잭션 동기화가 실행되는지(선택적으로)를 설명한다.<!--I broke into two sentences. Last part of sentence unclear,revise to say what triggers tx synch. Revise sentences if necessray. TR: OK--></para>

    <section id="tx-resource-synchronization-high">
      <title>고수준 동기화 접근</title>

      <para>스프링의 최고수준 템플릿에 기반한 퍼시스턴스 통합 API를 사용하거나 네이티브 리소스 팩토리를 
      관리하기 위해 transaction-을 인지하는 팩토리빈이나 프록시를 가진 네이티브 ORM을 사용하는 접근을 
      선호한다. 트랜잭션 친화적인(transaction-aware) 솔루션들은 내부적으로 리소스 생성, 재사용, 정리, 
      선택적으로 리소스의 트랜잭션 동기화, 예외 맵핑을 다룬다. 그러므로 사용자 데이터에 접근하는 코드는 이러한 
      작업에는 포함되지 않지만 보일러플레이트가 아닌 퍼시스턴스 로직에만 순수하게 집중할 수 있다. 보통 네이티브 
      ORM API를 사용하거나 <classname>JdbcTemplate</classname>를 사용해서 JDBC 접근에 대한 
      <emphasis>템플릿</emphasis> 접근을 취한다. 이러한 솔루션들은 이 레퍼런스 문서의 다음 장에서 자세히 설명한다.<!--If this approach is preferred, why not give examples here as you do with less desirable approaches? At least provide--><!--x-refs? Also is it correct to refer to APIs, then give classes as examples? Should this be reworded?
TR: REVISED, PLS REVIEW - I re-wrote this to match the current preferred approaches--></para>
    </section>

    <section id="tx-resource-synchronization-low">
      <title>저수준 동기화 접근</title>

      <para><classname>DataSourceUtils</classname> (JDBC를 위한),
      <classname>EntityManagerFactoryUtils</classname> (JPA를 위한),
      <classname>SessionFactoryUtils</classname> (Hibernate를 위한),
      <classname>PersistenceManagerFactoryUtils</classname> (JDO를 위한) 등과 같은 
      클래스들은 저수준으로 존재한다. 어플리케이션 코드가 네이티브 퍼시스턴스 API의 리소스 타입을 직접 
      다루기 원한다면 스프링 프레임워크가 관리하는 적절한 인스턴스를 획득하고 트랜잭션이 (선택적으로) 
      동기화되고 프로세스에서 발생한 예외를 일관성있는 API에 적절히 맵핑하도록 이러한 클래스들을 
      사용한다.</para>

      <para>예를 들어 JDBC의 경우 <interfacename>DataSource</interfacename>에서 
      <literal>getConnection()</literal> 메서드를 호출하는 전통적인 JDBC 접근대신에 
      다음과 같이 스프링의 
      <classname>org.springframework.jdbc.datasource.DataSourceUtils</classname>를 
      사용한다.</para>

      <programlisting language="java">Connection conn = DataSourceUtils.getConnection(dataSource);</programlisting>

      <para>이미 존재하는 트랜잭션이 동기화된(연결된, linked) 연결을 가지고 있다면 해당 인스턴스를 
      반환한다. 그렇지 않으면 이 메서드 호출은 (선택적으로) 이미 존재하는 트랜잭션에 동기화된 새로운 
      연결을 생성하고 같은 트랜잭션에서 이어서 재사용할 수 있게 한다. 이미 언급했듯이 모든 
      <exceptionname>SQLException</exceptionname>는 스프링 프레임워크의 언체크드(unckecked) 
      DataAccessExceptions 계층 중 하나인 
      <exceptionname>CannotGetJdbcConnectionException</exceptionname>로 감싸진다. 
      이 접근은 <exceptionname>SQLException</exceptionname>로 쉽게 얻을 수 있는 것보다 
      더 많은 정보를 주고 다른 퍼시스턴스 기술을 사용하더라도 데이터베이스간에 이식성(portability)을 
      보장한다.</para>

      <para>이 접근은 스프링 트랜잭션 관리(트랜잭션 동기화는 선택적이다)이 없이도 동작하기 때문에 
      트랜잭션 관리에 스프링을 사용하는지와 상관없이 사용할 수 있다.</para>

      <para>물론 일단 스프링의 JDBC 지원이나 JPA 지원, 하이버네이트 지원을 사용했다면 
      <classname>DataSourceUtils</classname>나 다른 헬러 클래스는 보통 사용하려고 하지 
      않을 것이다. 왜냐하면 관련된 API를 직접 사용하는 것보다 스프링 추상화를 통해서 작업하는 것이 
      훨씬 좋을 것이기 때문이다. 예를 들어 JDBC의 사용을 간소화하려고 스프링의 
      <classname>JdbcTemplate</classname>나 <literal>jdbc.object</literal> 패키지를 
      사용한다면 올바른 연결 검색은 보이지 않게 이뤄지고 특별한 코드를 작성할 필요가 없다.</para>

      <!--I don't understand this. Why tell them to use DataSourceUtils and then say you will prefer Spring abstraction? 
Why not give example of using Spring abstraction? 
TR: OK AS IS - it's not the prefered way, but we need to cover this if someine decideds to use it-->
    </section>

    <section id="tx-resource-synchronization-tadsp">
      <title><classname>TransactionAwareDataSourceProxy</classname></title>

      <para>가장 최저계층에 <classname>TransactionAwareDataSourceProxy</classname> 
      클래스가 존재한다. 이 클래스는 스프링이 관리하는 트랜잭션을 인지하도록 대상 
      <interfacename>DataSource</interfacename>를 감싸는 프록시이다. 이 관점에서는 Java EE 
      서버가 제공하는 것처럼 트랜잭션이 적용된 JNDI <interfacename>DataSource</interfacename>와 
      유사하다.<!--What is the purpose of TransactionAwareDataSourceProxy, do you use it instead of 4.2 or 4.1 approaches or in addition to?
TR: OK AS IS - it's and additional tool, rarely used, but needs to be documented--></para>

      <para>기존의 코드가 호출되어서 표준 JDBC <interfacename>DataSource</interfacename> 
      인터페이스 구현체를 전달하는 경우를 제외하고는 이 클래스를 사용하는 것이 바람직하지 않거나 필수가 
      아니어야 한다. 이러한 경우에 이 코드는 사용가능하지만 스프링이 관리하는 트랜잭션에 포함된다. 위에서 
      언급한 더 높은 수준의 추상화를 사용해서 새로운 코드를 작성하는 것을 더 추천한다.</para>
    </section>
  </section>

  <section id="transaction-declarative">
    <title>선언적인 트랜잭션 관리</title>

    <note>
      <para>대부분의 스프링 프레임워크의 사용자들은 선언적인 트랜잭션 관리를 선택한다. 선언적인 
      트랜잭션 관리는 어플리케이션에 최소한으로 영향을 주므로 <emphasis>비침투적인</emphasis> 
      경량 컨테이터의 이상과 매우 일치한다.</para>
    </note>

    <para>트랜잭션이 적용된 관점 코드가 스프링 프레임워크 배포판에 포함되어 있고 보일러플레이트 
    방식으로 사용되는 것과 마찬가지로 보통 이 코드를 효율적으로 사용하는데 AOP의 개념을 이해해야 
    할 필요는 없지만 스프링 프레임워크의 선언적인 트랜잭션 관리는 스프링의 관점지향 프로그래밍(AOP)와 
    사용가능하도록 만들어졌다.</para>

    <para>스프링 프레임워크의 선언적인 트랜잭션 관리는 개별 메서드 수준에 트랜잭션 동작(또는 부족(lack))을 
    지정할 수 있는 EJB CMT와 비슷하다. 필요하다면 트랜잭션 컨텍스트내에서 
    <methodname>setRollbackOnly()</methodname>를 호출할 수 있다. 두 가지 트랜잭션 관리 
    종류사이의 차이점은 다음과 같다.</para>

    <itemizedlist>
      <listitem>
        <para>JTA와 묶인 EJB CMT와는 다르게 스프링 프레임워크의 선언적인 트랜잭션 관리는 어떤 
        환경에서도 동작한다. 선언적인 트랜잭션 관리는 단순히 설정파일을 조정함으로써 JTA 트랜잭션이나 
        JDBC, JPA, 하이버네이트, JDO를 사용하는 지역 트랜잭션과 동작할 수 있다.<!--Indicate what kind of config changes? Changes to what  
TR: REVISED, PLS REVIEW - rewrote this to hoefully make it more clear--></para>
      </listitem>

      <listitem>
        <para>스프링 프레임워크의 선언적인 트랜잭션 관리를 EJB같은 전용 클래스만이 아니라 
        어떤 클래스에도 적용할 수 있다.</para>
      </listitem>

      <listitem>
        <para>스프링 프레임워크는 EJB에는 없는 선언적인 <link
        linkend="transaction-declarative-rolling-back"><emphasis>롤백 
        규칙</emphasis></link> 기능을 제공한다. 프로그래밍적인 지원과 선언적인 지원 모두 
        롤백 규칙을 제공한다.</para>
      </listitem>

      <listitem>
        <para>스프링 프레임워크는 AOP를 사용해서 트랜잭션 동작을 커스터마이징 할 수 있게 해준다. 
        예를 들어 트랜잭션을 롤백하는 경우 커스턴 동작을 추가할 수 있다. 트랜잭션이 적용된 어드바이스 
        사이에 임의의 어드바이스를 추가할 수도 있다. EJB CMT에서는 
        <methodname>setRollbackOnly()</methodname>를 제외하고는 컨테이너의 트랜잭션 
        관리에 영향을 줄 수 없다.</para>
      </listitem>

      <listitem>
        <para>스프링 프레임워크 하이엔드 어플리케이션 서버가 지원하는 원격호출에 걸친 트랜잰션 
        컨텍스트의 전파를 지원하지 않는다. 이 기능이 필요하다면 EJB를 사용하기를 추천한다. 하지만 
        보통은 원격 호출에 걸친 트랜잭션을 원하지 않으므로 이러한 기능을 사용하기 전에 신중하게 
        고려해봐야 한다.</para>
      </listitem>
    </itemizedlist>

    <sidebar>
      <title>
      <classname>TransactionProxyFactoryBean</classname>는 어디에 있는가?</title>

      <para>스프링 2.0이상의 버전에서 선언적인 트랜잭션 설정은 그 이전 버전과는 상당히 다르다. 
      더이상 <classname>TransactionProxyFactoryBean</classname> 빈을 설정할 필요가 
      없다는 것이 가장 큰 차이점이다.</para>

      <para>스프링 2.0 이전의 설정방식은 여전히 100% 유효하다. 
      <classname>TransactionProxyFactoryBean</classname> 빈을 정의하는 것처럼 새로운 
      <literal>&lt;tx:tags/&gt;</literal>를 생각해 봐라.</para>
    </sidebar>

    <para>롤백 규칙의 개념은 중요한다. 롤백 규칙은 예외(그리고 throwable) <!--If no difference between exceptions and throwables, delete throwables. TR: OK AS IS-->이 
    자동으로 롤백을 수행해야한다고 지정할 수 있게 한다. 롤백 규칙은 자바 코드가 아니라 설정파일에 
    선언적으로 지정한다. 그러므로 현재 트랜잭션을 롤백하기 위해 
    <interfacename>TransactionStatus</interfacename> 객체에서 
    <methodname>setRollbackOnly()</methodname>을 호출할 수 있다고 하더라도 대부분 
    <exceptionname>MyApplicationException</exceptionname>이 항상 롤백의 결과가 된다는 
    규칙을 지정할 수 있다. 이 옵션의 중요한 이점은 해당 비즈니스 객체가 트랜잭션 인프라스트럭처에 
    의존하지 않는다는 것이다. 예를 들어 보통 비즈니스 객체들은 스프링 트랜잭션 API나 다른 스프링 
    API를 임포트할 필요가 없다.</para>

    <para>EJB 컨테이너의 기본 동작은 <emphasis>시스템 예외</emphasis> (보통 런타임 예외)에 
    자동으로 트랜잭션을 롤백하는 것이더라도 EJB CMT는 <emphasis>어플리케이션 예되</emphasis>에는 
    자동으로 트랜잭션을 롤백하지 않는다.(즉, <exceptionname>java.rmi.RemoteException</exceptionname>를 
    제외한 체크드 익셉션) 선언적인 트랜잭션 관리의 스프링 기본동작이 EJB 관례(언체크드 익센션에만 자동으로 
    롤백한다.)를 따르지만 스프링의 기본동작을 커스터마이징 하는 것은 종종 유용하다.</para>

    <!--customize this so that what happens? TR: OK AS IS - i think - the option is to provide alternate rules for when a transaction 
would be rolled back, not necessarily following the EJB rules-->

    <section id="tx-decl-explained">
      <title>스프링 프레임워크의 선언적인 트랜잭션 구현체 이해하기</title>

      <para>클래스에 <interfacename>@Transactional</interfacename> 어노테이션을 붙히는 
      것만으로는 충분하지 않고 설정에 트랜잭션 관련설정
      (<literal>&lt;tx:annotation-driven/&gt;</literal>)을 추가하고 어떻게 동작하는지 
      이해해야 한다. 이번 섹션에서는 트랜잭션과 관련된 이벤트에서 스프링 프레임워크의 선언적인 트랜잭션 
      인프라스트럭처의 내부 동작을 설명한다.</para>

      <para>스프링 프레임워크의 선언적인 트랜잭션 지원을 이해하는 가장 중요한 개념은 트랜잭션이 
      <link linkend="aop-understanding-aop-proxies"><emphasis>AOP 프록시를 
      통해서</emphasis></link> 활성화되고 <emphasis>메타데이터</emphasis>(현재는 XML기반이거나 
      어노테이션 기반)로 트랜잭션이 적용된 어드바이스가 유도(driven)된다는 것이다. 트랜잭션이 적용된 
      메타데이터와 AOP의 조합은 <emphasis>메서드 호출 주위에</emphasis> 트랜잭션을 유도하기 
      위해 적절한 <classname>PlatformTransactionManager</classname> 구현체와 결합한 
      <classname>TransactionInterceptor</classname>를 사용하는 AOP 프록시를 
      만든다.</para>

      <note>
        <para>스프링 AOP는 <xref linkend="aop" />에서 다루었다.</para>
      </note>

      <para>개념적으로 트랜잭션이 적용된 프록시에서 메서드를 호출하는 것은 다음과 같을 
      것이다...</para>

      <!--I don't see this image in src file or in pdf. Maybe it was added to src after pdf was created? 
TR: OK AS IS. images don't show up in the editor, but they do show up in the generated docs-->

      <para><mediaobject>
          <imageobject role="fo">
            <imagedata align="center" fileref="images/tx.png" format="PNG" />
          </imageobject>

          <imageobject role="html">
            <imagedata align="center" fileref="images/tx.png" format="PNG" />
          </imageobject>
        </mediaobject></para>
    </section>

    <section id="transaction-declarative-first-example">
      <title>선언적인 트랜잭션 구현체 예제</title>

      <para>다음의 인터페이스와 그 구현체를 보자. 이 예제는 플레이스홀더로 <classname>Foo</classname>와 
      <classname>Bar</classname> 클래스를 사용해서 특정 도메인 모델에 집중하지 않고 트랜잭션 사용에 
      집중할 수 있다. 이 예제의 목적을 위해 <classname>DefaultFooService</classname> 클래스는 
      구현된 각각의 메서드 바디에서 <exceptionname>UnsupportedOperationException</exceptionname> 
      인스턴스를 던진다는 사실은 좋다. 이는 생성된 트랜잭션을 보고 
      <exceptionname>UnsupportedOperationException</exceptionname> 인스턴스에 대한 
      응답으로 롤백할 수 있게 한다.
      </para>

      <programlisting language="java"><lineannotation>// 트랜잭션이 적용되기를 원하는 서비스 인터페이스</lineannotation>

package x.y.service;

public interface FooService {

  Foo getFoo(String fooName);

  Foo getFoo(String fooName, String barName);

  void insertFoo(Foo foo);

  void updateFoo(Foo foo);

}</programlisting>

      <programlisting language="java"><lineannotation>// 위 인터페이스의 구현체</lineannotation>

package x.y.service;

public class DefaultFooService implements FooService {

  public Foo getFoo(String fooName) {
    throw new UnsupportedOperationException();
  }

  public Foo getFoo(String fooName, String barName) {
    throw new UnsupportedOperationException();
  }

  public void insertFoo(Foo foo) {
    throw new UnsupportedOperationException();
  }

  public void updateFoo(Foo foo) {
    throw new UnsupportedOperationException();
  }

}</programlisting>

      <para><interfacename>FooService</interfacename> 인터페이스의 처음 두 메서드 
      <literal>getFoo(String)</literal>와 <literal>getFoo(String, String)</literal>가 
      읽기 적용 트랜잭션의 컨텍스트로 실행되어야 하고 다른 메서드들인 
      <literal>insertFoo(Foo)</literal>와 <literal>updateFoo(Foo)</literal>는 
      읽기-쓰기 트랜잭션 컨텍스트로 실행되어야 한다고 가정해 보자. 다름 설정은 이어진 두 문단에서 
      자세히 설명한다.</para>

      <programlisting language="xml"><lineannotation>&lt;!-- <literal>'context.xml'</literal>파일에서 --&gt;</lineannotation>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:aop="http://www.springframework.org/schema/aop"
     <lineannotation><emphasis role="bold">xmlns:tx="http://www.springframework.org/schema/tx"</emphasis></lineannotation>
     xsi:schemaLocation="
     http://www.springframework.org/schema/beans 
     http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
     <lineannotation><emphasis role="bold">http://www.springframework.org/schema/tx
     http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</emphasis></lineannotation>
     http://www.springframework.org/schema/aop 
     http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt;
  
  <lineannotation>&lt;!-- 트랜잭션이 적용되기를 원하는 서비스 객체 --&gt;</lineannotation>
  &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

  <lineannotation>&lt;!-- 트랜잭션이 적용된 어드바이스 (무슨 일이 발생하는 지는 아래의 <literal>&lt;aop:advisor/&gt;</literal> 빈을 봐라.) --&gt;</lineannotation>
  &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
  <lineannotation>&lt;!-- 트랜잭셔널 의미(the transactional semantics)... --&gt;</lineannotation>
  &lt;tx:attributes&gt;
    <lineannotation>&lt;!-- <literal>'get'</literal>으로 시작하는 모든 메서드들은 읽기전용이다 --&gt;</lineannotation>
    &lt;tx:method name="get*" read-only="true"/&gt;
    <lineannotation>&lt;!-- 다름 메서드들은 기본 트랜잭션 설정을 사용한다. (아래를 참고) --&gt;</lineannotation>
    &lt;tx:method name="*"/&gt;
  &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;
  
  <lineannotation>&lt;!-- 위의 <interfacename>FooService</interfacename> 인터페이스가 정의한 연산의 
    모든 실행에 트랜잭션이 적용된 어드바이스가 실행된다는 것을 보장한다. --&gt;</lineannotation>
  &lt;aop:config&gt;
  &lt;aop:pointcut id="fooServiceOperation" expression="execution(* x.y.service.FooService.*(..))"/&gt;
  &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/&gt;
  &lt;/aop:config&gt;
  
  <lineannotation>&lt;!-- <interfacename>DataSource</interfacename>를 잊지 마라 --&gt;</lineannotation>
  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
  &lt;property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/&gt;
  &lt;property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/&gt;
  &lt;property name="username" value="scott"/&gt;
  &lt;property name="password" value="tiger"/&gt;
  &lt;/bean&gt;

  <lineannotation>&lt;!-- 유사하게 <interfacename>PlatformTransactionManager</interfacename>도 잊지 마라 --&gt;</lineannotation>
  &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
  &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;
  
  <lineannotation>&lt;!-- 다른 <literal>&lt;bean/&gt;</literal> 정의는 여기에 정의한다 --&gt;</lineannotation>

&lt;/beans&gt;</programlisting>

      <para>앞의 설정을 검사해 봐라. 서비스 객체인 <literal>fooService</literal>에 트랜잭션을 
      적용하길 원한다. 적용할 트랜잭션 의미는 <literal>&lt;tx:advice/&gt;</literal> 정의에 
      감추어져 있다. <literal>&lt;tx:advice/&gt;</literal> 정의는 
      <quote><emphasis>... <literal>'get'</literal>로 시작하는 모든 메서드들은 읽기 전용 
      트랜잭션 컨텍스트로 설행하고 그외 모든 메서드들은 기본 트랜잭션 으로 실행한다</emphasis></quote>고 
      읽는다. <literal>&lt;tx:advice/&gt;</literal> 태그의 
      <literal>transaction-manager</literal> 속성은 트랜잭션을 <emphasis>유도할</emphasis> 
      <interfacename>PlatformTransactionManager</interfacename> 빈의 이름으로 설정한다. 
      (이 경우에는 <literal>txManager</literal> 빈이다.)</para>

      <tip>
        <para>연결하려는 <interfacename>PlatformTransactionManager</interfacename> 
        빈의 이름이 <literal>transactionManager</literal>라는 이름이라면 트랜잭션이 적용된 
        어드바이스(<literal>&lt;tx:advice/&gt;</literal>)에서 
        <literal>transaction-manager</literal> 속성을 생략할 수 있다. 연결하려는 
        <interfacename>PlatformTransactionManager</interfacename> 빈이 다른 이름이라면 
        앞의 예제처럼 명시적으로 <literal>transaction-manager</literal> 속성을 
        사용해야 한다.</para>
      </tip>

      <para><literal>&lt;aop:config/&gt;</literal> 정의는 <literal>txAdvice</literal> 
      빈이 정의한 트랜잭션이 적용된 어브바이스가 프로그램에서 적절한 지점에서 실행된다는 것을 보장한다. 먼저 
      <interfacename>FooService</interfacename> 인터페이스
      (<literal>fooServiceOperation</literal>)에서 정의한 연산(operation)의 실행과 일치하는 
      포인트컷을 정의한다. 그 다음 포인트컷을 어드바이저를 사용하는 <literal>txAdvice</literal>와 
      연결한다. 그 결과 <literal>fooServiceOperation</literal> 실행시에 
      <literal>txAdvice</literal>가 정의한 어드바이스가 실행될 것이다.</para>

      <para><literal>&lt;aop:pointcut/&gt;</literal> 요소에서 정의된 표현식은 AspectJ 
      포인트컷 표현식이다. 스프링 2.0의 포인트컷 표현식에 대한 자세한 내용은 
      <xref linkend="aop" />를 참고해라.</para>

      <para>공통적인 요구사항은 전체 서비스계층이 트랜잭션이 가능하게 만든다. 이렇게 하는 가장 좋은 방법은 
      포인트컷 표현식이 서비스계층의 모든 연산과 일치하도록 변경하는 것이다. 예를 들면 다음과 같다.</para>

      <programlisting language="xml">&lt;aop:config&gt;
  &lt;aop:pointcut id="fooServiceMethods" expression="execution(* x.y.service.*.*(..))"/&gt;
  &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceMethods"/&gt;
&lt;/aop:config&gt;</programlisting>

      <para><note>
          <para><emphasis>이 예제에서는 모든 서비스 인터페이스가 <literal>x.y.service</literal> 
          패키지에 정의되어 있다고 가정한다. 더 자세한 내용은 
          <xref linkend="aop" />를 참고해라.</emphasis></para>
        </note></para>

      <para>이제 설정을 살펴보았는데 아마 스스로 다음과 같은 질문을 할 것이다. 
      <quote><emphasis>좋아.. 근데 이 모든 설정은 실제로 무엇을 
      하지?</emphasis></quote></para>

      <para>위의 설정은 <literal>fooService</literal> 빈 정의에서 생성한 객체주위에 
      트랜잭션이 적용된 프록시를 생성하는데 사용할 것이다. <!--Clarify what you mean by around the object; do you mean associated with the object? Revise to clarify. Around is vague. 
TR: OK AS IS - around is used a lot in AOP, so I think the audience will understand this usage-->
      프록시는 트랜잭션이 적용된 어드바이스로 설정될 것이므로 <emphasis>프록시에서</emphasis> 적절한 
      메서드가 호출되었을 때 해당 메서드와 연관된 트랜잭션 설정에 따라 트랜잭션을 시작하거나 일시중지하거나 
      읽기전용으로 표시하는 등의 작업을 한다. 위의 설정을 테스트하는 다음의 프로그램을 살펴보자.</para>

      <programlisting language="java">public final class Boot {

  public static void main(final String[] args) throws Exception {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml", Boot.class);
    FooService fooService = (FooService) ctx.getBean("fooService");
    fooService.insertFoo (new Foo());
  }
}</programlisting>

      <para>앞의 프로그램을 실행한 출력은 다음과 같을 것이다. (Log4J 출력과 DefaultFooService 
      클래스의 insertFoo(..) 메서드가 던진 UnsupportedOperationException의 스택 트레이스는 
      명확함을 위해 생략했다.)</para>

      <programlisting language="xml">  <lineannotation><emphasis role="bold">&lt;!-- 스프링 컨테이너가 시작된다... --&gt;</emphasis></lineannotation>
[AspectJInvocationContextExposingAdvisorAutoProxyCreator] - Creating implicit proxy
    for bean 'fooService' with 0 common interceptors and 1 specific interceptors
  <lineannotation><emphasis role="bold">&lt;!-- <classname>DefaultFooService</classname>는 실제로 프록싱된다 --&gt;</emphasis></lineannotation>
[JdkDynamicAopProxy] - Creating JDK dynamic proxy for [x.y.service.DefaultFooService]

  <lineannotation><emphasis role="bold">&lt;!-- ... <literal>insertFoo(..)</literal> 메서드는 이제 프록시에서 호출된다 --&gt;</emphasis></lineannotation>

[TransactionInterceptor] - Getting transaction for x.y.service.FooService.insertFoo
  <lineannotation><emphasis role="bold">&lt;!-- 여기서 트랜잭션이 적용된 어드바이스를 만든다... --&gt;</emphasis></lineannotation>
[DataSourceTransactionManager] - Creating new transaction with name [x.y.service.FooService.insertFoo]
[DataSourceTransactionManager] - Acquired Connection
    [org.apache.commons.dbcp.PoolableConnection@a53de4] for JDBC transaction

  <lineannotation><emphasis role="bold">&lt;!-- <classname>DefaultFooService</classname>의 <literal>insertFoo(..)</literal> 메서드는 예외를 던진다... --&gt;</emphasis></lineannotation>
[RuleBasedTransactionAttribute] - Applying rules to determine whether transaction should
    rollback on java.lang.UnsupportedOperationException
[TransactionInterceptor] - Invoking rollback for transaction on x.y.service.FooService.insertFoo
    due to throwable [java.lang.UnsupportedOperationException]

   <lineannotation><emphasis role="bold">&lt;!-- 그리고 트랜잭션은 롤백된다.(기본값으로 <exceptionname>RuntimeException</exceptionname> 인스턴스를 롤백을 발생시킨다) --&gt;</emphasis></lineannotation>
[DataSourceTransactionManager] - Rolling back JDBC transaction on Connection
    [org.apache.commons.dbcp.PoolableConnection@a53de4]
[DataSourceTransactionManager] - Releasing JDBC Connection after transaction
[DataSourceUtils] - Returning JDBC Connection to DataSource

Exception in thread "main" java.lang.UnsupportedOperationException
    at x.y.service.DefaultFooService.insertFoo(DefaultFooService.java:14)
   <lineannotation><emphasis role="bold">&lt;!-- AOP 인프라스트럭처 스택 트레이스 요소는 명확함을 위해 제거했다 --&gt;</emphasis></lineannotation>
    at $Proxy0.insertFoo(Unknown Source)
    at Boot.main(Boot.java:11)</programlisting>
    </section>

    <section id="transaction-declarative-rolling-back">
      <title>선언적인 트랜잭션 롤백</title>

      <para>이전 섹션에서 어플리케이션에서 선언적으로 클래스(보통은 서비스계층의 클래스)에 트랜잭션 
      설정을 어떻게 지정하는가에 대한 기본적인 내용을 살펴보았다. 이 섹션은 간단한 선언적인 방법으로 
      트랜잭션의 롤백 제어를 어떻게 할 수 있는가를 설명한다.</para>

      <para>스프링 프레임워크의 트랜잭션 인프라스트럭처가 트랜잭션 작업을 롤백하도록 추천하는 방법은 
      트랜잭션 컨텍스트에서 현재 실행되고 있는 코드가 <exceptionname>Exception</exceptionname>를 
      던지도록 하는 것이다. 스프링 프레임워크의 트랜잭션 인프라스트럭처 코드는 버블링되는 호출스택처럼 
      다루지 않는 모든 <exceptionname>Exception</exceptionname>를 잡아서 트랜잭션을 롤백으로 
      표시할 것인지를 결정한다.<!--I changed to *can be configured* because next sentence says it does not do this by default in all cases. 
TR: REVISED, PLS REVIEW. I changed it to *in its default configuration*BT: I STILL DON'T GET IT. PRECEDING SENTENCE AND FOLLOWING --><!--SENTENCE SEEM CONTRADICTORY. TR: REVISED AGAIN, PLS REVIEW.--></para>

      <para>기본설정에서 스프링 프레임워크의 트랜잭션 인프라스트럭처는 런타입 익셉션과 언체크드 
      익셉션<emphasis>만</emphasis> 트랜잭션을 롤백으로 표시한다. 즉, 
      <exceptionname>RuntimeException</exceptionname>의 인스턴스나 하위클래스의 예외를 
      던졌을 때 뿐이다.(기본적으로 <exceptionname>Error</exceptionname>도 롤백될 것이다.) 
      트랜잭션이 적용된 메서드의 체크드 익셉션은 기본설정에서는 롤백하지 
      <emphasis>않는다</emphasis>.<!--I revised preceding because it says ONLY first case is rolled back by default, but then says Errors are also marked by default.
TR: OK AS IS. Errors aren't thrown by application code, only checked or unchecked exceptions are. So the Errors part is just clarifying that 
if the underlying application server infrastructure throws an Error the transaction will be rolled back.--></para>

      <para>체크드 익셉션을 포함해서 어떤 타입의 <exceptionname>Exception</exceptionname>이 
      트랜잭션을 롤백으로 표시하도록 할 것인지 설정할 수 있다. 다음의 XML 코드는 체크드이면서 
      어플리케이션에 특화된 <exceptionname>Exception</exceptionname> 타입을 롤백으로 
      어떻게 설정하는지 보여준다.</para>

      <programlisting language="xml">&lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
  &lt;tx:attributes&gt;
  &lt;tx:method name="get*" read-only="true" <lineannotation><emphasis
            role="bold">rollback-for="NoProductInStockException"</emphasis></lineannotation>/&gt;
  &lt;tx:method name="*"/&gt;
  &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</programlisting>

      <para>예외가 던져졌을 때 트랜잭션을 롤백하기를 원치 <emphasis>않을 때</emphasis> 
      '롤백 규칙'을 지정하지 않을 수도 있다. 다음의 예제는 스프링 프레임워크의 트랜잭션 인프라스트럭처가 
      다루지 않은 <exceptionname>InstrumentNotFoundException</exceptionname>를 
      만났을 때 조차도 참여한 트랜잭션을 커밋하게 한다.</para>

      <programlisting language="xml">&lt;tx:advice id="txAdvice"&gt;
  &lt;tx:attributes&gt;
  &lt;tx:method name="updateStock" <lineannotation><emphasis role="bold">no-rollback-for="InstrumentNotFoundException"</emphasis></lineannotation>/&gt;
  &lt;tx:method name="*"/&gt;
  &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</programlisting>

      <para>스프링 프레임워크의 트랜잭션 인프라스트럭처가 예외를 잡고 트랜잭션을 롤백으로 표시할지를 
      결정하려고 설정된 롤백규칙을 참고했을 때 <emphasis>가장 강하게(strongest)</emphasis> 
      일치한 규칙을 사용한다. 그래서 다음 설정의 경우 
      <exceptionname>InstrumentNotFoundException</exceptionname>를 제외한 모든 예외는 
      참가한 트랜잭션을 롤백한다.</para>

      <programlisting language="xml">&lt;tx:advice id="txAdvice"&gt;
  &lt;tx:attributes&gt;
  &lt;tx:method name="*" rollback-for="Throwable" no-rollback-for="InstrumentNotFoundException"/&gt;
  &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</programlisting>

      <para>필요한 롤백을 <emphasis>프로그래밍적으로</emphasis> 지정할 수도 있다. 아주 
      간단하더라도 이 방법은 상당히 침투적이고 코드가 스프링 프레임워크의 트랜잭션 인프라스트럭처에 
      강하게 커플링된다.</para>

      <programlisting language="java">public void resolvePosition() {
  try {
    <lineannotation>// 몇몇 비즈니스 로직...</lineannotation>
  } catch (NoProductInStockException ex) {
    <lineannotation>// 프로그래밍적으로 롤백을 일으킨다</lineannotation>
    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
  }
}</programlisting>

      <para>가능한 모든 경우에 롤백에 대해서 선언적인 접근을 하는 것을 강력히 권장한다. 프로그래밍적인 
      롤백은 절대적으로 필요한 경우에만 사용해야 하지만 프로그래밍적인 롤백을 사용하면 깔끔한 POJO 
      기반의 아키텍처를 버리게 된다.</para>
    </section>

    <section id="transaction-declarative-diff-tx">
      <title>다른 빈에 다른 트랜잭션의 의미를 설정하기</title>

      <para>다수의 서비스계층 객체가 있고 각각에 <emphasis>완전히 다른</emphasis> 트랜잭션 
      설정을 적용하고자 하는 시나리오를 생각해 보자. 이러한 경우 다른 <literal>pointcut</literal>과 
      <literal>advice-ref</literal> 속성값을 가진 별개의 
      <literal>&lt;aop:advisor/&gt;</literal> 요소를 정의할 수 있다.</para>

      <para>약간의 차이점있지만 우선 모든 서비스 계층의 클래스는 <literal>x.y.service</literal> 
      패키지 루트에 정의되어 있다고 가정한다. 모든 빈을 이 패키지(혹은 그 하위 팩키지)에 정의된 클래스의 
      인스턴스로 만들고 <literal>Service</literal>로 이름이 끝나는 모든 빈이 기본 트랜잭션 설정을 
      가지도록 하려면 다음과 같이 작성해야 한다.</para>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:aop="http://www.springframework.org/schema/aop"
  xmlns:tx="http://www.springframework.org/schema/tx"
  xsi:schemaLocation="
  http://www.springframework.org/schema/beans 
  http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
  http://www.springframework.org/schema/tx 
  http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
  http://www.springframework.org/schema/aop 
  http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt;

  &lt;aop:config&gt;

    &lt;aop:pointcut id="serviceOperation"
          expression="<lineannotation>execution(* x.y.service..*Service.*(..))</lineannotation>"/&gt;

    &lt;aop:advisor pointcut-ref="serviceOperation" advice-ref="txAdvice"/&gt;

  &lt;/aop:config&gt;

  <lineannotation>&lt;!-- 이 두 빈은 트랜잭션이 적용될 것이다... --&gt;</lineannotation>
  &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;
  &lt;bean id="barService" class="x.y.service.extras.SimpleBarService"/&gt;

  <lineannotation>&lt;!-- ... 그리고 이 두 빈은 트랜잭션이 적용되지 않는다 --&gt;</lineannotation>
  &lt;bean id="anotherService" class="org.xyz.SomeService"/&gt; <lineannotation>&lt;!-- (적합한 패키지에 있지 않다) --&gt;</lineannotation>
  &lt;bean id="barManager" class="x.y.service.SimpleBarManager"/&gt; <lineannotation>&lt;!-- (이름이 'Service'로 끝나지 않는다) --&gt;</lineannotation>

  &lt;tx:advice id="txAdvice"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="get*" read-only="true"/&gt;
      &lt;tx:method name="*"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

  <lineannotation>&lt;!-- <interfacename>PlatformTransactionManager</interfacename>와 같은 다른 트랜잭션 인프라스트럭처 빈은 생략했다... --&gt;</lineannotation>

&lt;/beans&gt;</programlisting>

      <para>다음 예제는 환전히 다른 트랜잭션 설정으로 별도의 두 빈을 설정하는 방법을 
      보여준다.</para>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:aop="http://www.springframework.org/schema/aop"
  xmlns:tx="http://www.springframework.org/schema/tx"
  xsi:schemaLocation="
  http://www.springframework.org/schema/beans 
  http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
  http://www.springframework.org/schema/tx 
  http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
  http://www.springframework.org/schema/aop 
  http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt;

  &lt;aop:config&gt;

    &lt;aop:pointcut id="defaultServiceOperation"
          expression="<lineannotation>execution(* x.y.service.*Service.*(..))</lineannotation>"/&gt;

    &lt;aop:pointcut id="noTxServiceOperation"
          expression="<lineannotation>execution(* x.y.service.ddl.DefaultDdlManager.*(..))</lineannotation>"/&gt;

    &lt;aop:advisor pointcut-ref="defaultServiceOperation" advice-ref="defaultTxAdvice"/&gt;

    &lt;aop:advisor pointcut-ref="noTxServiceOperation" advice-ref="noTxAdvice"/&gt;

  &lt;/aop:config&gt;

  <lineannotation>&lt;!-- 이 빈은 트랜잭션이 적용된다 (<literal>'defaultServiceOperation'</literal> 포인트컷을 참고해라) --&gt;</lineannotation>
  &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

  <lineannotation>&lt;!-- 이 빈도 트랜잭션이 적용되지만 완전히 다른 트랜잭션 설정을 가진다 --&gt;</lineannotation>
  &lt;bean id="anotherFooService" class="x.y.service.ddl.DefaultDdlManager"/&gt;

  &lt;tx:advice id="defaultTxAdvice"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="get*" read-only="true"/&gt;
      &lt;tx:method name="*"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

  &lt;tx:advice id="noTxAdvice"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="*" propagation="NEVER"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

  <lineannotation>&lt;!-- <interfacename>PlatformTransactionManager</interfacename>와 같은 다른 트랜잭션 인프라스트럭처 빈은 생략했다... --&gt;</lineannotation>

&lt;/beans&gt;</programlisting>
    </section>

    <section id="transaction-declarative-txadvice-settings">
      <title><literal>&lt;tx:advice/&gt;</literal> 설정</title>

      <para>이번 색션에서는 <literal>&lt;tx:advice/&gt;</literal> 태그를 사용해서 
      지정할 수 있는 여러가지 트랜잭션 설정을 간략히 설명한다. 기본 
      <literal>&lt;tx:advice/&gt;</literal> 설정은 다음과 같다.</para>

      <para><itemizedlist>
          <listitem>
            <para><link linkend="tx-propagation">전파(Propagation) 설정</link>은
            <literal>REQUIRED</literal>다.</para>
          </listitem>

          <listitem>
            <para>격리 수준(Isolation level)은 <literal>DEFAULT</literal>이다.</para>
          </listitem>

          <listitem>
            <para>트랜잭션은 읽기/쓰기이다.</para>
          </listitem>

          <listitem>
            <para>트랜잭션 타입아웃 기본값은 의존하는 트랜잭션 시스템의 기본 타입아웃이거나 
            타임아웃을 지원하지 않는다면 존재하지 않는다.</para>
          </listitem>

          <listitem>
            <para>모든 <exceptionname>RuntimeException</exceptionname>은 롤백을 
            발생시키고 모든 체크드 <exceptionname>Exception</exceptionname>은 롤백을 
            발생시키지 않는다.</para>
          </listitem>
        </itemizedlist></para>

      <para>이 기본 설정을 변경할 수 있다. <literal>&lt;tx:advice/&gt;</literal>와 
      <literal>&lt;tx:attributes/&gt;</literal>내에 중첩된 
      <literal>&lt;tx:method/&gt;</literal> 태그의 여러가지 속성은 아래에 정리되어 
      있다.</para>

      <para><table id="tx-method-settings">
          <title><literal>&lt;tx:method/&gt;</literal> 설정</title>

          <tgroup cols="4">
            <colspec colnum="1" colwidth="1*" />

            <colspec colnum="2" colwidth="0.4*" />

            <colspec colnum="3" colwidth="0.6*" />

            <colspec colnum="4" colwidth="2*" />

            <thead>
              <row>
                <entry>속성</entry>

                <entry>필수여부?</entry>

                <entry>기본값</entry>

                <entry>설명</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>name</literal></entry>

                <entry>Yes</entry>

                <entry></entry>

                <entry><para>연결된 트랜잭션 속성의 메서드 이름. 와일드카드 (*) 문자를 
                다수의 메서드를 가진 같은 트랜잭션 속성 설정과 연결하는데 사용할 수 있다. 
                예를 들어, <literal>get*</literal>, <literal>handle*</literal>,
                <literal>on*Event</literal> 등등 이다.</para></entry>
              </row>

              <row>
                <entry><literal>propagation</literal></entry>

                <entry>No</entry>

                <entry>REQUIRED</entry>

                <entry>트랜잭션 전파 동작.</entry>
              </row>

              <row>
                <entry><literal>isolation</literal></entry>

                <entry>No</entry>

                <entry>DEFAULT</entry>

                <entry>트랜잭션 격리 수준.</entry>
              </row>

              <row>
                <entry><literal>timeout</literal></entry>

                <entry>No</entry>

                <entry>-1</entry>

                <entry>트랜잭션 타임아웃 값 (초단위).</entry>
              </row>

              <row>
                <entry><literal>read-only</literal></entry>

                <entry>No</entry>

                <entry>false</entry>

                <entry>해당 트랜잭션이 읽기 전용인가?</entry>
              </row>

              <row>
                <entry><literal>rollback-for</literal></entry>

                <entry>No</entry>

                <entry></entry>

                <entry><para>롤백을 일으키는 <literal>Exception(s)</literal>. 
                콤마로 구분한다. 예를 들면
                <literal>com.foo.MyBusinessException,ServletException.</literal></para></entry>
              </row>

              <row>
                <entry><literal>no-rollback-for</literal></entry>

                <entry>No</entry>

                <entry></entry>

                <entry><para>롤백을 일으키지 <emphasis>않는</emphasis> 
                <literal>Exception(s)</literal>. 콤마로 구분한다. 예를 들어
                <literal>com.foo.MyBusinessException,ServletException.</literal></para></entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section id="transaction-declarative-annotations">
      <title><interfacename>@Transactional</interfacename> 사용하기</title>

      <para>트랜잭션 설정에 대한 XML에 기반한 선언적인 접근에 추가적으로 어노테이션 기반의 접근을 
      사용할 수 있다. 자바 소스코드에 직접 트랜잭션을 선언하는 것은 영향받는 코드에 훨씬 가깝게 선언을 
      둘 수 있다. 어쨌든 트랜잭션을 사용하는 코드는 거의 항상 이러한 방법으로 배포되기 때문에 과도한 
      커플링으로 인한 큰 위험은 없다.</para>

      <para><interfacename>@Transactional</interfacename> 어노테이션의 쉬운 
      사용방법은 예제로 설명하는 것이 가장 쉽고 예제후에 좀더 자세히 설명한다. 다음의 
      클래스 정의를 보자.</para>

      <programlisting language="java"><lineannotation>// 트랜잭션을 적용하고자 하는 서비스 클래스</lineannotation>
<emphasis role="bold">@Transactional</emphasis>
public class DefaultFooService implements FooService {

  Foo getFoo(String fooName);

  Foo getFoo(String fooName, String barName);

  void insertFoo(Foo foo);

  void updateFoo(Foo foo);
}</programlisting>

      <para>위의 POJO가 스프링 IoC 컨테이너의 빈처럼 정의되었을 때 딱 <emphasis>한</emphasis> 
      줄의 XML 설정을 추가해서 빈 인스턴스에 트랜잭션을 적용할 수 있다.</para>

      <programlisting language="xml"><lineannotation>&lt;!-- <literal>'context.xml'</literal> 파일에서 --&gt;</lineannotation>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:aop="http://www.springframework.org/schema/aop"
     xmlns:tx="http://www.springframework.org/schema/tx"
     xsi:schemaLocation="
     http://www.springframework.org/schema/beans 
     http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
     http://www.springframework.org/schema/tx 
     http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
     http://www.springframework.org/schema/aop 
     http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt;
  
  <lineannotation>&lt;!-- 트랜잭션을 적용하고자 하는 서비스 객체다 --&gt;</lineannotation>
  &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

  <lineannotation>&lt;!-- 어노테이션에 기반한 트랜잭션 동작의 설정을 활성화한다. --&gt;</lineannotation>
  <emphasis role="bold">&lt;tx:annotation-driven transaction-manager="txManager"/&gt;</emphasis>

  <lineannotation>&lt;!-- a <interfacename>PlatformTransactionManager</interfacename>는 여전히 필요하다 --&gt;</lineannotation>
  &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
  <lineannotation>&lt;!-- (이 의존성은 어딘가에 정의되어 있다) --&gt;</lineannotation>
  &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;
  
  <lineannotation>&lt;!-- 다른 <literal>&lt;bean/&gt;</literal> 정의는 여기에 한다 --&gt;</lineannotation>

&lt;/beans&gt;</programlisting>

      <tip>
        <para>연결하려는 <interfacename>PlatformTransactionManager</interfacename>의 
        빈 이름이 <literal>transactionManager</literal>인 경우에는 
        <literal>&lt;tx:annotation-driven/&gt;</literal> 태그에서 
        <literal>transaction-manager</literal> 속성을 생략할 수 있다. 의존성 주입하려는 
        <interfacename>PlatformTransactionManager</interfacename> 빈이 다른 이름을 가지고 
        있다면 앞의 예제처럼 <literal>transaction-manager</literal> 속성을 명시적으로 
        사용해야 한다.</para>
      </tip>

      <sidebar>
        <title>메서드 가시성과 
        <interfacename>@Transactional</interfacename></title>

        <para>프록시를 사용할 때는 <emphasis>public</emphasis> 가시성을 가진 메서드에만 
        <interfacename>@Transactional</interfacename> 어노테이션을 적용해야 한다. 
        protected나 private, package-visible 메서드에 
        <interfacename>@Transactional</interfacename> 어노테이션을 붙히면 오류가 발생하지는 
        않지만 어노테이션이 붙은 메서드는 설정된 트랜잭션 설정에 나타나지 않는다. 퍼블릭이 아닌 메서드에 
        어노테이션을 붙혀야 한다면 AspectJ의 사용을 고려해봐라(아래 참고).</para>
      </sidebar>

      <para>인터페이스 정의, 인터페이스의 메서드, 클래스 정의, 클래스의 <emphasis>퍼블릭</emphasis> 
      메서드 앞에 <interfacename>@Transactional</interfacename> 어노테이션을 둘 수 있다. 하지만 
      단지 <interfacename>@Transactional</interfacename> 어노테이션의 존재만으로는 트랜잭션 동작을 
      활성화하기에 충분하지 않다. <interfacename>@Transactional</interfacename> 어노테이션은 단순히 
      <interfacename>@Transactional</interfacename>을 인지하는 몇몇 런타임 인프라스트럭처가 소비할 
      수 있는 메타데이터이고 적절한 빈에 트랜잭션 동작을 설정하는데 메타데이터를 사용할 수 있다. 앞의 예제에서 
      <literal>&lt;tx:annotation-driven/&gt;</literal> 요소가 트랜잭션 동작을 
      <emphasis>활성화한다</emphasis>.</para>

      <para><tip>
          <para>스프링은 인터페이스에 어노테이션을 붙히는 것과는 반대로 구현(concrete) 클래스(그리고 
          구현 클래스의 메서드들)에만 <interfacename>@Transactional</interfacename> 어노테이션을 
          붙히기를 권장한다. 확실히 인터페이스(또는 인터페이스의 메서드)에도 
          <interfacename>@Transactional</interfacename> 어노테이션을 붙힐 수 있지만 인터페이스 
          기반의 프록시를 사용하는 경우에만 제대로 동작한다. 자바의 어노테이션이 <emphasis>인터페이스를 
          상속받지 않는다는</emphasis> 점은 클래스 기반의 프록시
          (<literal>proxy-target-class="true"</literal>)를 사용하거나 위빙기반의 관점
          (<literal>mode="aspectj"</literal>)을 사용할 때 프록시와 위빙 인프라스트럭처가 트랜잭션 
          설정을 인지하지 못하고 해당 객체가 트랜잭션이 적용된 프록시로 감싸지지 않는다는 것(아주 
          <emphasis>안좋다</emphasis>)을 의미한다.</para>
        </tip></para>

      <note>
        <para>프록시 모드에서(기본값이다) 프록시를 통한 외부 메서드 호출만을 가로챈다. 즉, 호출된 
        메서드가 <interfacename>@Transactional</interfacename>로 표시되어 있더라도 
        자기호출(self-invocation, 대상 객체의 다른 메서드를 호출하는 대상 객체내의 메서드)은 
        런타임시에 실제로 트랜잭션이 되지 않을 것이다.</para>
      </note>

      <para>자기호출이 트랜잭션으로 잘 감싸지길 원한다면 AspectJ 모드의 사용을 고려해 봐라.(아래 
      표의 mode 속성을 참고해라.) <!--*see below* is not clear re AspectJmode. Provide clear x-ref  to mode in table below, or to Using Transactional with AspectJ section. Also clarify reference to *as well*. As well as what?--><!--Below, *in this case* meaning in *what* case? Explain what table shows. TR:  REVISED, PLS REVIEW-->우선 
      이 경우에 프록시가 없다. 대신, 모든 종류의 메서드에서 
      <interfacename>@Transactional</interfacename>을 런타임동작으로 바꾸기 위해 대상 
      객체는 위빙된 것이다.(즉 대상객체의 바이트코드가 수정될 것이다.)</para>

      <para><table id="tx-annotation-driven-settings">
          <title><literal>&lt;tx:annotation-driven/&gt;</literal>
          설정</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry>속성</entry>

                <entry>기본값</entry>

                <entry>설명</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>transaction-manager</literal></entry>

                <entry>transactionManager</entry>

                <entry><para>사용할 트랜잭션 관리자의 이름. 위의 예제처럼 트랜잭션 관리자의 
                이름이 <literal>transactionManager</literal>이 아닌 경우에만 
                필요하다.</para></entry>
              </row>

              <row>
                <entry><literal>mode</literal></entry>

                <entry>proxy</entry>

                <entry><para>기본 모드인 "proxy"가 스프링의 AOP 프레임워크를 사용해서 프록시되는 
                어노테이션이 붙은 빈을 처리한다.(위에서 얘기한 다음의 프록시 의미는 프록시를 통한 메서드 
                호출에만 적용된다.) 다른 모드인 "aspectj"는 스프링의 AspectJ 트랜잭션 관점으로 
                영향받은 클래스를 대신 위빙해서 모든 종류의 메서드 호출에 적용하기 위해 대상객체의 
                바이트코드를 수정한다. AspectJ 위빙은 활성화된 로드타임 위빙(또는 컴파일타임 위빙)과 
                마찬가지로 클래스패스에 spring-aspects.jar를 필요로 한다.(로드타임 위빙을 설정하는 
                방법은 <xref linkend="aop-aj-ltw-spring" />를 참고해라.)</para></entry>
              </row>

              <row>
                <entry><literal>proxy-target-class</literal></entry>

                <entry>false</entry>

                <entry><para>proxy 모드에만 적용된다. 
                <interfacename>@Transactional</interfacename> 어노테이션이 붙은 클래스에 
                어떤 타입의 트랜잭션 프록시를 생성할 것인지 제어한다. 
                <literal>proxy-target-class</literal> 속성을 <literal>true</literal>로 
                설정했다면 클래스기반의 프록시가 생성된다. <literal>proxy-target-class</literal>가 
                <literal>false</literal>이거나 이 속성을 생략하면 표준 JDK 인터페이스 기반 프록시가 
                생성된다. (다른 프록시 타입의 자세한 설명은 <xref linkend="aop-proxying" />를 
                참고해라.)</para></entry>
              </row>

              <row>
                <entry><literal>order</literal></entry>

                <entry>Ordered.LOWEST_PRECEDENCE</entry>

                <entry><para><interfacename>@Transactional</interfacename> 
                어노테이션이 붙은 빈에 적용되는 트랜잭션 어드바이스의 순서를 정의한다. (AOP 
                어드바이스의 순서와 관계된 규칙에 대한 내용은 
                <xref linkend="aop-ataspectj-advice-ordering" />를 참고해라.) 순서를 
                지정하지 않으면 AOP 서브시스템이 어드바이스의 순서를 결정한다.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <note>
        <para><interfacename>@Transactional</interfacename> 어노테이션이 붙은 클래스에 
        어떤 타입의 트랜잭션이 적용된 프록시를 생성할 것인 지를 
        <literal>&lt;tx:annotation-driven/&gt;</literal> 요소의 
        <literal>proxy-target-class</literal> 속성이 제어한다. 
        <literal>proxy-target-class</literal> 속성을 <literal>true</literal>로 설정했으면 
        클래스기반의 프록시가 생성된다. <literal>proxy-target-class</literal>가 
        <literal>false</literal>이거나 이 속성을 생략하면 표준 JDK 인터페이스기반의 프록시가 
        생성된다. (다른 프록시 타입에 대한 내용은 <xref linkend="aop-proxying" />를 
        참고해라.)</para>
      </note>

      <note>
        <para><literal>&lt;tx:annotation-driven/&gt;</literal>는 같은 어플리케이션 
        컨텍스트에 정의된 <interfacename>@Transactional</interfacename>가 붙은 빈만을 
        찾는다. 즉, <classname>DispatcherServlet</classname>을 위해서 
        <interfacename>WebApplicationContext</interfacename>에 
        <literal>&lt;tx:annotation-driven/&gt;</literal>를 두면 서비스가 아니라 
        컨트롤러에서만 <interfacename>@Transactional</interfacename> 빈을 확인한다. <!--I don't understand the logic of preceding explanation. Also identify *it* in first sentence of Note. 
TR: OK AS IS. "it" refers to <tx:annotation-driven/>-->자세한 내용은 <xref
        linkend="mvc-servlet" />를 참고해라.</para>
      </note>

      <para>메서드에 트랜잭션 설정을 평가할 때 가장 깊은 위치(most derived location)의 설정을 
      우선시한다. <!--Do you need to clarify what *most derived* location means? Lowest level? TR: OK AS IS. following sentence explains it-->다음 
      예제에서 <classname>DefaultFooService</classname> 클래스는 읽기전용 트랜잭션 설정으로 
      클래스수준에 어노테이션을 붙혔지만 같은 클래스의 <methodname>updateFoo(Foo)</methodname> 
      메서드의 <interfacename>@Transactional</interfacename> 어노테이션이 클래스수준에 정의된 
      트랜잭션 설정보다 앞선다.</para>

      <programlisting language="java">@Transactional(readOnly = true)
public class DefaultFooService implements FooService {

  public Foo getFoo(String fooName) {
    <lineannotation>// 어떤 작업을 한다</lineannotation>
  }

  <lineannotation>// 이 메서드에는 <emphasis role="bold">이</emphasis> 설정이 우선시된다</lineannotation>
  @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)
  public void updateFoo(Foo foo) {
    <lineannotation>// 어떤 작업을 한다</lineannotation>
  }
}</programlisting>

      <section id="transaction-declarative-attransactional-settings">
        <title><interfacename>@Transactional</interfacename> 설정</title>

        <para><interfacename>@Transactional</interfacename> 어노테이션은 인터페이스, 
        클래스, 메서드가 트랜잭션이 되어야 한다는 것을 지정하는 메타데이터이다. 예를 들어 
        <quote><emphasis>해당 메서드가 호출될 때 기존의 존재하는 트랜잭션은 중지시키고 읽기 전용의 
        새로운 트랜잭션을 시작해야 한다는 식이다.</emphasis></quote> 기본 
        <interfacename>@Transactional</interfacename> 설정은 다음과 같다.</para>

        <itemizedlist>
          <listitem>
            <para>전파 설정은 
            <literal>PROPAGATION_REQUIRED 이다.</literal></para>
          </listitem>

          <listitem>
            <para>격리 수준은
            <literal>ISOLATION_DEFAULT 이다.</literal></para>
          </listitem>

          <listitem>
            <para>트랜잭션은 읽기/쓰기가 가능하다.</para>
          </listitem>

          <listitem>
            <para>트랜잭션 타임아웃의 기본값은 의존하는 트랜잭션 시스템의 기본 타임아웃값이거나 
            타임아웃이 지원되지 않는다면 타임아웃이 없다.</para>
          </listitem>

          <listitem>
            <para>모든 <exceptionname>RuntimeException</exceptionname>은 롤백을 실행하고 
            체크드 <exceptionname>Exception</exceptionname>은 롤백하지 
            않는다.<!--Bullet list above does not exactly map to properties in table.ok? TR: OK AS IS--></para>
          </listitem>
        </itemizedlist>

        <para>이 기본설정은 변경할 수 있다. <interfacename>@Transactional</interfacename> 
        어노테이션의 다양한 프로퍼티는 다음 표에 정리해 놨다.</para>

        <para><table id="tx-attransactional-properties">
            <title><interfacename>@Transactional</interfacename>
            프로퍼티</title>

            <tgroup cols="3">
              <thead>
                <row>
                  <entry>프로퍼티</entry>

                  <entry>타입</entry>

                  <entry>설명</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><literal><link
                    linkend="tx-multiple-tx-mgrs-with-attransactional">value</link></literal></entry>
                  
                  <entry>String</entry>
                  
                  <entry>
                    사용할 트랜잭션 관리자를 지정하는 선택적인 제한자(qualifier)
                  </entry>
                </row>
                
                <row>
                  <entry><literal><link
                  linkend="tx-propagation">propagation</link></literal></entry>

                  <entry>enum: <classname>Propagation</classname></entry>

                  <entry>선택적인 전파 설정.</entry>
                </row>

                <row>
                  <entry><literal>isolation</literal></entry>

                  <entry>enum: <classname>Isolation</classname></entry>

                  <entry>선택적인 격리수준.</entry>
                </row>

                <row>
                  <entry><literal>readOnly</literal></entry>

                  <entry>boolean</entry>

                  <entry>읽기/쓰기 트랜잭션인가? 읽기전용 트랜잭션인가?</entry>
                </row>

                <row>
                  <entry><literal>timeout</literal></entry>

                  <entry>int (in seconds granularity)</entry>

                  <entry>트랜잭션 타임아웃.</entry>
                </row>

                <row>
                  <entry><literal>rollbackFor</literal></entry>

                  <entry><classname>Throwable</classname>에서 얻어져야하는 
                  <classname>Class</classname> 객체들의 배열.</entry>

                  <entry><emphasis role="bold">반드시</emphasis> 롤백해야 하는 
                  예외 클래스의 선택적인 배열.</entry>
                </row>

                <row>
                  <entry><literal>rollbackForClassname</literal></entry>

                  <entry>클래스 이름의 배열. <classname>Throwable</classname>에서 
                  얻어져야 하는 클래스들.</entry>

                  <entry><emphasis role="bold">반드시</emphasis> 롤백해야 하는 
                  예외 클래스 이름의 선택적인 배열.</entry>
                </row>

                <row>
                  <entry><literal>noRollbackFor</literal></entry>

                  <entry><classname>Throwable</classname>에서 얻어져야 하는 
                  <classname>Class</classname> 객체들의 배열.</entry>

                  <entry><emphasis role="bold">반드시</emphasis> 롤백하지 않아야 하는 
                  예외 클래스의 선택적인 배열.</entry>
                </row>

                <row>
                  <entry><literal>noRollbackForClassname</literal></entry>

                  <entry><classname>Throwable</classname>에서 얻어져야 하는 클래스 
                  이름 <classname>String</classname>의 배열.</entry>

                  <entry><emphasis role="bold">반드시</emphasis> 롤백하지 않아야 하는 
                  예외 클래스 이름의 선택적인 배열.</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>

        <para>지금은 트랜잭션의 이름으로 명시적인 제어를 할 수 없다. 여기서 '이름'은 가능한 경우 
        트랜잭션 모니터(예를 들면 웹로직의 트랜잭션 모니터)와 로깅 출력에 나올 트랜잭션의 이름을 
        의미한다. 선언적인 트랜잭션에서 트랜잭션 이름은 항상 정규화된 클래스명  + "." + <!--Meaning of symbols is unclear. TR: OK AS IS. means concatenation and it would be clear to any programmer reading the docs-->
        트랜잭션하게 어드바이즈된 클래스의 메서드명이다. 예를 들어 
        <classname>BusinessService</classname> 클래스의 
        <methodname>handlePayment(..)</methodname> 메서드가 트랜잭션을 시작하면 트랜잭션의 
        이름은 <literal>com.foo.BusinessService.handlePayment</literal>가 된다.</para>
      </section>
    
      <section id="tx-multiple-tx-mgrs-with-attransactional">
        <title><interfacename>@Transactional</interfacename>과 여러 트랜잭션 관리자</title>
        <para>
          대부분의 스프링 어플리케이션은 딱 하나의 트랜잭션 관리자만 필요로 하지만 하나의 어플리케이션에서 여러 개의 독립적인 
          트랜잭션 관리자가 필요한 상황이 있을 것이다. <interfacename>@Transactional</interfacename> 
          어노테이션의 value 속성은 사용할 <classname>PlatformTransactionManager</classname>의 식별자를 
          선택적으로 지정하는데 사용할 수 있다. 이는 트랜잭션 관리자 빈의 이름이나 제한자(qualifier) 값이 될 수 있다. 
          예를 들어 제한자(qualifier) 표기법을 사용한 다음의 자바코드는
<programlisting language="java">
  public class TransactionalService {
  
    @Transactional("order")
    public void setSomething(String name) { ... }
  
    @Transactional("account")
    public void doSomething() { ... }
  }
</programlisting>          
          어플리케이션 컨텍스트에서 다음의 트랜잭션 관리자 빈 선언과 섞을 수 있다.
<programlisting language="xml"><![CDATA[
  <tx:annotation-driven/>

  <bean id="transactionManager1" class="org.springframework.jdbc.DataSourceTransactionManager">
    ...
    <qualifier value="order"/>
  </bean>

  <bean id="transactionManager2" class="org.springframework.jdbc.DataSourceTransactionManager">
    ...
    <qualifier value="account"/>
  </bean>  
]]>
</programlisting>  
          이 경우에 <literal>TransactionalService</literal>의 두 메서드는 "order"와 "account" 제한자로 
          구분된 별도의 트랜잭션 관리자에서 실행될 것이다. 적합한 PlatformTransactionManager 빈을 특별히 찾아내지 
          못한다면 <literal>transactionManager</literal> 빈 이름을 가리키는 기본 
          <literal>&lt;tx:annotation-driven&gt;</literal>를 여전히 사용할 것이다. 
        </para>
      </section>
      <section id="tx-custom-attributes">
        <title>커스텀 단축 어노테이션</title>
        <para>
          여러 메서드의 <interfacename>@Transactional</interfacename>에 같은 속성을 반복적으로 사용하고 있다면 
          스프링 메타어노테이션 지원을 이용해서 커스텀 단축 어노테이션을 정의할 수 있다. 예를 들면 다음과 같은 어노테이션을 
          정의해서
<programlisting language="java">
  @Target({ElementType.METHOD, ElementType.TYPE})
  @Retention(RetentionPolicy.RUNTIME)
  @Transactional("order")
  public @interface OrderTx {
  }
  
  @Target({ElementType.METHOD, ElementType.TYPE})
  @Retention(RetentionPolicy.RUNTIME)
  @Transactional("account")
  public @interface AccountTx {
  }  
</programlisting>
          다음과 같이 이전 섹션의 예제를 작성할 수 있다.
<programlisting language="java">
  public class TransactionalService {
  
    @OrderTx
    public void setSomething(String name) { ... }
  
    @AccountTx
    public void doSomething() { ... }
  }
</programlisting>          
          여기서는 트랜잭션 관리자 제한자를 정의하는 문법을 사용했지만 전파 동작, 롤백 규칙, 타임아웃 등도 사용할 수 있다.
        </para>
      </section>  
    </section>

    <section id="tx-propagation">
      <title>트랜잭션 전파</title>

      <!--Changed heading to be more explicit. These are settings, right? 
TR: REVISED, PLS REVIEW - changed it back; it's not just settings, the section discusses propagation in general as well as the settings-->

      <para>이번 섹션에서는 스프링에서 트랜잭션 전파의 의미를 설명한다. 이번 섹션이 트랜잭션 전파의 
      적절한 소개가 아니라는 것을 유념해야 한다. 오히려 스프링에서 트랜잭션 전파에 관련된 몇 가지 
      의미를 설명한다.</para>

      <para>스프링이 관리하는 트랜잭션에서sms <emphasis>물리적인</emphasis> 트랜잭션과 
      <emphasis>논리적인</emphasis> 트랜잭션간의 차이점과 이 차이점에 전파설정을 적용하는 
      방법을 알아야 한다.</para>

      <section id="tx-propagation-required">
        <title>Required</title>

        <para><mediaobject>
            <imageobject>
              <imagedata align="center" fileref="images/tx_prop_required.png"
                         format="PNG" />
            </imageobject>

            <caption><para>PROPAGATION_REQUIRED</para></caption>
          </mediaobject></para>

        <para>전파 설정이 <literal>PROPAGATION_REQUIRED</literal>인 경우 설정이 적용된 
        각 메서드마다 <emphasis>논리적인</emphasis> 트랜잭션의 범위가 생성된다. 이러한 각각의 
        논리적인 트랜잭션 범위는 외부 트랜잭션 범위는 내부 트랜잭션 범위와 논리적으로 독립되어 개별적인 
        롤백전용(rollback-only) 상태를 결정한다. 물론 표준 <literal>PROPAGATION_REQUIRED</literal> 
        동작의 경우 이러한 모든 범위는<!--OK? Need to identify *they*. TR: OK AS IS--> 
        같은 물리적인 트랜잭션에 매핑될 것이다. 그래서 내부 트랜잭션 범위에 설정된 롤백전용 표시(marker)는 
        외부 트랜잭션이 실제로 커밋할 기회에 영향을 준다.(기대대로)<!--Do you need to explain what an inner transaction scope as opposed to an outer transaction scope? TR: OK AS IS--></para>

        <para>하지만 내부 트랜잭션 범위가 롤백전용으로 설정된 경우에 외부 트랜잭션 스스로 롤백을 결정하지 
        않으므로 롤백을(내부 트랜잭션 범위가 조용히 실행한다.) 예상하지 못한다. 이 때 대응되는 
        <classname>UnexpectedRollbackException</classname>이 던져진다. 이는 트랜잭션의 
        호출자가 커밋되지 않아야 하는 경우 커밋되었다고 가정하지 않도록 할 수 있는 <emphasis>예상된 
        동작</emphasis>이다. 그래서 내부 트랜잭션(외부 호출자가 알지 못하는)은 트랜잭션을 조용히 
        롤백전용으로 표시하고 외부 호출자는 여전히 커밋을 호출한다. 외부 호출자는 커밋이 아니라 롤백이 
        수행되었다는 것을 명확히 알도록 <classname>UnexpectedRollbackException</classname>를 
        받야야 한다.</para>
      </section>

      <section id="tx-propagation-requires_new">
        <title>RequiresNew</title>

        <para><mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="images/tx_prop_requires_new.png"
                         format="PNG" />
            </imageobject>

            <caption><para>PROPAGATION_REQUIRES_NEW</para></caption>
          </mediaobject></para>

        <para><type>PROPAGATION_REQUIRED</type>와는 반대로 
        <literal>PROPAGATION_REQUIRES_NEW</literal>는 영향받은 각각의 트랜잭션 범위에 
        <emphasis>완전히</emphasis> 독릭적인 트랜잭션을 사용한다. 이러한 경우 의존하는 물리적인 
        트랜잭션이 다르므로 외부 트랜잭션이 내부 트랜잭션의 롤백상태에 영향을 받지 않고 독립적으로 
        커밋하거나 롤백할 수 있다.</para>
      </section>

      <section id="tx-propagation-nested">
        <title>Nested</title>

        <para><literal>PROPAGATION_NESTED</literal>는 롤백할 수 있는 여러 
        세이브포인트(savepoint)를 가진 <emphasis>하나의</emphasis> 물리적인 트랜잭션을 사용한다. 
        이러한 부분 롤백으로 어떤 작업이 롤백되었더라도 외부 트랜잭션은 계속해서 물리적인 트랜잭션을 
        진행하면서 내부 트랜잭션 범위가 <emphasis>자신의 범위에서</emphasis> 롤백을 실행할 수 있게 
        한다. 이 설정은 보통 JDBC 세이브포인트에 매핑되므로 JDBC 리소스 트랜잭션에서만 동작할 것이다. 
        스프링의 <classname>DataSourceTransactionManager</classname>를 참고해라.</para>
      </section>
    </section>

    <section id="transaction-declarative-applying-more-than-just-tx-advice">
      <title>트랜잭션 작업 어드바이징하기<!--Need better heading? Executing transactional advice? TR: OK AS IS--></title>

      <para>트랜잭션 작업과 몇가지 기본적인 프로파일링 어드바이스를 <emphasis>둘 다</emphasis> 
      실행한다고 생각해보자. <literal>&lt;tx:annotation-driven/&gt;</literal> 컨텍스트에서 
      이렇게 하려면 어떻게 해야하는가?</para>

      <para><methodname>updateFoo(Foo)</methodname> 메서드를 호출할 때 다음의 
      동작을 보기 원할 것이다.<!--I changed this to a numbered list because language indicated that one thing happens after another. TR: OK--></para>

      <orderedlist>
        <listitem>
          <para>설정된 프로파일링 관점 시작.</para>
        </listitem>

        <listitem>
          <para>트랙잭션이 적용된 어드바이스 실행.</para>
        </listitem>

        <listitem>
          <para>어드바이즈된 객체의 메서드 실행.</para>
        </listitem>

        <listitem>
          <para>트랜잭션 커밋.</para>
        </listitem>

        <listitem>
          <para>프로파일링 관점이 전체 트랜잭션 메서드 호출의 정확한 실행시간을 
          리포팅함.</para>
        </listitem>
      </orderedlist>

      <note>
        <para>이번 장에서는 AOP의 자세한 내용은  설명하지 않는다.(트랜잭션을 적용하는 것과 
        관련된 것은 제외하고) 일반적인 다음의 AOP와 AOP의 설정에 대한 자세한 내용은 <xref
        linkend="aop" />를 참고해라.</para>
      </note>

      <para>다음은 앞에서 얘기한 간단한 프로파일링 관점에 대한 코드이다.
      <!--If you mean this code produces actions above, say that. TR: REVISED, PLS REVIEW.added 'discussed above'-->
      어드바이스의 순서는 <interfacename>Ordered</interfacename> 인터페이스로 제어한다. 
      어드바이스 순서에 대한 자세한 내용은 <xref linkend="aop-ataspectj-advice-ordering" />를 
      참고해라.</para>

      <programlisting language="java">package x.y;

import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.util.StopWatch;
import org.springframework.core.Ordered;

public class SimpleProfiler implements Ordered {

  private int order;

  <lineannotation>// 어드바이스의 순서를 제어할 수 있게 한다</lineannotation>
  public int getOrder() {
    return this.order;
  }

  public void setOrder(int order) {
    this.order = order;
  }

  <lineannotation>// 이 메서드<emphasis>는</emphasis> around advice 이다</lineannotation>
  public Object profile(ProceedingJoinPoint call) throws Throwable {
    Object returnValue;
    StopWatch clock = new StopWatch(getClass().getName());
    try {
      clock.start(call.toShortString());
      returnValue = call.proceed();
    } finally {
      clock.stop();
      System.out.println(clock.prettyPrint());
    }
    return returnValue;
  }
}
</programlisting>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:aop="http://www.springframework.org/schema/aop"
     xmlns:tx="http://www.springframework.org/schema/tx"
     xsi:schemaLocation="
   http://www.springframework.org/schema/beans 
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
   http://www.springframework.org/schema/tx 
   http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
   http://www.springframework.org/schema/aop 
   http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt;

  &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

  <lineannotation>&lt;!-- 관점이다 --&gt;</lineannotation>
  &lt;bean id="profiler" class="x.y.SimpleProfiler"&gt;
    <lineannotation>&lt;!-- 트랜잭션이 적용된 어드바이스 이전에 실행한다 (그러므로 순서(order) 번호가 작다) --&gt;</lineannotation>
    &lt;property name="order" <emphasis role="bold">value="1"</emphasis>/&gt;
  &lt;/bean&gt;

  &lt;tx:annotation-driven transaction-manager="txManager" <emphasis
          role="bold">order="200"</emphasis>/&gt;

  &lt;aop:config&gt;
    <lineannotation>&lt;!-- 이 어드바시스는 트랜잭션이 적용된 어드바이스 <emphasis role="bold">주위에서(around)</emphasis> 실행될 것이다 --&gt;</lineannotation>
    &lt;aop:aspect id="profilingAspect" ref="profiler"&gt;
      &lt;aop:pointcut id="serviceMethodWithReturnValue"
              expression="execution(!void x.y..*Service.*(..))"/&gt;
      &lt;aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/&gt;
    &lt;/aop:aspect&gt;
  &lt;/aop:config&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/&gt;
    &lt;property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/&gt;
    &lt;property name="username" value="scott"/&gt;
    &lt;property name="password" value="tiger"/&gt;
  &lt;/bean&gt;

  &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</programlisting>

      <para>위의 설정으로 <emphasis>원하는 순서에 따라</emphasis> 
      <literal>fooService</literal> 빈에 프로파일링과 트랜잭셔널 관점을 적용한다. <!--By *that order,* indicate whether you mean the numbered process or the above example? Or are they the same? 
TR: REVISED, PLS REVIEW. changed to 'desired'; seems clear that the desired order is profiling first followed by transactional aspect-->유사한 
      방법으로 다수의 추가 관점을 설정한다.</para>

      <para>다음 예제는 위의 설정과 같은 효과가 있지만 순수하게 XML의 선언적인 접근을 
      사용한다.</para>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:aop="http://www.springframework.org/schema/aop"
     xmlns:tx="http://www.springframework.org/schema/tx"
     xsi:schemaLocation="
   http://www.springframework.org/schema/beans 
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
   http://www.springframework.org/schema/tx 
   http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
   http://www.springframework.org/schema/aop 
   http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt;

  &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

  <lineannotation>&lt;!-- 프로파일링 어드바이스 --&gt;</lineannotation>
  &lt;bean id="profiler" class="x.y.SimpleProfiler"&gt;
    <lineannotation>&lt;!-- 트랜잭션이 적용된 어드바이스 이전에 실행된다. (그러므로 순서(order) 번호가 낮다) --&gt;</lineannotation>
    <emphasis role="bold">&lt;property name="order" value="1</emphasis>"/&gt;
  &lt;/bean&gt;

  &lt;aop:config&gt;

    &lt;aop:pointcut id="entryPointMethod" expression="execution(* x.y..*Service.*(..))"/&gt;

    <lineannotation>&lt;!-- 프로파일링 어드바이스 이후에 실행될 것이다. (order 속성을 비교해봐라) --&gt;</lineannotation>
    &lt;aop:advisor
        advice-ref="txAdvice"
        pointcut-ref="entryPointMethod"
        <emphasis role="bold">order="2</emphasis>"/&gt; <lineannotation>&lt;!-- order 값이 프로파일링 관점보다 크다 --&gt;</lineannotation>

    &lt;aop:aspect id="profilingAspect" ref="profiler"&gt;
      &lt;aop:pointcut id="serviceMethodWithReturnValue"
              expression="execution(!void x.y..*Service.*(..))"/&gt;
      &lt;aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/&gt;
    &lt;/aop:aspect&gt;

  &lt;/aop:config&gt;

  &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="get*" read-only="true"/&gt;
      &lt;tx:method name="*"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

  <lineannotation>&lt;!-- <interfacename>DataSource</interfacename>와 <interfacename>PlatformTransactionManager</interfacename>같은 다른 &lt;bean/&gt; 정의는 여기에 한다 --&gt;</lineannotation>

&lt;/beans&gt;</programlisting>

      <para>앞의 설정으로 <emphasis>순서에 따라</emphasis> 프로파일링 관점과 트랜잭셔널 관점이 
      <literal>fooService</literal> 빈에 적용될 것이다. 트랜잭셔널 어드바이스에 진입한 
      <emphasis>이후</emphasis>와 트랜잭셔널 어드바이스가 끝나기 <emphasis>전에</emphasis> 
      프로파일링 어드바이스를 실행하려고 하면 그냥 프로파일링 관점 빈의 <literal>order</literal> 
      프로퍼티 값을 트랜잭셔널 어드바이스의 order 값보다 높게 바꿔주면 된다.<!--Do you mean ...transactional advice *bean's* order value? TR: OK AS IS--></para>

      <para>추가적인 관점도 비슷한 방법으로 설정한다.</para>
    </section>

    <section id="transaction-declarative-aspectj">
      <title>AspectJ로 <interfacename>@Transactional</interfacename> 
      사용하기</title>

      <para>스프링 컨테이너 외부에서 AspectJ 관점으로 스프링 프레임워크의 
      <interfacename>@Transactional</interfacename> 지원을 사용할 수도 있다. 이렇게 하려면 
      일단 클래스(선택적으로 클래스의 메서드에)에 <interfacename>@Transactional</interfacename> 
      어노테이션을 붙히고 그 다음 <filename class="libraryfile">spring-aspects.jar</filename>에 
      정의된 <classname>org.springframework.transaction.aspectj.AnnotationTransactionAspect</classname>와 
      어플리케이션은 연결(위브, weave)한다. 관점도 반드시 트랜잭션 관리자로 설정해야 한다. 당연히 관점을 
      의존성 주입하는데 스프링 프레임워크의 IoC 컨테이너를 사용할 수 있다. 트랜잭션 관리 관점을 설정하는 
      가장 간단한 방법은 <literal>&lt;tx:annotation-driven/&gt;</literal> 요소를 사용하고 
      <xref linkend="transaction-declarative-annotations" />에서 설명한 것처럼 
      <literal>aspectj</literal>에 <literal>mode</literal> 속성을 지정하는 것이다. 여기서는 
      스프링 컨테이너 외부에서 동작하는 어플리케이션에 대해서 얘기하고 있으므로 프로그래밍적으로 설정하는 
      방법을 설명할 것이다.</para>

      <note>
        <para>계속 읽기 전에 <xref
        linkend="transaction-declarative-annotations" />와 <xref
        linkend="aop" />를 읽으면 도움이 될 것이다.</para>
      </note>

      <programlisting language="java"><lineannotation>// 적절한 트랜잭션 관리자를 생성한다 </lineannotation>
DataSourceTransactionManager txManager = new DataSourceTransactionManager(getDataSource());

<lineannotation>// 사용할 <classname>AnnotationTransactionAspect</classname>를 설정한다. 이는 반드시 트랜잭션이 적용된 어떤 메서드라도 실행하기 전에 이뤄져야 한다.</lineannotation>
AnnotationTransactionAspect.aspectOf().setTransactionManager(txManager); </programlisting>

      <note>
        <para>이 관점을 사용할 때는 클래스가 구현한 인터페이스(존재한다면)가 
        <emphasis>아니라</emphasis> <emphasis>구현</emphasis> 클래스(또는 구현클래스의 메서드)에 
        어노테이션을 붙혀야 한다. AspectJ는 인터페이스에 붙은 어노테이션은 
        <emphasis>상속받지 않는다</emphasis>는 자바의 규칙을 따른다.</para>
      </note>

      <para>클래스에 붙은 <interfacename>@Transactional</interfacename> 어노테이션은 
      클래스의 모든 메서드 실행에 대한 기본 트랜잭션 동작을 지정한다.</para>

      <para>클래스내의 메서드에 붙은 <interfacename>@Transactional</interfacename> 
      어노테이션은 클래스 어노테이션(존재한다면)이 지정한 기본 트랜잭션 동작을 덮어쓴다. 가시성에 
      상관없이 모든 메서드는 어노테이션이 붙을 수 있다.</para>

      <para><classname>AnnotationTransactionAspect</classname>으로 어플리케이션을 
      위빙하려면 어플리케이션은 AspectJ로 구성하거나(<ulink
      url="http://www.eclipse.org/aspectj/doc/released/devguide/index.html">AspectJ
      개발 가이드</ulink> 참고) 로드타입 위빙을 사용해야 한다. AspectJ를 사용하는 로드타임 
      위빙에 대한 내용은 <xref linkend="aop-aj-ltw" />를 참고해라.</para>
    </section>
  </section>

  <section id="transaction-programmatic">
    <title>프로그래밍적인 트랜잭션 관리</title>

    <para>스프링 프레임워크는 프로그래밍적인 트랜잭션 관리의 두가지 수단을 제공한다.</para>

    <itemizedlist>
      <listitem>
        <para><classname>TransactionTemplate</classname> 사용하기.</para>
      </listitem>

      <listitem>
        <para>
        <interfacename>PlatformTransactionManager</interfacename> 
        구현체를 직접 사용하기.</para>
      </listitem>
    </itemizedlist>

    <para>스프링 팀은 프로그래밍적인 트랜잭션 관리에 보통 <classname>TransactionTemplate</classname>를 
    추천한다. 두번째 접근은 예외 처리에 대한 부단이 적기는 하지만 JTA 
    <interfacename>UserTransaction</interfacename> API를 사용하는 것과 유사하다.</para>

    <section id="tx-prog-template">
      <title><classname>TransactionTemplate</classname> 사용하기</title>

      <para><classname>TransactionTemplate</classname>은 
      <classname>JdbcTemplate</classname>같은 다른 스프링 <emphasis>템플릿</emphasis>과 
      같은 접근을 채택했다. <classname>TransactionTemplate</classname>는 어플리케이션 코드가 
      보일러플레이트 획득과 트랜잭셔널 리소스의 해지에서 자유롭도록 콜백 접근을 사용한다. 그래서 코드는 
      의도지향적(intention driven)이 되고 작성한 코드는 개발자가 하고자 한것에만 오로지 
      집중할 수 있다.</para>

      <note>
        <para>다음에 예제에서 보듯이 <classname>TransactionTemplate</classname>를 
        사용하면 스프링의 트랜잭션 인프라스트럭처 API에 완전히 커플링된다. 개발요구사항에 프로그래밍적인 
        트랜잭션 관리가 적합하든지 적합하지 않든지간에 결정은 스스로 하는 것이다.</para>
      </note>

      <para>트랜잭션 컨텍스트에서 실행되어야 하고 명시적으로 
      <classname>TransactionTemplate</classname>를 사용할 어플리케이션 코드는 다음과 같다. 
      어플리케이션 개발자는 트랜잭션 컨텍스트에서 실행해야하는 코드를 담고 있는 
      <interfacename>TransactionCallback</interfacename> 구현체를 작성한다. 그 다음 작성한 
      커스텀 <interfacename>TransactionCallback</interfacename>의 인스턴스를 
      <classname>TransactionTemplate</classname>에 노출된 
      <methodname>execute(..)</methodname> 메서드에 전달한다.</para>

      <programlisting language="java">public class SimpleService implements Service {

  <lineannotation>// 이 인스턴스의 모든 메서드에서 공유되는 하나의 <classname>TransactionTemplate</classname></lineannotation>
  private final TransactionTemplate transactionTemplate;

  <lineannotation>// <interfacename>PlatformTransactionManager</interfacename>를 제공하기 위해 생성자 주입을 사용한다</lineannotation>
  public SimpleService(PlatformTransactionManager transactionManager) {
    Assert.notNull(transactionManager, "The 'transactionManager' argument must not be null.");
    this.transactionTemplate = new TransactionTemplate(transactionManager);
  }

  public Object someServiceMethod() {
    return transactionTemplate.execute(new TransactionCallback() {

      <lineannotation>// 이 메서드의 코드는 트랜잭션 컨텍스트에서 실행된다</lineannotation>
      public Object doInTransaction(TransactionStatus status) {
        updateOperation1();
        return resultOfUpdateOperation2();
      }
    });
  }
}</programlisting>

      <para>반환값이 없으면 다음과 같이 익명 클래스로 간편한 
      <classname>TransactionCallbackWithoutResult</classname> 클래스를 사용해라.</para>

      <programlisting language="java">transactionTemplate.execute(new <emphasis
          role="bold">TransactionCallbackWithoutResult</emphasis>() {

  protected void doInTransactionWithoutResult(TransactionStatus status) {
    updateOperation1();
    updateOperation2();
  }
});</programlisting>

      <para>콜백내의 코드는 제공된 <interfacename>TransactionStatus</interfacename> 
      객체의 <literal>setRollbackOnly()</literal> 메서드를 호출해서 트랜잭션을 
      롤백할 수 있다.</para>

      <programlisting language="java">transactionTemplate.execute(new TransactionCallbackWithoutResult() {

  protected void doInTransactionWithoutResult(TransactionStatus status) {
    try {
      updateOperation1();
      updateOperation2();
    } catch (SomeBusinessExeption ex) {
      <emphasis role="bold">status.setRollbackOnly();</emphasis>
    }
  }
});</programlisting>

      <section id="tx-prog-template-settings">
        <title>트랜잭션 설정 지정하기</title>

        <para>프로그래밍적으로나 설정에서 <classname>TransactionTemplate</classname>에 
        전파모드, 격리수준, 타임아웃 등의  트랜잭션 설정을 지정할 수 있다. 기본적으로 
        <classname>TransactionTemplate</classname> 인스턴스는 <link
        linkend="transaction-declarative-txadvice-settings">기본 트랜잭션 설정</link>을 
        가진다. 다음 예제는 특정 <classname>TransactionTemplate</classname>의 트랜잭션 설정을 
        프로그래밍적으로 커스터마이징한 것을 보여준다.</para>

        <programlisting language="java">public class SimpleService implements Service {

  private final TransactionTemplate transactionTemplate;

  public SimpleService(PlatformTransactionManager transactionManager) {
    Assert.notNull(transactionManager, "The 'transactionManager' argument must not be null.");
    this.transactionTemplate = new TransactionTemplate(transactionManager);

    <lineannotation>// 원한다면 트랜잭션 설정은 여기서 명시적으로 설정할 수 있다</lineannotation>
    this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);
    this.transactionTemplate.setTimeout(30); <lineannotation>// 30 초</lineannotation>
    <lineannotation>// 등등...</lineannotation>
  }
}</programlisting>

        <para>다음 예제는 스프링 XML 설정을 사용해서 몇가지 커스텀 트랜잭션 설정으로 
        <classname>TransactionTemplate</classname>를 정의한다. 
        <literal>sharedTransactionTemplate</literal>를 필요한 만큼의 서비스에 
        주입할 수 있다.</para>

        <programlisting language="xml">&lt;bean id="sharedTransactionTemplate"
    class="org.springframework.transaction.support.TransactionTemplate"&gt;
  &lt;property name="isolationLevelName" value="ISOLATION_READ_UNCOMMITTED"/&gt;
  &lt;property name="timeout" value="30"/&gt;
&lt;/bean&gt;"</programlisting>
      </section>

      <para>마지막으로 <classname>TransactionTemplate</classname> 클래스의 인스턴스들은 
      스레드세이프하므로 어떤 대화식(conversational) 상태도 유지하지 않는다. 하지만 
      <classname>TransactionTemplate</classname> 인스턴스는 설정(configuration) 상태를 
      유지<emphasis>한다.</emphasis> 그러므로 다수의 클래스가 하나의 
      <classname>TransactionTemplate</classname> 인스턴스를 공유할 것이므로 클래스가 다른 
      설정(예를 들어 다른 격리수준)의 <classname>TransactionTemplate</classname>를 사용해야 
      한다면 두 가지의 다른 <classname>TransactionTemplate</classname> 인스턴스를 
      생성해야 한다.</para>
    </section>

    <section id="transaction-programmatic-ptm">
      <title>
      <interfacename>PlatformTransactionManager</interfacename> 사용하기</title>

      <para>트랜잭션을 관리하는데 
      <interfacename>org.springframework.transaction.PlatformTransactionManager</interfacename>를 
      직접 사용할 수도 있다. 단순히 사용하는 <interfacename>PlatformTransactionManager</interfacename>의 
      구현체를 빈 레퍼런스로 빈에 전달해라. 그 다음 <interfacename>TransactionDefinition</interfacename>와 
      <interfacename>TransactionStatus</interfacename>를 사용해서 트랜잭션을 시작하고 롤백하고 
      커밋할 수 있다.</para>

      <programlisting language="java">DefaultTransactionDefinition def = new DefaultTransactionDefinition();
<lineannotation>// 트랜잭션 이름만이 프로그래밍적으로 명시적으로 설정할 수 있다</lineannotation>
def.setName("SomeTxName");
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

TransactionStatus status = txManager.getTransaction(def);
try {
  <lineannotation>// 여기의 비즈니스 로직을 실행한다</lineannotation>
}
catch (MyException ex) {
  txManager.rollback(status);
  throw ex;
}
txManager.commit(status);</programlisting>
    </section>
  </section>

  <section id="tx-decl-vs-prog">
    <title>프로그래밍적인 트랜잭션 관리와 선언적인 트랜잭션 중에서 선택하기</title>

    <para>프로그래밍적인 트랜잭션 관리는 적은 수의 트랜잭션 작업이 있을 때만 보통 좋은 생각이다. 
    예를 들어 특정 업데이트 작업에만 트랜잭션이 필요한 웹어플리케이션인 경우 스프링이나 다른 기술을 
    사용해서 트랜잭션이 적용된 프록시를 설정하기 원치 않을 것이다. 이러한 경우 
    <classname>TransactionTemplate</classname>을 사용하는 것이 좋은 접근이 될 
    <emphasis>수 있다.</emphasis> 명시적으로 트랜잭션 이름을 설정할 수 있는 것도 트랜잭션 
    관리에 프로그래밍적인 접근을 사용해서만 할 수 있는 것이다.</para>

    <para>반면에 어플리케이션에 매우 많은 트랜잭션 작업이 있다면 선언적인 트랜잭션 관리가 일반적으로 
    휼륭하다. 선언적인 트랜잭션 관리는 비즈니스 로직 외부에서 트랜잭션 관리를 하고 설정하기가 어렵지 
    않다. EJB CMT가 아니라 스프링 프레임워크를 사용할 때 선언적인 트랜잭션 관리의 설정 비용은 
    엄청나게 줄어든다.</para>
  </section>

  <section id="transaction-application-server-integration">
    <title>어플리케이션 서버에 특화된 통합</title>

    <para>스프링의 트랜잭션 추상화는 보통 어플리케이션 서버와 관계가 없다. 게다가 JTA 
    <interfacename>UserTransaction</interfacename>와 
    <interfacename>TransactionManager</interfacename> 객체들을 검색하는 JNDI를 선택적으로 
    수행하는 스프링의 <classname>JtaTransactionManager</classname> 클래스는 어플리케이션 
    서버마다 다른 <interfacename>TransactionManager</interfacename>의 위치를 자동으로 탐지한다. 
    JTA <interfacename>TransactionManager</interfacename>로의 접근해서 특히 트랜잭션 중지 
    지원같은 향상된 트랜잭션을 사용할 수 있다. 자세한 내용은 
    <classname>JtaTransactionManager</classname> Javadoc을 참고해라.</para>

    <para>스프링의 <classname>JtaTransactionManager</classname>는 Java EE 어플리케이션 
    서버에서 실행할 때의 일반적인 선택이고 별도의 설정을 하지 않고도 일반적인 모든 서버에서 동작한다고 
    알려져있다. 트랜잭션 중지같은 향샹된 기능은 다수의 서버에서 잘 동작한다.(GlassFish, JBoss, 
    Geronimo, Oracle OC4J를 포함해서) 하지만 완전한 트랜잭션 중지 지원과 더 향상된 통합을 위해서 
    스프링은 IBM WebSphere, BEA WebLogic 서버, Oracle OC4J에 대한 전용 아답터를 제공한다. 
    이러한 아답터들은 다음 섹션에서 설명한다.</para>

    <para><emphasis>WebLogic 서버, WebSphere, OC4J를 포함한 일반적인 시나리오에서는 
    간편한 <literal>&lt;tx:jta-transaction-manager/&gt;</literal> 설정요소의 
    사용을 고려해 봐라.</emphasis> 이 요소를 설정하면 의존하는 서버를 자동으로 탐지하고 플랫폼에서 
    사용할 수 있는 가장 좋은 트랜잭션 관리자를 선택한다. 즉, 서버에 특화된 아답터 클래스(앞의 섹션에서 
    설명했듯이)를 명시적으로 설정하지 않아도 된다. 반대로 아답터 클래스들은 자동으로 선택하고 기본 
    폴백(fallback)으로 표준 <classname>JtaTransactionManager</classname>를 
    사용한다.</para>

    <section id="transaction-application-server-integration-websphere">
      <title>IBM WebSphere</title>

      <para>WebSphere 6.1.0.9 이상의 버전에서 사용하길 추천하는 스프링 JTA 트랜잭션 관리자는 
      <classname>WebSphereUowTransactionManager</classname>이다. 이 전용 아답터는 
      웹스피어 어플리케이션 서버 6.0.2.19 이상의 버전과 6.1.0.9 이상의 버전에서 사용할 수 있는 
      IBM의 <interfacename>UOWManager</interfacename> API를 사용한다. 이 아답터를 
      사용하면 스프링 주도의 트랜잭션 중지(<literal>PROPAGATION_REQUIRES_NEW</literal>으로 
      시작된 것처럼 중지/복귀)를 IBM이 공식적으로 지원한다!</para>
    </section>

    <section id="transaction-application-server-integration-weblogic">
      <title>BEA WebLogic 서버</title>

      <para>웹로직 서버 9.0 이상에서는 <classname>JtaTransactionManager</classname> 
      클래스 대신 <classname>WebLogicJtaTransactionManager</classname>를 보통 사용할 
      것이다. 이 클래스는 웹로직에 특화된 클래스로 일반적인 
      <classname>JtaTransactionManager</classname>의 하위클래스로 표준 JTA 의미를 넘어 
      웹로직이 관리하는 트랜잭션 환경에서 스프링의 트랜잭션 정의를 완전히 지원한다. 트랜잭션 이름, 
      트랜잭션당 격리 수준, 모든 경우에서 트랜잭션을 적절히 복귀하는 등의 기능을 포함한다.</para>
    </section>

    <section id="transaction-application-server-integration-oc4j">
      <title>Oracle OC4J</title>

      <para>스프링은 OC4J 10.1.3 이상의 버전을 위해서 전용 아답터 클래스인 
      <classname>OC4JJtaTransactionManager</classname>를 제공한다. 이 클래스는 앞에서 
      설명한 <classname>WebLogicJtaTransactionManager</classname> 클래스와 유사해서 
      OC4J에 트랜잭션 이름, 트랜잭션당 격리 수준같은 부가가치를 제공한다.</para>

      <para>트랜잭션 중지를 포함한 전체 JTA 기능은 OC4J상에서도 스프링의 
      <classname>JtaTransactionManager</classname>로 잘 동작한다. 전용 
      <classname>OC4JJtaTransactionManager</classname> 아답터는 표준 JTA 이상의 
      부가가치를 제공할 뿐이다.</para>
    </section>
  </section>

  <section id="transaction-solutions-to-common-problems">
    <title>일반적인 문제에 대한 해결책</title>

    <section id="transaction-solutions-to-common-problems-wrong-ptm">
      <title>지정한 <interfacename>DataSource</interfacename>에 
      잘못된 트랜잭션 관리자의 사용</title>

      <para>트랜잭션 기술과 요구사항의 선택에 기반해서 <emphasis>올바른</emphasis> 
      <interfacename>PlatformTransactionManager</interfacename> 구현체를 
      사용해라.<!--for *what* requirements? Identify *their* TR: REVISED, PLS REVIEW.Clarified this a bit.-->
      적절히 사용하면 스프링 프레임워크는 단지 직관적이고 이식성있는 추상화를 제공할 뿐이다. 전역 
      트랜잭션을 사용한다면 모든 트랜잭션 작업에 
      <classname>org.springframework.transaction.jta.JtaTransactionManager</classname> 
      클래스(또는 이 클래스의 <link linkend="transaction-application-server-integration">
      하위클래스이면서 어플리케이션에 특화된 클래스</link>)를 <emphasis>반드시</emphasis> 사용해야 
      한다. 그렇지 않으면 트랜잭션 인프라스트럭처가 컨테이너 <interfacename>DataSource</interfacename> 
      인스턴스같은 리소스에 지역 트랜잭션을 수행하려고 한다. 이러한 지역 트랜잭션은 적합하지 않으며 
      좋은 어플리케이션 서버라면 에러로 취급한다.</para>
    </section>
  </section>

  <section id="transaction-resources">
    <title>관련 자료</title>

    <para>스프링 프레임워크의 트랜잭션 지원에 대한 더 자세한 정보는 다음을 참고해라.</para>

    <itemizedlist>
      <listitem>
        <para><ulink
        url="http://www.javaworld.com/javaworld/jw-01-2009/jw-01-spring-transactions.html">XA를 
        사용하든지 안하든간에 스프링에서 분산 트랜잭션</ulink>은 스프링소스의 David Syer가 
        스프링 어플리케이션에서 분산 트랜잭션의 7가지 패턴을 설명하는 JavaWorld의 발표자료이다. 
        7가지 패턴 중 3가지는 XA를 사용하고 4가지는 사용하지 않는다.</para>
      </listitem>

      <listitem>
        <para><ulink url="http://www.infoq.com/minibooks/JTDS">자바 트랜잭션 디자인 
        전략</ulink>은 <ulink url="http://www.infoq.com/">InfoQ</ulink>의 책으로 
        자바에서 트랜잭션에 대한 좋은 소개를 제공한다. 그리고 이 책은 스프링 프레임워크와 EJB3 
        모두에서 트랜잭션을 설정하고 사용하는 방법에 대한 예제들도 포함되어 있다.</para>
      </listitem>
    </itemizedlist>
  </section>
</chapter>
