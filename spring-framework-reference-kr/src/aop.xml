<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
 "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="aop">
  <title>스프링의 관점 지향 프로그래밍</title>

  <section id="aop-introduction">
    <title>소개</title>

    <para><emphasis>관점지향 프로그래밍</emphasis>(AOP, Aspect-Oriented Programming)은 
    프로그램 구조를 다른 방식으로 생각하게 함으로써 객체지향 프로그래밍(OOP, Object-Oriented 
    Programming)을 보완한다. OOP에서 모듈화의 핵심단위는 클래스이지만 AOP에서 모듈화의 핵심단위는 
    <emphasis>관점(aspect)</emphasis>이다. 관점은 다양한 타입과 객체에 걸친 트랙잭션 관리같은 
    관심(concern)을 모듈화할 수 있게 한다. (AOP 문서에서는 이러한 관심을 종종 
    <emphasis>crosscutting</emphasis> 관심이라고 부른다.)</para>

    <para>스프링의 핵심 컴포넌트중 하나는 <emphasis>AOP 프레임워크</emphasis>이다. 스프링 
    IoC 컨테이너가 AOP에 의존하지 않기 때문에(즉 필요하지 않으면 AOP를 사용하지 않아도 된다.) AOP는 
    아주 기능이 많은 미들웨어 솔루션을 제공해서 스프링 IoC를 보완한다.</para>

    <sidebar>
      <title>Spring 2.0 AOP</title>

      <para>스프링 2.0에서 <link linkend="aop-schema">스키마 기반의 접근</link>이나 
      <link linkend="aop-ataspectj">@AspectJ 어노테이션 방식</link>을 사용하서 더 
      간단하면서도 강력하게 커스텀 관점(aspect)를 작성하는 방법을 도입했다. 두 가지 방법 모두 
      완전한 타입의 어드바이스(advice)와 AspectJ 포인트컷 언어(pointcut language)를 
      제공하지만 여전히 위빙(weaving)에는 Spring AOP를 사용했다.</para>

      <para>스프링 2.0의 스키마기반이나 @AspectJ 기반의 AOP는 이번 장에서 얘기하는 것들을 
      지원한다. 스프링 2.0 AOP는 스프링 1.2 AOP와 완전한 하위호환성을 가지고 있고 
      <link linkend="aop-api">다음 장</link>에서 얘기할 스프링 1.2 API가 제공하는 
      저수준 AOP를 지원한다.</para>
    </sidebar>

    <para>스프링 프레임워크에서 사용한 AOP는...</para>

    <itemizedlist>
      <listitem>
        <para>... EJB의 선언적인 서비스의 대체제같은 선언적인 엔터프라이즈 서비스를 제공한다. 
        이러한 엔터프라이즈 서비스 중에서 가장 중요한 것은 <link
        linkend="transaction-declarative"><emphasis>선언적인 트랜잭션 
        관리</emphasis></link>이다.</para>
      </listitem>

      <listitem>
        <para>... 사용자가 OOP의 사용을 AOP로 보충하는 커스텀 관점을 구현하도록
        해준다.</para>
      </listitem>
    </itemizedlist>

    <remark><para>선언적인 제너릭 서비스나 풀링(pooling)같은 미리 패키징된 다른 선언적인 
    미들웨어 서비스에만 관심이 있다면 스프링 AOP를 직접 사용할 필요다 없고 이번 장의 대부분을 
    건너뛰어도 된다. </para></remark>

    <section id="aop-introduction-defn">
      <title>AOP 개념</title>

      <para>핵심 AOP의 개념과 용어를 정리하면서 시작해 보자. 이러한 용어들은 스프링에 
      특화된 것이 아니고 안타깝게도 AOP 용어는 그다지 직관적이지 않다. 하지만 스프링이 
      스프링만의 용어를 쓴다면 오히려 더 혼란스러울 것이다.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>관점(Aspect)</emphasis>: 여러 클레스에 걸친 관심사의 모듈화이다. 
          엔터프라이즈 자바 어플리케이션에서 트랙잭션 관리는 관신사를 보여주는 좋은 예제이다. 스프링 
          AOP는 정규 클래스(<link linkend="aop-schema">스키마기반의 접근</link>)나 
          <interfacename>@Aspect</interfacename> 어노테이션이 붙은 정규 클래스(<link
          linkend="aop-ataspectj"><interfacename>@AspectJ</interfacename>
          방식</link>)를 사용해서 관점을 구현했다.</para>
        </listitem>

        <listitem>
          <para><emphasis>조인 포인트(Join point)</emphasis>: 메서드의 실행이나 
          예외 처리같은 프로그램이 실행되는 중의 어떤 지점이다. 스프링 AOP에서 조인포인트는 
          <emphasis>항상</emphasis> 메서드 실행을 나타낸다.</para>
        </listitem>

        <listitem>
          <para><emphasis>어드바이스(Advice)</emphasis>: 특정 조인포인트에서 관점이 
          취하는 행동(action). "around", "before", "after" 어드바이스같은 여러 가지 
          타입의 어드바이스가 있다.(어드바이스의 타입은 아래에서 나와있다.) 스프링을 포함한 많은 
          AOP 프레임워크는 조인포인트 <emphasis>주위에</emphasis> 인터셉터 체인을 
          유지한다.</para>
        </listitem>

        <listitem>
          <para><emphasis>포인트컷(Pointcut)</emphasis>: 조인포인트를 매칭하는 
          것(predicate)이다. 어드바이스는 포인트컷 표현식과 연결되고 포인트컷이 매치한 
          조인포인트에서 실행된다. (예를 들어 특정이름의 메서드 실행처럼) 포인트컷 표현식과 
          일치하는 조인포인트의 개념은 AOP의 핵심이고 스프링은 기본적으로 AspectJ 포인트컷 
          표현식 언어를 사용한다.</para>
        </listitem>

        <listitem>
          <para><emphasis>인트로덕션(Introduction)</emphasis>: 타입을 대신해서 
          메서드나 필드를 추가적으로 선언한다. 스프링 AOP로 어떤 어드바이스 객체에도 새로운 
          인터페이스(와 대응하는 구현체)를 추가할 수 있다. 예를 들어 간단하게 캐싱할 수 있도록 
          <interfacename>IsModified</interfacename> 인터페이스를 구현하는 빈을 만들 
          때 인트로덕션을 사용할 수 있다.(AspectJ 커뮤니티에서는 인트로덕션을 
          인터타입(inter-type) 선언이라고 부른다.)</para>
        </listitem>

        <listitem>
          <para><emphasis>대상 객체(Target object)</emphasis>: 하나 이상의 관점으로 
          어드바이스된 객체다. <emphasis>어드바이스된(advised)</emphasis> 객체라고 부르기도 
          한다. 스프링 AOP가 런타임 프록시를 사용해서 구현되었기 때문에 이 대상 객체는 언제나 
          <emphasis>프록시된</emphasis> 객체가 될 것이다.</para>
        </listitem>

        <listitem>
          <para><emphasis>AOP 프록시</emphasis>: 관점 계약(aspect contract, 어드바이스 
          메서드 실행 등등)이 생성한 객체. 스프링 프레임워크의  AOP 프록시는 JDK 다이나믹 
          프록시나 CGLIB 프록시가 될 것이다.</para>
        </listitem>

        <listitem>
          <para><emphasis>위빙(Weaving)</emphasis>: 다른 어플리케이션 타입이나 
          어드바이즈된 객체를 생성하는 객체와 관점을 연결한다. 위빙은 컴파일시점(예를 들면 
          AspectJ 컴파일러를 사용해서), 로딩시점, 런타임시점에서 수행될 수 있다. 다른 순수한 
          자바 AOP 프레임워크와 같이 스프링 AOP도 런타임시에 위빙을 수행한다.</para>
        </listitem>
      </itemizedlist>

      <para>어드바이스의 타입</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>어드바이스 이전(Before advice)</emphasis>: 조인포인트 
          이전에 실행되는 어드바이스이지만 조인포인로 진행되는 흐름을 막을 수는 없다.(예외를 
          던지지 않는 한)</para>
        </listitem>

        <listitem>
          <para><emphasis>어드바이스 반환 후(After returning advice)</emphasis>: 
          조인 포인트가 정상적으로 완료될 후에 실행되는 어드바이스. 예를 들어 메서드가 
          예외를 던지지 않고 반환하는 경우이다.</para>
        </listitem>

        <listitem>
          <para><emphasis>어드바이스를 던진 후(After throwing advice)</emphasis>: 
          예외를 던진 메서드가 있는 경우 실행되는 어드바이스.</para>
        </listitem>

        <listitem>
          <para><emphasis>(최종적인)어드바이스 이후(After (finally) advice)</emphasis>: 
          어떤 조인포인트가 존재하는 지와 상관없이 실행되는 어드바이스(정상적이든 예외를 던지든)</para>
        </listitem>

        <listitem>
          <para><emphasis>어드바이스 주변(Around advice)</emphasis>: 메서드 호출같은 
          조인포인트를 둘러싼 어드바이스. 이 어드바이스는 어드바이스중에서 가장 강력하다. Around
          advice는 메서드 실행 이전이나 이후에 임의의 동작을 수행할 수 있다. 반환값을 반환하거나 
          예외를 던짐으로써 실행되는 어드바이스된 메서드에 대한 단축키나 어떤 조인프인트로 진행할 
          것인지 선택하는 책임을 지기도 한다.</para>
        </listitem>
      </itemizedlist>

      <para>Around advice가 가장 일반적인 어드바이스다. AspectJ처럼 스프링 AOP가 어드바이스 
      타입을 모두 제공하기 때문에 필요한 동작을 구현할 수 있는 어드바이스 중에서 가장 덜 강력한 
      어드바이스를 사용하기를 권장한다. 예를 들어 메서드의 리턴값으로 캐시를 업데이트만 하려고 한다면 
      around advice로 같은 작업을 할 수 있다로 하더라도 around advice보다는 after returning 
      advice를 구현하는 것이 더 낫다. 가장 구체적인 어드바이스를 사용함으로써 잠재적인 오류를 줄이고 
      프로그래밍 모델을 더 간단하게 할 수 있다. 예를 들어 around advice에 사용한 
      <interfacename>JoinPoint</interfacename>에서 <methodname>proceed()</methodname> 
      메서드를 호출할 필요가 없다면 <methodname>proceed()</methodname> 메서드 호출하지 
      않을 수 없다.</para>

      <para>스프링 2.0에서 모든 어드바이스 파라미터들은 정적타입이므로 
      <classname>Object</classname> 배열대신의 적절한 타입(메서드 실행 결과로 반환된 값의 
      타입같은)의 어드바이스 파라미터를 사용해야 한다.</para>

      <para>포인트컷으로 매치된 조인포인트의 개념은 인터셉트만 제공하는 오래된 다른 기술들과 AOP를 
      구분짓는 핵심개념이다. 포인트컷은 객체지향 계층에서 어드바이스가 독립적인 대상이 될 수 있게 한다. 
      예를 들어 선언적인 트랜잭션 관리를 제공하는 around advice를 다양한 객체(서비스 레이어의 모든 
      비즈니르 작업같은)에 걸친 메서드 세트에 적용할 수 있다.</para>
    </section>

    <section id="aop-introduction-spring-defn">
      <title>Spring AOP의 능력과 목표</title>

      <para>스프링 AOP는 자바로만 구현되었고 여기에는 특별한 컴파일 과정이 필요없다. 스프링 
      AOP는 클래스 로더 계층을 제어할 필요가 없으므로 서블릿 컨테이너나 어플리케이션 
      서버에서 사용하기에 적합하다.</para>

      <para>현재 스프링 AOP는 메서드 실행 조인포인트만 지원한다.(스프링 빈의 메서드를 실행하는 
      어드바이스) 핵심 스프링 AOP API를 깨뜨리지 않고도 필드 인터셉트를 추가할 수 있었지만 필드 
      인터셉트는 구현되지 않았다. 필드 접근을 어드바이스하고 조인포인트를 갱신해야 한다면 
      AspectJ같은 언어를 고려해라.</para>

      <para>AOP에 대한 스프링 AOP의 접근은 다른 대부분의 AOP 프레임워크와는 다르다. 가장 완전한 
      AOP 구현체를 제공하고자 하는 것이 아니다.(스프링 AOP가 아주 강력하기는 하지만) 오히려 
      엔터프라이즈 어플리케이션의 일반전인 문제를 해결할 수 있도록 스프링 IoC와 AOP 구현체의 
      닫힌 통합을 하려는 것이 목적이다.</para>

      <para>그러므로 스프링 프레임워크의 AOP 기능은 보통 스프링 IoC 컨테이너와 겹합해서 사용한다. 
      일반적인 빈 정의 문법(이 문법이 강력한 "autoproxying" 기능을 지원함에도)을 사용해서 관점을 
      설정한다. 이 부분이 다른 AOP 구현체와 결정적으로 다른 점이다. 아주 커다란 객체(보통 도메인 
      객체같은)를 어드바이하는 작업같은 것은 스프링 AOP로는 쉽게하거나 효율적으로 할 수 없다. 이러한 
      경우에는 AspectJ가 가장 좋은 선택이다. 하지만 AOP를 따라야 하는 엔터프라이즈 자바 
      어플리케이션의 대부분의 문제에 대해 스프링 AOP는 경험상 뛰어난 해결책을 제공한다.</para>

      <para>광범위한 AOP 해결책을 제공하기 위해 스프링 AOP는 결코 AspectJ와 경쟁하려고 하지 
      않을 것이다. 스프링 AOP같은 프록시기반의 프레임워크와 AspectJ같은 충분히 발달한 프레임워크 
      둘다 가치가 있다고 생각하고 경쟁관계라기 보다는 서로 보완하는 관계라고 생각한다. 스프링 2.0은 
      일관된 스프링기반의 어플리케이션 아키텍쳐내에서 AOP의 모든 사용을 제공할 수 있도록 스프링 AOP와 
      IoC를 어렵지않게 AspectJ와 통합했다. 이 통합은 스프링 AOP API나 AOP Alliance API(하위 
      호환성을 위해서 남아있다.)에는 영향을 끼치지 않는다. 스프링 AOP API는 
      <link linkend="aop-api">다음 장</link>을 봐라.</para>

      <note>
        <para>스프링 프레임워크의 핵심 신조중 하나는 <emphasis>비침투적인</emphasis> 특성이다. 
        이는 프레임워크에 특화된 클래스나 인터페이스를 비즈니스 모델이나 도메인모델에 추가하는 것을 
        강제하지 않는다는 것이다. 하지만 어떤 경우에는 스프링 프레임크가 스프링 프레임워크에 특화된 
        의존성을 기반코드에 추가하는 선택사항을 준다. 특정 시나리오에서는 이러한 방법으로 구현하는 것이 
        명백하게 코드를 더 읽기 쉽게 만들거나 구현하기 쉽게 만들기 때문에 이러한 선택사항을 주는 것은 
        합리적이다. 스프링 프레임워크는 (거의) 항상 선택권을 제공하므로 특정 유즈케이스나 시나리오에 
        가장 적합한 좋은 선택을 할 수 있는 자유를 가진다.</para>

        <para>이번 장과 연관된 이러한 선택 중 하나는 어떤 AOP 프레인워크(혹은 어떤 AOP 방식)을 
        선택할 것인가 하는 것이다. AspectJ와 스프링 AOP 중에서 선택할 수 있고 @AspectJ 
        어노테이션방식의 접근이나 스프링 XML 설정방식의 접근 중에서도 선택할 수 있다. 이번 장에서 
        @AspectJ 방식의 접근을 먼저 선택했다는 것을 스프링 팀이 스프링 XML 설정방식보다 
        @AspectJ 어노테이션 방식의 접근을 더 좋아한다고 받아들여서는 안된다.</para>

        <para>각 방식의 이유에 대한 자세한 내용은 <xref linkend="aop-choosing" />를 
        봐라.</para>
      </note>
    </section>

    <section id="aop-introduction-proxies">
      <title>AOP 프록시</title>

      <para>스프링 AOP는 기본적으노 AOP 프록시에 표준 J2SE <emphasis>다이나믹 
      프록시</emphasis>를 사용한다. 이는 어떤 인터페이스(또는 인터페이스의 설정)도 
      프록시할 수 있게 한다.</para>

      <para>스프링 AOP는 CGLIB 프록시를 사용할 수도 있다. CGLIB 프록시는 인터페이스보다는 
      클래스를 프록시하는데 필수적이다. 비즈니스 객체가 인터페이스를 구현하지 않았다면 기본적으로 
      CGLIB을 사용한다. 클래스보다는 인터페이스를 작성하는 것이 더 좋은 사용방법이므로 비즈니스 
      클래스는 보통 하나 이상의 비즈니스 인터페이스를 구현할 것이다. 인터페이스에 선언되지 않은 
      메서드를 어드바이즈해야 하거나 고정된(concrete) 타입인 것처럼 메서드에 프록시한 객체를 
      전달해야 하는 경우에(드문 경우이길 바란다) <link
      linkend="aop-autoproxy-force-CGLIB">CGLIB을 사용하도록 강제</link>할 
      수 있다.</para>

      <para>스프링 AOP가 <emphasis>프록시 기반</emphasis>이라는 것은 중요하므로 
      꼭 이해해야 한다. 이 구현체의 세부사항들이 실제로 무엇을 의미하는 지에 대한 철저한 
      조사는 <xref linkend="aop-understanding-aop-proxies" />를 봐라.</para>
    </section>
  </section>

  <section id="aop-ataspectj">
    <title>@AspectJ 지원</title>

    <para>@AspectJ는 자바 5 어노테이션이 붙은 정규 자바 클래스처럼 관점을 선언하는 방식을 
    사용한다. @AspectJ 방식은 AspectJ 5 릴리즈의 일부인 <ulink 
    url="http://www.eclipse.org/aspectj">AspectJ 프로젝트</ulink>에서 도입되었다. 
    스프링 2.0은 포인트컷을 파싱하고 매칭하는데 AspectJ가 제공하는 라이브러리를 사용해서 
    AspectJ 5와 같은 어노테이션을 해석한다. 하지만 AOP 런타임은 여전히 순수 스프링 AOP이고 
    AspectJ 컴파일러나 위버(weaver)에 대한 의존성은 없다.</para>

    <remark><para>AspectJ 컴파일러와 위버(weaver)를 사용하면 전체 AspectJ 언어를 
    사용할 수 있으며 <xref linkend="aop-using-aspectj" />에서 
    설명한다.</para></remark>

    <section id="aop-aspectj-support">
      <title>@AspectJ 지원 활성화하기</title>

      <para>스프링 설정에서 @AspectJ 관점을 사용하려면 @AspectJ 관점에 기반한 스프링 AOP 
      설정을 지원하도록 활성화해야 하고 <emphasis>autoproxying</emphasis> 빈들은 이러한 
      관점이 어드바이즈하는지 안하는 지에 따라 달라진다. autoproxying이 의미하는 바는 빈이 하나 
      이상의 관점으로 어드바이즈 되는 지를 스프링이 결정한다는 것이고 해당 빈의 메서드 호출을 가로채고 
      필요할 때 어드바이스를 실행할 수 있도록 자동으로 프록시를 생성할 것이다.</para>

      <para>스프링 설정내에 다음 요소를 추가해서 @AspectJ 지원을 활성화한다.</para>

      <programlisting language="xml">&lt;aop:aspectj-autoproxy/&gt;</programlisting>

      <para>여기서는 <xref linkend="xsd-config" />에서 설명한 스키마 지원을 사용한다고 
      가정한다. aop 네임스페이스에서 태그를 어떻게 임포트하는 지에 대해서는 <xref
      linkend="xsd-config-body-schemas-aop" />를 봐라.</para>

      <para>DTD를 사용하는 경우에도 어플리케이션 컨텍스트에 다음의 정의를 추가해서 @AspectJ 
      지원을 활성화할 수 있다.</para>

      <programlisting language="xml">&lt;bean class="org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator" /&gt;</programlisting>

      <para>그리고 어플리케이션의 클래스패스에 AspectJ의 
      <filename class="libraryfile">aspectjrt.jar</filename> 라이브러리가 필요하다. 
      이 라이브러리는 AspectJ 배포판의 <filename class="directory">'lib'</filename> 
      디렉토리에서나 메이븐 중앙저장소를 통해서 찾을 수 있다.</para>
    </section>

    <section id="aop-at-aspectj">
      <title>관점 선언</title>

      <para>@AspectJ 지원이 활성화되면 어플리케이션 컨텍스트에서 @AspectJ 관점인 클래스
      (<interfacename>@Aspect</interfacename> 어노테이션이 붙어있다.)로 정의된 모든 
      빈을 스프링이 자동으로 탐지할 것이고 스프링 AOP를 설정하는데 사용한다. 다음 예제는 아주 
      유용하지는 않은 관점에 대한 최소한의 필수 정의를 보여준다.</para>

      <para><interfacename>@Aspect</interfacename> 어노테이션이 붙은 빈 클래스를 
      가리키는 어플리케이션 컨텍스트의 정규 빈 정의.</para>

      <programlisting language="xml">&lt;bean id="myAspect" class="org.xyz.NotVeryUsefulAspect"&gt;
   <lineannotation>&lt;!-- 평소처럼 관점의 프로퍼티를 여기에 설정한다 --&gt;</lineannotation>
&lt;/bean&gt;
</programlisting>

      <para>다음은 
      <interfacename>org.aspectj.lang.annotation.Aspect</interfacename> 
      어노테이션이 붙은 <classname>NotVeryUsefulAspect</classname> 클래스 
      정의다.</para>

      <programlisting language="java">package org.xyz;
import org.aspectj.lang.annotation.Aspect;

@Aspect
public class NotVeryUsefulAspect {

}</programlisting>

      <para>관점(<interfacename>@Aspect</interfacename> 어노테이션이 붙은 클래스들)은 
      다른 클래스와 마찬가지로 메서드와 필드를 가질 것이다. 이 관점들은 포이트컷, 어드바이스, 
      인트로덕션(inter-type) 선언도 포함할 것이다.</para>

      <note>
        <title>컴포넌트 스캔으로 관점을 자동으로 탐지하기</title>

        <para>스프링 XML 설정에서 다른 정규 빈들처럼 관점 클래스들을 등록하거나 클래스패스 
        스캐닝으로 관점 클래스들을 자동으로 탐지할 것이다. 이는 스프링이 관리하는 다른 빈들과 
        동일하다. 하지만 클래스패으세어 자동으로 탐지하기에 <emphasis>@Aspect</emphasis> 
        어노테이션은 충분하지 <emphasis>않다</emphasis>. 자동으로 탐지하기 위해서는 별도의 
        <emphasis>@Component</emphasis> 어노테이션을 추가해야 한다.(아니면 대신 스프링의 
        컴포넌트 스캐너의 규칙마다 제한을 하는 커스텀 스테레오타입 어노테이션을 추가해야 한다.)</para>
      </note>

      <note>
        <title>관점을 다른 관점들과 함께 어드바이징하기?</title>

        <para>스프링 AOP에서 관점 자체는 다른 관점의 어드바이스 타겟이 될 수 
        <emphasis>없다</emphasis>. 클래스에 붙은 <emphasis>@Aspect</emphasis> 
        어노테이션은 클래스가 관점이라는 것을 표시하므로 오토프록싱에서 제외된다.</para>
      </note>
    </section>

    <section id="aop-pointcuts">
      <title>포인트컷 선언</title>

      <para>포인트컷을 호출하는 것은 관심(interest)의 조인포인터를 결정하므로 어드바이스를 
      실행할 때 제어할 수 있도록 한다. <emphasis>스프링 AOP는 스프링 빈에 대한 메서드 실행 
      조인포인트만 지원하므로</emphasis> 포인트컷을 스프링 빈에서 메서드의 실행을 매칭하는 것으로 
      생각할 수 있다. 포인트컷 선언은 두 부분으로 나누어져 있다. 이름과 파라미터들로 구성된 시그니와 
      관심을 가지는 것이 <emphasis>정확히</emphasis> 어던 메서드 실행인지를 결정하는 포인트컷 
      표현식 두 부분이다. @AspectJ 어노테이션 방식의 AOP에서 포인트컷 시그니쳐는 정규 메서드 정의로 
      제공하고 포인트컷 표현식은 <interfacename>@Pointcut</interfacename> 어노테이션을 
      사용해서 나타낸다.(포인트컷 시그니처로 제공되는 메서드는 <emphasis>반드시</emphasis> 
      <literal>void</literal> 반환타입이 되어야 한다.)</para>

      <para>다음 예제는 포인트컷 시그니처와 포인트컷 표현식을 명확하게 구별하는데 도움을 줄 것이다. 
      다음 에제는 <literal>'transfer'</literal>라는 이름의 메서드의 실행과 매칭될 
      <literal>'anyOldTransfer'</literal>라는 이름의 포인트컷을 정의한다.</para>

      <programlisting language="java">@Pointcut("execution(* transfer(..))")<lineannotation>// 포인트컷 표현식</lineannotation>
private void anyOldTransfer() {}<lineannotation>// 포인트컷 시그니처</lineannotation></programlisting>

      <para><interfacename>@Pointcut</interfacename> 어노테이션의 값을 가진 포인트컷 
      표현식은 정식 AspectJ 5 포인트컷 표현식이다. AspectJ의 포인트컷 언어에 대한 전체 내용은 <ulink
      url="http://www.eclipse.org/aspectj/doc/released/progguide/index.html">AspectJ
      Programming Guide</ulink> (그리고 자바 5에 기반한 확장에 대한 <ulink
      url="http://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html">AspectJ
      5 Developers Notebook</ulink>)이나 Colyer et. al.가 쓴 
      <quote>Eclipse AspectJ</quote>와 Ramnivas Laddad가 쓴 
      <quote>AspectJ in Action</quote> 같은 AspectJ 책들을 봐라.</para>

      <section id="aop-pointcuts-designators">
        <title>지원되는 포인트컷 지정자(Designator)</title>

        <para>스프링 AOP는 포인트컷 표현식에서 사용하는 다음의 AspectJ 포인트컷 
        지정자(AspectJ pointcut designators, PCD)를 지원한다.</para>

        <sidebar>
          <title>그 밖의 포인트컷 타입</title>

          <para>완전한 AspectJ 포인트컷 언어는 스프링이 지원하지 않는 추가적인 포인트컷 지정자를 
          지원한다. 이러한 지정자에는 <literal>call, get, set, preinitialization, 
          staticinitialization, initialization, handler, adviceexecution, 
          withincode, cflow, cflowbelow, if, @this, @withincode</literal>가 있다. 
          스프링 AOP가 해석하는 포인트컷 표현식에서 이러한 포인트컷 지정자를 사용하면 
          <classname>IllegalArgumentException</classname>가 던져질 것이다.</para>

          <para>AspectJ 포인트컷 지정자를 더 지원하기 위해 스프링 AOP가 지원하는 포인트컷 
          지정자의 세트는 차후 버전에서는 늘어날 것이다.</para>
        </sidebar>

        <itemizedlist>
          <listitem>
            <para><emphasis>execution</emphasis> - 실행 메서드 조인포인트를 위한 
            것으로 스프링 AOP를 사용할 때 주요 포인트컷 지정자이다.</para>
          </listitem>

          <listitem>
            <para><emphasis>within</emphasis> - 매칭할 조인포인트를 특정 타입으로 
            제한한다.(스프링 AOP를 사용할 때 매칭한 타입내에서 선언된 메서드의 
            실행이다.)</para>
          </listitem>

          <listitem>
            <para><emphasis>this</emphasis> - 매칭할 조인포인트(스프링 AOP를 사용하는 
            경우 메서드의 실행)를 빈 참조(스프링 AOP 프록시)가 전달한 타입의 인스턴스인 
            경우로 제한한다.</para>
          </listitem>

          <listitem>
            <para><emphasis>target</emphasis> - 매칭할 조인포인트(스프링 AOP를 사용하는 
            경우 메서드의 실행)를 대상객체(어플리케이션 객체는 프록시된다.)가 전달한 타입의 
            인스턴스 인 경우로 제한한다.</para>
          </listitem>

          <listitem>
            <para><emphasis>args</emphasis> - 매칭할 조인포인트(스프링 AOP를 사용하는 
            경우 메서드의 실행)를 아규먼트가 전달한 타입의 인스턴스인 경우로 제한한다.</para>
          </listitem>

          <listitem>
            <para><emphasis><interfacename>@target</interfacename></emphasis>
            - 매칭할 조인포인트(스프링 AOP를 사용하는 경우 메서드의 실행)를 실행하는 객체의 
            클래스가 전달한 타입의 어노테이션이 붙어있는 경우로 제한한다.</para>
          </listitem>

          <listitem>
            <para><emphasis><interfacename>@args</interfacename></emphasis> -
            매칭할 조인포인트(스프링 AOP를 사용하는 경우 메서드의 실행)를 전달된 실제 아규먼트의 
            런타임 타입이 전달한 타입의 어노테이션이 붙어있는 경우로 제한한다.</para>
          </listitem>

          <listitem>
            <para><emphasis><interfacename>@within</interfacename></emphasis>
            - 매칭할 조인포인트를 전달한 어노테이션이 붙은 타입으로 제한한다. (스프링 AOP를 사용할 
            때 전달한 어노테이션이 붙은 타입에 선언된 메서드의 실행)</para>
          </listitem>

          <listitem>
            <para><emphasis>@annotation</emphasis> - 매칭할 조인포인트를 조인포인트의 
            주체(스프링 AOP에서 실행되는 메서드)가 전달한 어노테이션이 붙어있는 경우로 
            제한한다.</para>
          </listitem>
        </itemizedlist>

        <para>스프링 AOP가 메서드 실행 조인포인트만 매칭하기 때문에 위의 포인트컷 지정자에 대한 
        설명은 AspectJ 프로그래밍 가이드보다는 더 좁은 정의를 하고 있다. 게다가 AspectJ 자체는 
        타입기반의 시맨틱이고 조인포인트를 실행할 때 '<literal>this</literal>'와 
        '<literal>target</literal>' 둘 다 같은 객체 즉 메서드를 실행하는 객체를 참조한다. 
        스프링 AOP는 프록시기반의 시스템이고 프록시 객체 자체와('<literal>this</literal>'로 
        바인딩된다) 프록시 뒤의 대상객체('<literal>target</literal>'로 바인딩된다)를 
        구별한다.</para>

        <note>
          <para>스프링 AOP 프레임워크의 프록시에 기반한 특성으로 인해 프로텍티드(protected) 
          메서드는 JDK 프록시(적용가능하지도 않다.)와 CGLIB 프록시(기술적으로는 가능하지만 AOP 
          목적에 따라 추천하지 않는다.)로 당연히 인터셉트되지 <emphasis>않는다</emphasis>. 
          그 결과 주어진 포인트컷은 모두 <emphasis>퍼블릭 메서드에만</emphasis> 매칭될 
          것이다! </para>

          <para>protected/private 메서드나 생성자를 인터셉트해야 한다면 스프링의 프록시기반 
          AOP 프레임워크 대신에 스프링주도(Spring-driven) <link linkend="aop-aj-ltw">
          네이티브 AspectJ 위빙</link>의 사용을 고려해 봐라. 이는 다른 특성을 가진 AOP 
          사용방법에 대한 다른 모드로 구성되어 있으므로 선택을 하지 전에 먼저 위빙에 
          익숙한지 생각해봐라.</para>
        </note>

        <para>스프링 AOP는 '<literal>bean</literal>'이라는 이름의 추가적인 PCD도 지원한다. 
        이 PCD로 매칭할 조인포인트를 특정 이름의 스프링 빈이나 빈의 세트(와일드카드 사용시)로 
        제한할 수 있다. '<literal>bean</literal>' PCD는 다음의 형식을 가진다.</para>

        <programlisting language="java">bean(idOrNameOfBean)</programlisting>

        <para>'<literal>idOrNameOfBean</literal>' 토큰은 어떤 스프링 빈의 이름도 
        될 수 있다. '<literal>*</literal>' 문자로 와일드카드를 사용한 제한도 제공하므로 
        스프링 빈이 어떤 네이밍 관례를 따르고 있다면 아주 쉽게 필요한 빈을 선택하는 
        '<literal>bean</literal>' PCD 표현식을 작성할 수 있다. 다른 포인트컷 지정자를 
        사용하는 경우 '<literal>bean</literal>' PCD는 &amp;&amp;, ||, 
        !(부정)도 될 수 있다.</para>

        <note>
          <para>'<literal>bean</literal>' PCD는 스프링 AOP<emphasis>에서만</emphasis> 
          지원되고 네이티브 AspectJ 위빙에서는 <emphasis>지원하지 않는다</emphasis>. 
          이는 AspectJ가 정의한 표준 PCD에 대한 스프링에 한정된 확장이다.</para>

          <para>'<literal>bean</literal>' PCD는 타입 수준에서만이(어떤 
          위빙기반의 AOP가 제한하는 지) 아니라 <emphasis>인스턴스</emphasis> 
          수준(스프링 빈 이름 개념을 이루는)에서 수행된다. 인스턴스 기반의 포인트컷 
          지정자는 스프링 빈 팩토리와 닫힌 통합을 하는 스프링의 프록시기반 AOP 프레임워크의 
          특별한 기능이고 이름으로 특정 빈을 식별하는 것이 자연스럽고 직관적이다.</para>
        </note>
      </section>

      <section id="aop-pointcuts-combining">
        <title>포인트컷 표현식 결합하기</title>

        <para>'&amp;&amp;', '||', '!'를 사용해서 포인트컷 표현식을 결합할 수 있고 이름으로 
        포인트컷 표현식을 참조하는 것도 가능한다. 다음 예제는 3가지 포인트컷 표현식을 보여준다. 
        <literal>anyPublicOperation</literal> (메서드 실행 조인포인트가 어느 퍼블릭 
        메서드의 실행을 나타나는 지 매칭한다.), <literal>inTrading</literal> (trading 
        모듈에 있는 메서드 실행을 매칭한다.), <literal>tradingOperation</literal> 
        (메서드 실행이 trading 모듈의 어느 퍼블릭 메서드를 나타내는지 매칭한다.)</para>

        <programlisting language="java">    @Pointcut("execution(public * *(..))")
    private void anyPublicOperation() {}
    
    @Pointcut("within(com.xyz.someapp.trading..*)")
    private void inTrading() {}
    
    @Pointcut("anyPublicOperation() &amp;&amp; inTrading()")
    private void tradingOperation() {}</programlisting>

        <para>위에서 보여줬듯이 이름있고 작은 컴포넌트들로 더 복잡한 포인트컷 표현식을 작성하는 
        것이 가장 좋은 사용방법이다. 이름으로 포인트컷을 참조하는 경우 일반적인 자바의 가시성 규칙이 
        적용된다. (같은 타임에서 프라이빗 포인트컷을, 계층에서는 프로텍티드 포잇트컷을 볼 수 있고 
        퍼블릭 포인트컷은 어디서나 볼 수 있다.) 가시성은 포잇트컷 <emphasis>매칭</emphasis>에는 
        영향을 주지 않는다.</para>
      </section>

      <section id="aop-common-pointcuts">
        <title>공통 포잇트컷 정의 공유하기</title>

        <para>엔터프라이즈 어플리케이션을 개발할 때는 때로 여러 관점에서 어플리케이션의 모듈을 
        참조하거나 작업의 특정 세트를 참조할 필요가 있다. 이러한 경우에는 공통 포인트컷 표현식을 
        가진 "SystemArchitecture" 관점을 정의하는 것을 추천한다. 이러한 관점은 일반적으로 
        다음과 같이 생겼다.</para>

        <programlisting language="java">package com.xyz.someapp;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
public class SystemArchitecture {

  <lineannotation>/**
   * 메서드가 com.xyz.someapp.web 패키지나 그 하위 패키지에 있는 
   * 타입에서 정의되었다면 조인포인트는 웹계층에 있다.
   */</lineannotation>
  @Pointcut("within(com.xyz.someapp.web..*)")
  public void inWebLayer() {}

  <lineannotation>/**
   * 메서드가 <literal>com.xyz.someapp.service</literal> 패키지나
   * 그 하위 패키지에 있는 타입에서 정의되었다면 
   * 조인포인트는 서비스계층에 있다.
   */</lineannotation>
  @Pointcut("within(com.xyz.someapp.service..*)")
  public void inServiceLayer() {}

  <lineannotation>/**
   * 메서드가 <literal>com.xyz.someapp.dao</literal> 패키지나
   * 그 하위 패키지에 있는 타입에서 정의되었다면 
   * 조인포인트는 데이터계층에 있다.
   */</lineannotation>
  @Pointcut("within(com.xyz.someapp.dao..*)")
  public void inDataAccessLayer() {}

  <lineannotation>/**
   * 비즈니스 서비스는 서비스 인터페이스에 정의된 어떤 메서드의 실행이다.
   * 이 정의는 인터페이스가 "service" 패키지에 있고 그 구현체 타입은 하위 패키지에 있다고 
   * 가정한다.
   * 
   * 서비스 인터페이스를 기능적인 영역으로 구분지었다면(예를 들어
   * <literal>com.xyz.someapp.abc.service</literal>나 <literal>com.xyz.def.service</literal>패키지)
   * 대신 "<literal>execution(* com.xyz.someapp..service.*.*(..))</literal>"
   * 포인트컷 표현식을 사용한다.
   *
   * 그 대신 "<literal>bean(*Service)</literal>"같은 '<literal>bean</literal>' PCD를
   * 사용한 표현식을 작성할 수 있다.(이는 스프링의 서비스 빈에 일관적인 방법으로 이름을 지었다고
   * 가정한다.)
   */</lineannotation>
  @Pointcut("execution(* com.xyz.someapp.service.*.*(..))")
  public void businessService() {}
  
  <lineannotation>/**
   * 데이터 접근작업은 dao 인터페이스에 정의된 어떤 메서드의 실행이다.
   * 이 정의는 인터페이스가 "<literal>dao</literal>" 패키지에 있고 그 구현체 타입은
   * 하위 패키지에 있다고 가정한다.
   */</lineannotation>
  @Pointcut("execution(* com.xyz.someapp.dao.*.*(..))")
  public void dataAccessOperation() {}

}</programlisting>

        <para>이러한 a9n 관점에서 정의한 포인트컷은 포인트컷 표현식이 필요한 어디서도 참조할 
        수 있다. 예를 들어 서비스계층이 트랙잭션이 되도록 하려면 다음과 같이 작성할 수 
        있다.</para>

        <programlisting language="xml">&lt;aop:config&gt;
  &lt;aop:advisor 
      pointcut="com.xyz.someapp.SystemArchitecture.businessService()"
      advice-ref="tx-advice"/&gt;
&lt;/aop:config&gt;

&lt;tx:advice id="tx-advice"&gt;
  &lt;tx:attributes&gt;
    &lt;tx:method name="*" propagation="REQUIRED"/&gt;
  &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</programlisting>

        <para><literal>&lt;aop:config&gt;</literal>요소와 
        <literal>&lt;aop:advisor&gt;</literal>요소는 <xref 
        linkend="aop-schema" />에서 설명한다. 트랜잭션 요소는 
        <xref linkend="transaction" />에서 설명한다.</para>
      </section>

      <section id="aop-pointcuts-examples">
        <title>예제</title>

        <para>스프링 AOP 사용자들은 <literal>execution</literal> 포인트컷 지정자를 
        가장 많이 사용할 것이다. execution 표현식의 형식은 다음과 같다.</para>

        <programlisting language="java">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)
          throws-pattern?)</programlisting>

        <para>반환하는 타입 패턴(위의 예제에서 ret-type-pattern), 이름 패턴, 파라미터 패턴을 
        제외한 모든 부분은 선택사항이다. 반환하는 타입 패턴은 일치하는 조인포인트를 찾기 위해 메서드가 
        어떤 타입을 반환해야 하는지를 결정한다. 반환하는 타입 패턴에 어떤 반환 타입도 매칭할 수 있도록 
        <literal>*</literal>를 가장 자주 사용할 것이다. 정규화된 타입 이름은 메서드가 주어진 
        타입을 반환할 때만 매칭될 것이다. 이름 패턴은 메서드의 이름을 매칭한다. 이름 패턴에에서 전체나 
        일부분에 <literal>*</literal> 와일드카드를 사용할 수 있다. 파라미터 패턴은 약간 더 복잡하다. 
        <literal>()</literal>는 파라미터가 없는 메서드와 매칭되지만 <literal>(..)</literal>는 
        파라미터의 갯수와 상관없이(0 또는 그 이상) 매칭한다. <literal>(*)</literal> 패턴은 어떤 
        타입이든 하나의 파라미터를 받는 메서드와 매칭되고 <literal>(*,String)</literal>는 2개의 
        파라미터를 받지만 첫 파라미터는 타입이 상관없고 두번째 파라미터는 String이어야 하는 메서드와 
        매칭된다. 더 자세한 내용은 AspectJ Programming Guide의 <ulink
        url="http://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html">
        Language Semantics</ulink> 섹션을 참고해라.</para>

        <para>다음은 일반적인 포인트컷 표현식의 몇가지 예제이다.</para>

        <itemizedlist>
          <listitem>
            <para>모든 퍼블릭 메서드의 실행</para>

            <programlisting language="java">execution(public * *(..))</programlisting>
          </listitem>

          <listitem>
            <para>이름이 "set"로 시작하는 모든 메서드의 실행</para>

            <programlisting language="java">execution(* set*(..))</programlisting>
          </listitem>

          <listitem>
            <para><interfacename>AccountService</interfacename>
            인터페이스가 정의한 모든 메서드의 실행</para>

            <programlisting language="java">execution(* com.xyz.service.AccountService.*(..))</programlisting>
          </listitem>

          <listitem>
            <para>service 패키지에서 정의된 모든 메서드의 실행</para>

            <programlisting language="java">execution(* com.xyz.service.*.*(..))</programlisting>
          </listitem>

          <listitem>
            <para>service 패키지나 그 하위 패키지에서 정의한 모든 메서드의 실행</para>

            <programlisting language="java">execution(* com.xyz.service..*.*(..))</programlisting>
          </listitem>

          <listitem>
            <para>service 패키지내의 모든 조인포인트(스프링 AOP에서는 메서드 실행만 
            가능)</para>

            <programlisting language="java">within(com.xyz.service.*)</programlisting>
          </listitem>

          <listitem>
            <para>service 패키지나 그 하위 패키지내의 모든 조인포인트(스프링 AOP에서는 
            메서드 실행만 가능)</para>

            <programlisting language="java">within(com.xyz.service..*)</programlisting>
          </listitem>

          <listitem>
            <para>프록시가 <interfacename>AccountService</interfacename> 인터페이스를 
            구현한 모든 조인포인트(스프링 AOP에서는 메서드 실행만 가능)</para>

            <programlisting language="java">this(com.xyz.service.AccountService)</programlisting>

            <remark><para>바인딩 형식에서는 'this' 를 더 일반적으로 사용한다. 어드바이스 
            바디에서 어떻게 프록시 객체를 사용가능하도록 만드는지는 어드바이스 부분에 
            나오는 섹션을 봐라.</para></remark>
          </listitem>

          <listitem>
            <para>대상 객체가 <interfacename>AccountService</interfacename> 
            인터페이스를 구현한 모든 조인포인트(스프링 AOP에서는 메서드 실행만 가능)</para>

            <programlisting language="java">target(com.xyz.service.AccountService)</programlisting>

            <remark><para>바인딩 형식에서는 'target'을 더 일반적으로 사용한다. 어드바이스
            바디에서 어떻게 대상 객체를 사용가능하도록 만드는 지는 어드바이스 부분에
            나오는 섹션을 봐라.</para></remark>
          </listitem>

          <listitem>
            <para>하나의 파라미터를 받고 런타임시에 전달된 아규먼트가 
            <interfacename>Serializable</interfacename>인 모든 
            조인포인트(스프링 AOP에서는 메서드 실행만 가능)</para>

            <programlisting language="java">args(java.io.Serializable)</programlisting>

            <remark>바인딩 형식에서는 'args'을 더 일반적으로 사용한다. 어드바이스 바디에서
            어떻게 메서드 아규먼트를 사용가능하도록 만드는 지는 어드바이스 부분에 나오는
            섹션을 봐라.</remark>

            <para>이 예제에서 주어진 포인트컷은 
            <literal>execution(* *(java.io.Serializable))</literal>와는 다르다. 
            args 방식은 런타임시에 전달된 아규먼트가 Serializable하는 경우 매칭되고 execution 
            방식은 메서드 시그니처가 <interfacename>Serializable</interfacename> 타입의 
            단일 파라미터를 선언한 경우에 매칭된다.</para>
          </listitem>

          <listitem>
            <para>대상 객체에 <interfacename>@Transactional</interfacename> 어노테이션이 
            붙어있는 모든 조인포인트(스프링 AOP에서는 메서드 실행만 가능)</para>

            <programlisting language="java">@target(org.springframework.transaction.annotation.Transactional)</programlisting>

            <remark><para>바인딩 형식에서는 '@target'도 사용할 수 있다. 어드바이스 
            바디에서 어떻게 어노테이션 객체를 사용할 수 있게 만드는지는 어드바이스 부분에 
            나오는 섹션을 봐라.</para></remark>
          </listitem>

          <listitem>
            <para>대상 객체에 선언된 타입에 <interfacename>@Transactional</interfacename> 
            어노테이션이 붙어있는 모든 조인포인트(스프링 AOP에서는 메서드 실행만 가능)</para>

            <programlisting language="java">@within(org.springframework.transaction.annotation.Transactional)</programlisting>

            <remark><para>바인딩 형식에서는 '@within'도 사용할 수 있다. 어드바이스 
            바디에서 어떻게 어노테이션 객체를 사용할 수 있게 만드는지는 어드바이스 부분에 
            나오는 섹션을 봐라.</para></remark>
          </listitem>

          <listitem>
            <para>실행하는 메서드에 <interfacename>@Transactional</interfacename> 
            어노테이션이 붙은 모든 조인포인트(스프링 AOP에서는 메서드 실행만 가능)</para>

            <programlisting language="java">@annotation(org.springframework.transaction.annotation.Transactional)</programlisting>

            <remark><para>바인딩 형식에서는 '@annotation'도 사용할 수 있다. 어드바이스
            바디에서 어떻게 어노테이션 객체를 사용할 수 있게 만드는지는 어드바이스 부분에
            나오는 섹션을 봐라.</para></remark>
          </listitem>

          <listitem>
            <para>하나의 파라미터만 받고 전달된 아규먼트의 런타임 타입에 
            <interfacename>@Classified</interfacename> 어노테이션이 붙어있는 모든 
            조인포인트(스프링 AOP에서는 메서드 실행만 가능)</para>

            <programlisting language="java">@args(com.xyz.security.Classified)</programlisting>

            <remark><para>바인딩 형식에서는 '@args'도 사용할 수 있다.어드바이스 바디에서
            어떻게 어노테이션 객체를 사용할 수 있게 만드는지는 어드바이스 부분에 나오는
            섹션을 봐라.</para></remark>
          </listitem>

          <listitem>
            <para>'<literal>tradeService</literal>'이라는 이름의 스프링 빈에 대한 모든 
            조인포인트(스프링 AOP에서는 메서드 실행만 가능)</para>

            <programlisting language="java">bean(tradeService)</programlisting>
          </listitem>

          <listitem>
            <para>와일드카드 표현식 '<literal>*Service</literal>'와 일치하는 이름의 
            스프링 빈에 대한 모든 조인포인트(스프링 AOP에서는 메서드 실행만 가능)</para>

            <programlisting language="java">bean(*Service)</programlisting>
          </listitem>
        </itemizedlist>
      </section>
      <section id="writing-good-pointcuts">
        <title>좋은 포인트컷 작성하기</title>

        <para>AspectJ는 매칭 성능을 최적화하기 위해 컴파일 중에 포인트컷을 처리한다. 코드를 검사하고 각 조인포인트가 
        주어진 포인트컷과 일치하는지(정적으로나 동적으로나) 결정하는 것은 비용이 많이 드는 작업이다.(동적 매칭은 정적 
        분석으로는 매칭을 완전히 결정할 수 없어서 코드가 실행될 때 실제로 매칭되는지 결정하는 테스트를 코드에 둔다.) 
        첫 포인트컷 선언을 만났을 때 AspectJ는 매칭 프로세스에 최적인 형식으로 포인트컷을 재작성 할 것이다. 이것이 
        무엇을 의미하는가? 기본적으로 포인트컷은 DNF (Disjunctive Normal Form)에서 재작성되고 포인트컷의 컴포넌트들이 
        정렬되어 있기 때문에 평가하는데 비용이 적게 드는 컴포넌트를 먼저 확인할 것이다. 이는 다양한 포인트컷 지정자의 성능을 
        이해해야 하는지 걱정하지 않아도 되고 포인트컷 선언에서 아무 순서로나 컴포넌트들을 제공할 것이다.</para>
        
        <para>하지만 AspectJ는 AspectJ가 지정해 준 것과만 동작할 수 있으므로 최적의 매칭 성능을 위해서는 정의할 때 
        가능한한 매치에 대한 검색 영역을 획득하고 한정하도록 고민해 봐야한다. 존재하는 지정자들은 자연스럽게 세가지 그룹으로 
        나누어진다. 종류(kinded), 범위(scoping), 컨텍스트(context) 세가지 그룹니다.</para>
        <itemizedlist>
          <listitem><para>종류 지정자(Kinded designator)는 조인포인트의 특수한 종류를 선택한다. 예를 들면 execution, get, set, call, handler 이다.</para></listitem>
          <listitem><para>범위 지정자(Scoping designator)는 관심있는 조인포인트의 그룹을(아마도 많은 종류의) 선택한다. 예를 들면 within, withincode 이다.</para></listitem>
          <listitem><para>컨텍스트 지정자(Contextual designator)는 컨텍스트에 기반해서 매칭한다.(그리고 선택적으로 바인딩한다.) 예를 들어 this, target, @annotation 이다.</para></listitem>
        </itemizedlist>
        
        <para>잘 작성된 포인트컷은 최소한 앞의 두 타입(종류와 범위)에 속해야하고 컨텍스트 지정자는 조인포인트 컨텍스트에 
        기반해서 매칭해야 하거나 어드바에스에서 사용할 목적으로 컨텍스트를 바인딩하는 경우에 사용한다. 그냥 종류 지정자를 
        제공하거나 컨텍스트 지정자를 제공하는 것 모두 잘 동작할 것이지만 여분의 모든 처리와 분석때문에 위빙 성능(사용되는 
        시간과 메모리)에 영향을 줄 것이다. 범위 지정자는 매칭이 아주 빠르고 범위 지정자를 사용한다는 것은 AspectJ가 더 
        처리되지 않아도 되는 조인포인트의 그룹을 아주 빠르게 제거할 수 있다는 의미이다. 이것이 좋은 포인트컷은 가능한한 
        항상 하나만 포함하는가 하는 이유이다.</para> 
      </section>
    </section>

    <section id="aop-advice">
      <title>어드바이스 선언</title>

      <para>어드바이스는 포인트컷 표현식과 연결되고 포인트컷과 채킹된 before, after, around 
      메서드 실행을 수행한다. 포인트컷 표현식은 이름있는 포인트컷에 대한 간단한 참조나 적절한 위치에 
      선언된 포인트컷 표현식이 모두 될 수 있다.</para>

      <section id="aop-advice-before">
        <title>Before advice</title>

        <para>Before advice는 <interfacename>@Before</interfacename> 
        어노테이션을 사용해서 관점에서 선언한다.</para>

        <programlisting language="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class BeforeExample {

  @Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
  public void doAccessCheck() {
    <lineannotation>// ...</lineannotation>
  }

}</programlisting>

        <para>인플레이스(in-place) 포인트컷 표현식을 사용해서 위의 예제를 다음과 같이
        재작성할 수 있다.</para>

        <programlisting language="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class BeforeExample {

  @Before("execution(* com.xyz.myapp.dao.*.*(..))")
  public void doAccessCheck() {
    <lineannotation>// ...</lineannotation>
  }

}</programlisting>
      </section>

      <section id="aop-advice-after-returning">
        <title>After returning advice</title>

        <para>매칭된 메서드 실행이 정상적으로 반환했을 때 After returning advice가 
        실행된다. 이는 <interfacename>@AfterReturning</interfacename> 
        어노테이션을 사용해서 정의한다.</para>

        <programlisting language="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterReturning;

@Aspect
public class AfterReturningExample {

  @AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
  public void doAccessCheck() {
    <lineannotation>// ...</lineannotation>
  }

}</programlisting>

        <remark>Note: 다른 멤버들와 마찬가지로 여러 어드바이스를 같은 관점내에 선언할 수 
        있다. 예제에서는 말하고자 하는 내용에 집중하기 위해서 하나의 어드바이스 선언만 
        보여준다.</remark>

        <para>때로는 어드바이스 바디에서 반환되는 실제 값에 접근해야 할 필요가 있다. 
        이러한 경우 <interfacename>@AfterReturning</interfacename>의 형식을 
        사용해서 반환 값에 바인딩할 수 있다.</para>

        <programlisting language="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterReturning;

@Aspect
public class AfterReturningExample {

  @AfterReturning(
    pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()",
    returning="retVal")
  public void doAccessCheck(Object retVal) {
    <lineannotation>// ...</lineannotation>
  }
  
}</programlisting>

        <para><literal>returning</literal> 속성에서 사용한 이름은 반드시 어드바이스 
        메서드의 파라미터 이름과 일치해야 한다. 메서드 실행이 반환되었을 때 반환값은 어드바이스 
        메서드의 대응되는 아규먼트의 값으로 전달될 것이다. <literal>returning</literal> 
        절도 지정한 타입의 값을 반환하는 메서드 실행만으로 매칭을 제한한다.(이 경우에 
        <classname>Object</classname>는 모든 반환값과 매치될 것이다.)</para>

        <para>after-returning advice를 사용하는 경우 완전히 다른 참조를 반환할 
        가능성은 <emphasis>없다</emphasis>.</para>
      </section>

      <section id="aop-advice-after-throwing">
        <title>After throwing advice</title>

        <para>매치된 메서드 실행이 예외를 던지고 종료되었을 때 After throwing advice가 
        실행된다. 이는 <interfacename>@AfterThrowing</interfacename> 어노테이션을 
        사용해서 선언한다.</para>

        <programlisting language="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterThrowing;

@Aspect
public class AfterThrowingExample {

  @AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
  public void doRecoveryActions() {
    <lineannotation>// ...</lineannotation>
  }

}</programlisting>

        <para>때로는 주어진 타입의 예외가 던져졌을 때만 어드바이스를 실행하거나 어드바이스 바이에서 
        던져진 예외에 접근해야할 필요가 있다. 매칭을 제한하고(원한다면 대신 예외타입으로 
        <interfacename>Throwable</interfacename>를 사용해라.) 어드바이스 파라미터로 
        던져진 예외를 바인딩 하는데 모두 <literal>throwing</literal> 속성을 
        사용해라.</para>

        <programlisting language="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterThrowing;

@Aspect
public class AfterThrowingExample {

  @AfterThrowing(
    pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()",
    throwing="ex")
  public void doRecoveryActions(DataAccessException ex) {
    <lineannotation>// ...</lineannotation>
  }

}</programlisting>

        <para><literal>throwing</literal> 속성에서 사용한 이름은 반드시 어드바이스 메서드의 
        파라미터 이름과 같아야 한다. 메서드 실행이 예외를 던지고 종료되었을 때 예외는 어드바이스 
        메서드의 대응되는 아규먼트의 값으로 전달될 것이다. <literal>throwing</literal> 절도 
        지정한 타입의 예외를 던지는 메서드 실행만으로 매칭을 제한한다.(이 경우에는 
        <classname>DataAccessException</classname>)</para>
      </section>

      <section id="aop-advice-after-finally">
        <title>After (finally) advice</title>

        <para>매치된 메서드실행이 종료되었을 때 After (finally) advice가 실행된다. 
        이는 <interfacename>@After</interfacename> 어노테이션을 사용해서 선언한다. 
        After advice는 반드시 정상적인 상황과 예외가 발생한 상황을 모두 처리할수 있도록 
        준비해야 한다. 보통 리소스를 해제하는 등에 사용한다.</para>

        <programlisting language="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.After;

@Aspect
public class AfterFinallyExample {

  @After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
  public void doReleaseLock() {
    <lineannotation>// ...</lineannotation>
  }

}</programlisting>
      </section>

      <section id="aop-ataspectj-around-advice">
        <title>Around advice</title>

        <para>마지막으로 얘기할 어드바이스는 around advice다. 매치된 메서드 실행 "주위에서" 
        Around advice가 실행된다. Around advice는 메서드 실행의 전과 후에 모두 작업을 할 
        수 있고 언제, 어떻게, 상황에 따라 결정하기 위해서 메서드는 실제로 실행할 모든 것을 획득한다. 
        쓰레드 세이프한 방법으로 메서드를 실행하는 전후로 상태를 공유해야할 때(예를 들면 타이머를 
        시작하고 종료하는 작업) Around advice를 사용하기도 한다. 항상 요구사항을 충족하는 어드바이스 
        중에 가장 덜 강력한 것을 사용해라.(예를 들면 before advice가 간단히 할 수 있는 경우에 
        around advice를 사용하지 마라.)</para>

        <para><interfacename>@Around</interfacename> 어노테이션을 사용해서 Around 
        advice를 선언한다. 어드바이스 메서드의 첫 파라미터는 반드시 
        <interfacename>ProceedingJoinPoint</interfacename> 타입이어야 한다. 
        어드바이스 바디내에서 <interfacename>ProceedingJoinPoint</interfacename>의 
        <literal>proceed()</literal>를 호출하면 기반하는 메서드가 실행된다. 
        <literal>proceed</literal> 메서드에는 <classname>Object[]</classname>가 
        전달되면서 실행될 것이다. 배열내의 값들은 진행되면서 메서드 실행의 아규먼트로 사용될 
        것이다.</para>

        <remark>proceed가 <classname>Object[]</classname>로 호출되었을 때의 동작은 
        AspectJ가 컴파일러가 컴파일한 around advice에 대한 proceed의 동작과는 약간 다르다. 
        전통적인 AspectJ 언어를 사용해서 작성한 around advice에서 proceed에 전달된 아규먼트의 
        수는 around advice에 전달된 아규먼트의 수와 일치해야 하고(기반하는 조인포인트가 취한 
        아규먼트의 수가 아니다.) 주어진 아규먼트위 위치에서 proceed에 전달된 값들은 값이 바인딩되는 
        엔티티를 위해서 조인포인트의 원래 값을 대체한다.(지금은 잘 이해되지 않아도 걱정하지 마라.) 
        스프링이 취한 접근은 의미론적으로만 실행하는 프록시기반의 특성에 맞게 더 간단하고 좋다. 
        스프링에 작성된 @AspectJ 관점을 컴파일때와 AspectJ 컴파일러와 위버를 가진 아규먼트로 
        proceed를 사용할 때의 이러한 차이점이 알아야할 전부이다. 스프링 AOP와 AspectJ에서 
        100% 호환성이 있는 관점을 작성하는 방법이 있는데 이는 어드바이스 파리미터에 나온 
        섹션에서 이야기한다.</remark>

        <programlisting language="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.ProceedingJoinPoint;

@Aspect
public class AroundExample {

  @Around("com.xyz.myapp.SystemArchitecture.businessService()")
  public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
    // 스톱워치를 시작한다
    Object retVal = pjp.proceed();
    // 스톱워치를 멈춘다
    return retVal;
  }

}</programlisting>

        <para>around advice가 반환한 값은 메서드 호출자(caller)가 받는 반환값이 될 것이다. 
        예를 들어 관점을 캐싱하면 캐싱된 값이 있는 경우 캐시로부터 값을 돌려받고 캐싱된 값이 없을 
        경우 proceed()를 호출한다. around advice의 바디내에서 proceed를 한번 호출하거나 
        여러번 호출할 수 있고 전혀 호출하지 않을수도 있다.</para>
      </section>

      <section id="aop-ataspectj-advice-params">
        <title>어드바이스 파라미터</title>

        <para>스프링 2.0은 완전히 타입이 있는 어드바이스를 제공한다. 즉 어드바이스 시그니처에서 
        언제나 <classname>Object[]</classname> 배열을 사용하는 대신에 필요한 파라미터
        (위의 예제에서 반환값과 예외에 대해서 선언한 것처럼)를 선언한다는 의미이다. 이제 어떻게 
        어드바이스 바디에서 아규먼트와 다른 컨텍스트상의 값들을 사용할 수 있도록 만드는 지를 볼 
        것이다. 우선 어드바이스가 현재 어드바이징한 메서드를 찾을 수 있는 제너릭 어드바이스를 
        어떻게 작성하는지 살펴보자.</para>

        <section id="aop-ataspectj-advice-params-the-joinpoint">
          <title>현재 <interfacename>JoinPoint</interfacename>에 
          접근하기</title>

          <para>모든 어드바이스는 <interfacename>org.aspectj.lang.JoinPoint</interfacename> 
          타입의 파라미터를 어드바이스의 첫 파라미터로 선언할 수 있다. around advice는 
          <interfacename>JoinPoint</interfacename>의 하위클래스인 
          <interfacename>ProceedingJoinPoint</interfacename> 타입의 파라미터를 
          <emphasis>필수적으로</emphasis> 첫 파라미터로 선언해야 한다. 
          <interfacename>JoinPoint</interfacename> 인터페이스는 
          <literal>getArgs()</literal> (메서드 아규먼트를 반환한다), 
          <methodname>getThis()</methodname> (프록시 객체를 반환한다), 
          <methodname>getTarget()</methodname> (대상 객체를 반환한다), 
          <methodname>getSignature()</methodname> (어드바이즈되는 메서드의 
          설명(description)을 반환한다), <methodname>toString()</methodname> 
          (어드바이즈되는 메서드의 유용한 설명을 출력한다)같은 다수의 유용한 메서드를 제공한다. 
          자세한 내용은 Javadoc을 참고해라.</para>
        </section>

        <section id="aop-ataspectj-advice-params-passing">
          <title>어드바이스에 파라미터 전달하기</title>

          <para>반환값이나 예외값에 어떻게 바인딩하는 지를 이미 봤다.(after returning 
          advice와 after throwing advice를 사용해서) 아규먼트 값을 어드바이스 바디에서 
          사용할 수 있도록 하려면 <literal>args</literal> 형식의 바인딩을 사용할 수 있다. 
          args 표현식에서 타입이름 대신에 파라미터 이름을 사용했다면 어드바이스를 호출할 때 이름에 
          대응되는 아규먼트의 값이 파라미터 값으로 전달될 것이다. 예제를 보면 이를 더 명확하게 이해할 
          수 있다. 첫 파라미터로 Account 객체를 받는 dao 작업의 실행을 어드바이즈하고 어드바이스 
          바디에서 account에 접근해야 한다고 가정해 보자. 이를 다음과 같이 작성할 수 있다.</para>

          <programlisting language="java">@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp;" + 
        "args(account,..)")
public void validateAccount(Account account) {
  <lineannotation>// ...</lineannotation>
}</programlisting>

          <para>포인트컷 표현식의 <literal>args(account,..)</literal> 부분은 두가지 
          목적을 제공한다. 첫째로 최소 하나이상의 파라미터를 받고 파라미터로 전달되는 아규먼트는 
          <classname>Account</classname>의 인스턴스인 메서드 실행만으로 매칭을 제한한다. 
          두번째로 <literal>account</literal> 파라미터로 실제 <classname>Account</classname> 
          객체가 어드바이스에서 사용할 수 있도록 만든다.</para>

          <para>다른 방법으로 이것을 작성하려면 조인포인트가 매칭되었을 때 
          <classname>Account</classname> 객체를 "제공"하는 포인트컷을 선언하고 어드바이스에서 
          포인트컷 이름으로 참조하면 된다. 다음과 같이 작성한다.</para>

          <programlisting language="java">@Pointcut("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp;" + 
          "args(account,..)")
private void accountDataAccessOperation(Account account) {}

@Before("accountDataAccessOperation(account)")
public void validateAccount(Account account) {
  <lineannotation>// ...</lineannotation>
}</programlisting>

          <para>더 자세한 내용에 흥미가 있다면 AspectJ programming guide를 
          참고해라.</para>

          <para>프록시 객체 (<literal>this</literal>), 대상 객체 
          (<literal>target</literal>), 어노테이션(<literal>@within, @target, 
          @annotation, @args</literal>)은 모두 비슷한 방법으로 바인딩할 수 있다. 다음 
          예제는 <interfacename>@Auditable</interfacename> 어노테이션이 붙은 메서드의 
          실행을 어떻게 매칭하고 audit 코드를 추출하는지 보여준다.</para>

          <para>우선 <interfacename>@Auditable</interfacename> 
          어노테이션의 정의이다.</para>

          <programlisting language="java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Auditable {
	AuditCode value();
}</programlisting>

          <para>다음은 <interfacename>@Auditable</interfacename> 
          메서드의 실행을 매칭하는 어드바이스이다.</para>

          <programlisting language="java">@Before("com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; " + 
        "@annotation(auditable)")
public void audit(Auditable auditable) {
  AuditCode code = auditable.value();
  <lineannotation>// ...</lineannotation>
}</programlisting>
        </section>

        <section id="aop-ataspectj-advice-params-generics">
          <title>어드바이스 파라미터와 제너릭</title>

          <para>스프링 AOP는 클래스 선언과 메서드 파라미터에서 사용한 제너릭을 다룰 수 있다. 
          다음과 같은 제너릭 타입이 있다고 생각해보자.</para>

          <programlisting language="java">public interface Sample&lt;T&gt; {
  void sampleGenericMethod(T param);
  void sampleGenericCollectionMethod(Collection&gt;T&gt; param);
}</programlisting>

          <para>인터셉트하려는 메서드의 파라미터 타입에 어드바이스 파라미터의 타입을 지정해서 
          특정 파라미터 타입으로 인터셉트하는 메서드 타입을 제한할 수 있다.</para>

          <programlisting language="java">@Before("execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)")
public void beforeSampleMethod(MyType param) {
  // 어드바이스 구현체
}</programlisting>

          <para>앞에서 이미 얘기했듯이 이 동작은 꽤 명확하다. 하지만 제너릭 컬렉션에는 
          동작하지 않는다는 사실은 중요하다. 그러므로 다음과 같은 포인트컷은 
          정의할 수 없다.</para>

          <programlisting language="java">@Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)")
public void beforeSampleMethod(Collection&lt;MyType&gt; param) {
  // 어드바이스 구현체
}</programlisting>

          <para>이 예제가 동작하려면 컬렉션의 모든 요소를 검사해야 하는데 
          <literal>null</literal> 값을 보통 어떻게 처리해야 하는지 결정할 수 없으므로 
          모든 요소를 검사하는 것은 말이 안된다. 이와 비슷하게 하려면 파라미터를 
          <interfacename>Collection&lt;?&gt;</interfacename> 타입으로 지정하고 
          수동으로 요소의 타입을 확인해야 한다.</para>
        </section>

        <section id="aop-ataspectj-advice-params-names">
          <title>아규먼트 이름 결정하기</title>

          <para>어드바이스 호출시에 파라미터 바인딩은 포인트컷 표현식에서 사용한 이름과 
          (어드바이스와 포인트컷) 메서드 시그니처에서 선언한 파라미터 이름이 일치하는지 여부에 
          달려있다. 파라미터 이름은 자바 리플렉션에서 사용할 수 <emphasis>없으므로</emphasis> 
          스프링 AOP는 파라미터 이름을 결정하기 위해 다음의 전략들을 사용한다.</para>

          <orderedlist>
            <listitem>
              <para>사용자가 명시적으로 파라미터 이름을 지정했다면 지정된 파라미터 이름을 
              사용한다. 어드바이스와 포인트컷 어노테이션에는 둘다 어노테이션이 붙은 메서드의 
              아규먼트 이름을 지정할 수 있는 선택적인 "argNames" 속성이 있다. 이러한 
              아규먼트 이름은 런타임시에 사용할 수 <emphasis>있다</emphasis>. 
              예를 들어 다음과 같다.</para>

              <programlisting language="java">@Before(
   value="com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)",
   argNames="bean,auditable")
public void audit(Object bean, Auditable auditable) {
  AuditCode code = auditable.value();
  <lineannotation>// ... code와 bean을 사용한다</lineannotation>
}</programlisting>

              <para>첫 파라미터가 <interfacename>JoinPoint</interfacename>,
              <interfacename>ProceedingJoinPoint</interfacename>, 
              <interfacename>JoinPoint.StaticPart</interfacename>의 타입이면 
              "argNames" 속성의 값에서 파라미터 이름을 무시할 것이다. 예를 들어 앞의 
              어드바이스를 조인포인트 객체를 받도록 수정해도 "argNames" 속성에 조인포인트 
              객체를 포함시킬 필요가 없다.</para>

              <programlisting language="java">@Before(
   value="com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)",
   argNames="bean,auditable")
public void audit(JoinPoint jp, Object bean, Auditable auditable) {
  AuditCode code = auditable.value();
  <lineannotation>// ... code, bean, jp를 사용한다</lineannotation>
}</programlisting>

              <para><interfacename>JoinPoint</interfacename>,
              <interfacename>ProceedingJoinPoint</interfacename>,
              <interfacename>JoinPoint.StaticPart</interfacename> 타입의 첫 
              파라미터를 특별하게 처리하는 것은 다른 어떤 조인포인트 컨텍스트도 수집하지 않는 
              어드바이스에 특히 편리하다. 이러한 경우에는 그냥 "argNames" 속성을 생략한다. 
              예를 들어 다음의 어드바이스는 "argNames" 속성을 선언할 필요가 없다.</para>

              <programlisting language="java">@Before(
   "com.xyz.lib.Pointcuts.anyPublicMethod()")
public void audit(JoinPoint jp) {
  <lineannotation>// ... jp를 사용한다</lineannotation>
}</programlisting>
            </listitem>

            <listitem>
              <para><literal>'argNames'</literal> 속성을 사용하는 것은 별로 보기가 좋지 
              않으므로 <literal>'argNames'</literal> 속성을 지정하지 않으면 스프링 AOP가 
              해당 클래스의 디버그 정보를 검사하고 로컬변수 테이블에서 파라미터 이름을 결정하려고 
              시도할 것이다. 클래스가 디버그정보(최소한 <literal>'-g:vars'</literal>)와 
              함께 컴파일되는 한 이 정보는 존재할 것이다. 이 플래그를 사용한 컴파일 결과는 (1) 
              코드를 이해하기가 다소 쉬워질 것이고(역엔지니어링), (2) 클래스 파일 크기가 미세하게 
              커질 것이고(보통 사소한 정도다), (3) 사용하지 않는 로컬 변수를 제거하는 최적화를 
              컴파일러가 적용하지 않을 것이다. 즉, 이 플래그를 사용하는데 아무런 어려움이 
              없다.</para>

              <remark>@AspectJ 관점을 디버그 정보 없이 AspectJ 컴파일러 (ajc)로 컴파일하면 
              컴파일러가 필요한 정보를 유지할 것이므로 <literal>argNames</literal> 
              속성을 추가할 필요가 없다.</remark>
            </listitem>

            <listitem>
              <para>필수적인 디버그 정보없이 코드를 컴파일했으면 스프링 AOP가 변수와 파라미터를 
              바인딩하는 연결(pairing)을 추론하려고 시도할 것이다. (예를 들어 포인트컷 표현식에서 
              딱 하나의 변수만 바인딩하고 어드바이스 메서드가 딱 하나의 파라미터만 받으면 
              연결(pairing)은 명확하다!) 주어진 정보로 변수의 바인딩이 모호하다면 
              <exceptionname>AmbiguousBindingException</exceptionname>가 
              던져질 것이다.</para>
            </listitem>

            <listitem>
              <para>위의 전략이 모두 실패하면 
              <exceptionname>IllegalArgumentException</exceptionname>를 
              던질 것이다.</para>
            </listitem>
          </orderedlist>
        </section>

        <section id="aop-ataspectj-advice-proceeding-with-the-call">
          <title>아규먼트를 가지고 속행하기(Proceeding with arguments)</title>

          <para>스프링 AOP와 AspectJ에서 일관성있게 동작하면서 어떻게 
          <emphasis>아규먼트를 가진</emphasis> 호출을 속행하도록 작성하는지 설명한다. 
          어드바이스 시크니처를 메서드 파라미터 각각에 순서대로 바인딩하는 것이 해결책이다. 
          예를 들면 다음과 같다.</para>

          <programlisting language="java">@Around("execution(List&lt;Account&gt; find*(..)) &amp;&amp;" +
        "com.xyz.myapp.SystemArchitecture.inDataAccessLayer() &amp;&amp; " +
        "args(accountHolderNamePattern)")		
public Object preProcessQueryPattern(ProceedingJoinPoint pjp, String accountHolderNamePattern)
throws Throwable {
  String newPattern = preProcess(accountHolderNamePattern);
  return pjp.proceed(new Object[] {newPattern});
}        
</programlisting>

          <para>많은 경우에 이 바인딩을 사용할 것이다.(위의 예제처럼)</para>
        </section>
      </section>

      <section id="aop-ataspectj-advice-ordering">
        <title>어드바이스 순서</title>

        <para>여러 어드바이스들이 모두 같은 조인포인트에서 실행하려고 하면 무슨 일이 발생하는가? 
        어드바이스 실행의 순서를 결정하는데 AspectJ와 같은 우선순위 규칙을 스프링 AOP도 따른다. 
        "안으로 들어갈 때는" 가장 높은 우선순위를 가진 어드바이스가 먼저 실행된다. (그러므로 주어진 
        두 before advice 중 가장 높은 우선순위를 가진 어드바이스가 먼저 실행된다.) "밖으로 
        나올 때는" 조인포인트에서 가장 높은 우선순위를 가진 어드바이스가 나중에 실행된다.(그러므로 
        주어진 두 after advice 중 가장 우선순위가 높은 어드바이스가 두번째로 실행된다.)</para>

        <para><emphasis>다른</emphasis> 관점에서 정의된 두 어드바이스를 모두 같은 조인포인트에서 
        실행해야 하는 경우 직접 지정하지 않으면 실행의 순서는 정의되어 있지 않다. 우선순위를 
        명시해서 실행 순서를 제어할 수 있다. 관점 클래스에서 
        <interfacename>org.springframework.core.Ordered</interfacename> 
        인터페이스를 구현하거나 <interfacename>Order</interfacename> 어노테이션을 
        사용해서 일방적인 스프링식으로 실행순서를 제어한다. 두 관점이 있을 때 
        <literal>Ordered.getValue()</literal>(또는 어노테이션 값)가 더 작은 값을 
        반환하는 관점이 더 높은 우선순위를 가진다.</para>

        <para><emphasis>같은</emphasis> 관점에서 정의된 두 어드바이스를 모두 같은 
        조인포인트에서 실행해야 하는 경우 순서는 정의되어 있지 않다.(javac로 컴파일된 클래스를 
        리플랙션해서 순서선언을 획득하는 방법은 없으므로) 이러한 어드바이스 메서드들을 각 
        관점클래스의 조인포인트마다 하나의 어드바이스 메서드로 구성하거나 어드바이스들을 분리된 
        관점 클래스로 리팩토링하는 것을 고려해 봐라. 이렇게 하면 관점 수준에서 
        정렬할 수 있다.</para>
      </section>
    </section>

    <section id="aop-introductions">
      <title>인트로덕션(Introduction)</title>

      <para>인트로덕션(AspectJ에서는 inter-type 선언이라고 부른다)은 관점이 주어진 인터페이스를 
      구현한 어드바이즈된 객체를 선언하고 이러한 객체 대신에 주어진 인터페이스의 구현체를 
      제공하도록 할 수 있다.</para>

      <para>인트로억션은 <interfacename>@DeclareParents</interfacename> 
      어노테이션으로 만든다. 이 어노테이션은 새로운 부모를 가진 타입 매칭(따라서 그 이름으로)을 
      선언하는데 사용한다. 예를 들어 <interfacename>UsageTracked</interfacename> 
      인터페이스와 <classname>DefaultUsageTracked</classname> 인터페이스의 구현체가 
      주어졌을 때 다음의 관점은 서비스 인터페이스의 모든 구현체가 
      <interfacename>UsageTracked</interfacename> 인터페이스도 구현한다고 선언한다. 
      (예를 들면 JMX를 통해서 통계를 노출하기 위해서)</para>

      <programlisting language="java">@Aspect
public class UsageTracking {

  @DeclareParents(value="com.xzy.myapp.service.*+",
                  defaultImpl=DefaultUsageTracked.class)
  public static UsageTracked mixin;
  
  @Before("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp;" +
          "this(usageTracked)")
  public void recordUsage(UsageTracked usageTracked) {
    usageTracked.incrementUseCount();
  }
  
}</programlisting>

      <para>구현할 인터페이스는 어노테이션이 붙은 필드의 타입으로 결정한다. 
      <interfacename>@DeclareParents</interfacename> 어노테이션의 
      <literal>value</literal> 속성은 AspectJ 타입패턴이다. (매칭된 타입의 모든 빈은 
      UsageTracked 인터페이스를 구현할 것이다.) 앞의 예제에서 before advice의 서비스 빈을 
      <interfacename>UsageTracked</interfacename> 인터페이스의 구현체로 직접 사용할 
      수 있다. 프로그래밍적으로 빈에 접근하려면 다음과 같이 작성한다.</para>

      <programlisting language="java">UsageTracked usageTracked = (UsageTracked) context.getBean("myService");</programlisting>
    </section>

    <section id="aop-instantiation-models">
      <title>관점 인스턴스화 모델(Aspect instantiation models)</title>

      <remark>(이 주제는 고급주제이느로 AOP를 시작하는 단계라면 이번 섹션은 
      나중에 봐도 된다.)</remark>

      <para>기본적으로 어플리케이션 컨텍스트내에는 각 관점마다 하나의 인스턴스가 있을 것이다. 
      AspectJ는 이를 싱글톤 인스턴스화 모델(singleton instantiation model)이라고 부른다. 
      이 모델로 대리 생명주기로 관점을 정의하는 것이 가능하다. 스프링은 AspectJ의 
      <literal>perthis</literal> 인스턴스화 모델과 <literal>pertarget</literal> 
      인스턴스화 모델을 지원한다. (<literal>percflow, percflowbelow,</literal>와 
      <literal>pertypewithin</literal>는 현재 지원하지 않는다.)</para>

      <para><interfacename>@Aspect</interfacename> 어노테이션에서 
      <literal>perthis</literal>절을 지정해서 "perthis" 관점을 선언한다. 예제를 
      먼저 보고 어떻게 동작하는지 설명하겠다.</para>

      <programlisting language="java">@Aspect("perthis(com.xyz.myapp.SystemArchitecture.businessService())")
public class MyAspect {

  private int someState;
	
  @Before(com.xyz.myapp.SystemArchitecture.businessService())
  public void recordServiceUsage() {
    <lineannotation>// ...</lineannotation>
  }
  	
}</programlisting>

      <para><literal>'perthis'</literal> 절은 비즈니스 서비스를 실행하는 유일한 각각의 
      서비스 객에마다 하나의 관전 인스턴스를 생성할 것이다.(유일한 각각의 객체는 포인트컷 표현식으로 
      매칭된 조인포인트의 'this'로 바인딩된다.) 관점 인스턴스는 서비스 객체에서 메서드가 최초로 
      호출될 때 생성된다. 서비스객체가 범위를 벗어날 때 관점도 범위를 벗어난다. 관점 인스턴스가 생성되기 
      전에 관점 인스턴스 내에서 실행되는 어드바이스는 없다. 관점 인스턴스가 생성되자 마자 관점에서 선언된 
      어드바이스가 매칭된 조인포인트에서 실행되지만 이 관점과 연결된 서비스 객체에서만 실행된다. per-절에 
      대한 자세한 내용은 AspectJ programming guide를 봐라.</para>

      <para><literal>'pertarget'</literal> 인스턴스화 모델도 perthis와 완전히 같은 
      방법으로 동작하지만 매치된 조인포인트에서 유일한 각각의 대상객체마다 하나의 관점인스턴스를 
      생성한다.</para>
    </section>

    <section id="aop-ataspectj-example">
      <title>예제</title>

      <para>어떻게 모든 구성요소가 동작하는지 모았으므로 무언가 유용한 작용을 위에서 
      이를 섞어보자.</para>

      <para>비스니스 서비스의 실행은 종종 동시성 이슈때문에 실패할 수 있다.(예를 들면 데드락 실패) 
      작업이 재시도되었다면 다음번에는 성공할 가능성이 높아보인다. 이러한 경우처럼(사용자가 복잡한 
      해결책을 적용할 필요가 없는 멱등 작업) 재시도가 적절해 보이는 비스니스 서비스에서는 클라이언트가 
      <classname>PessimisticLockingFailureException</classname>를 보지 않도록 투명하게 
      작업을 재시도할 것이다. 이는 서비스계층에서 여러 서비스에 걸쳐서 명확하게 적용하는 것이 
      필수사항이므로 관점을 통해서 구현하는 것이 이상적이다.</para>

      <para>작업을 재시도해야 하기 때문에 여러번 proceed를 호출할 수 있도록 around advice를 
      사용할 필요가 있다. 다음은 기본적인 관점 구현체의 예제이다.</para>

      <programlisting language="java">@Aspect
public class ConcurrentOperationExecutor implements Ordered {
   
   private static final int DEFAULT_MAX_RETRIES = 2;

   private int maxRetries = DEFAULT_MAX_RETRIES;
   private int order = 1;

   public void setMaxRetries(int maxRetries) {
      this.maxRetries = maxRetries;
   }
   
   public int getOrder() {
      return this.order;
   }
   
   public void setOrder(int order) {
      this.order = order;
   }
   
   @Around("com.xyz.myapp.SystemArchitecture.businessService()")
   public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable { 
      int numAttempts = 0;
      PessimisticLockingFailureException lockFailureException;
      do {
         numAttempts++;
         try { 
            return pjp.proceed();
         }
         catch(PessimisticLockingFailureException ex) {
            lockFailureException = ex;
         }
      }
      while(numAttempts &lt;= this.maxRetries);
      throw lockFailureException;
   }

}</programlisting>

      <para>관점이 <interfacename>Ordered</interfacename> 인터페이스를 구현하므로 
      트랜잭션 어드바이스보다 더 높은 우선순위를 관점에 설정할 수 있다.(시도할 때마다 새로운 트랜잭션이 
      필요하다) <literal>maxRetries</literal>와 <literal>order</literal> 프로퍼티는 
      둘다 스프링으로 설정한다. 핵심 동작은 <literal>doConcurrentOperation</literal> 
      around advice에서 일어난다. 지금은 모든 <literal>businessService()s</literal>에 
      재시도 로직을 적용하고 있다. proceed를 시도하고 
      <classname>PessimisticLockingFailureException</classname>로 실패하면 모든 
      재시도 횟수를 소진하지 않고 그냥 다시 시도한다.</para>

      <para>이에 상응하는 스프링 설정은 다음과 같다.</para>

      <programlisting language="xml">&lt;aop:aspectj-autoproxy/&gt;

&lt;bean id="concurrentOperationExecutor"
  class="com.xyz.myapp.service.impl.ConcurrentOperationExecutor"&gt;
     &lt;property name="maxRetries" value="3"/&gt;
     &lt;property name="order" value="100"/&gt;  
&lt;/bean&gt;</programlisting>

      <para>멱등작업만 재시도를 하는 것으로 관점을 개선하려면 
      <interfacename>Idempotent</interfacename> 어노테이션을 정의한다.</para>

      <programlisting language="java">@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent {
  <lineannotation>// marker annotation</lineannotation>
}</programlisting>

      <para>그리고 서비스 작업의 구현체에 어노테이션을 사용해라. 멱등 작업만 재시도하도록 관점을 
      변경하는 것은 <interfacename>@Idempotent</interfacename> 작업에만 매치하기 위해서 
      포인트컷을 개선하는 것을 포함한다.</para>

      <programlisting language="java">@Around("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; " + 
        "@annotation(com.xyz.myapp.service.Idempotent)")
public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable { 
  ...	
}</programlisting>
    </section>
  </section>

  <section id="aop-schema">
    <title>스키마 기반의 AOP 지원</title>

    <para>자바 5를 사용할 수 없거나 단순히 XML 기반의 형식을 선호한다면 스프링 2.0이 새로운 
    "aop" 네임스페이스 태그를 사용해서 관점을 정의하는 기능도 지원한다. @AspectJ 방식을 
    사용했을 때와 완전히 같은 포인트컷 표현식과 어드바이스들을 지원하기 때문에 이번 섹션에서는 
    새로운 <emphasis>문법</emphasis>에 집중하고 포인트컷 작성과 어드바이스 파라미터 바인딩에 
    대해서는 이전 섹션 (<xref linkend="aop-ataspectj" />)을 참고하길 바란다.</para>

    <para>이번 섹션에서 설명한 aop 네임스페이스를 사용하려면 <xref linkend="xsd-config" />에서 
    설명했듯이 spring-aop 스키마를 임포트해야 한다. aop 네임스페이스에서 태그를 임포트하는 방법은 <xref
    linkend="xsd-config-body-schemas-aop" />를 봐라.</para>

    <para>스프링 설정에서 모든 aspect과 advisor 요소는 
    <literal>&lt;aop:config&gt;</literal> 요소안에 있어야 한다. (어플리케이션 컨텍스트 
    설정에 하나 이상의 <literal>&lt;aop:config&gt;</literal> 요소를 둘 수 있다.) 
    <literal>&lt;aop:config&gt;</literal> 요소에는 pointcut, advisor, aspect 
    요소가 있을 수 있다.(이 요소들은 반드시 저 순서대로 선언되어야 한다.)</para>

    <warning>
      <para><literal>&lt;aop:config&gt;</literal> 방식의 설정은 스프링의 <link
      linkend="aop-autoproxy">auto-proxying</link> 메카니즘을 많이 사용한다. 
      이미 <classname>BeanNameAutoProxyCreator</classname> 등을 사용해서 
      명시적인 auto-proxying을 사용하고 있다면 문제가 될 소지가 있다.(어드바이스가 위빙되지 
      않는 등) 추천하는 사용패턴은 <literal>&lt;aop:config&gt;</literal> 방식이나 
      <interfacename>AutoProxyCreator</interfacename> 방식을 사용하는 
      것이다.</para>
    </warning>

    <section id="aop-schema-declaring-an-aspect">
      <title>관점 선언</title>

      <para>스키마 지원을 사용하면 관점은 스프링 어플리케이션 컨텍스트에 정의된 빈과 마찬가지로 
      단순히 보통의 자바 개체일 뿐이다. 상태(state)와 동작(behavior)는 객체의 필드와 
      메서드에 담겨있고 포인트컷과 어드바이스 정보는 XML에 담겨있다.</para>

      <para>관점은 &lt;aop:aspect&gt; 요소를 사용해서 선언하고 지원하는 
      빈(backing bean)은 <literal>ref</literal> 속성을 사용해서 참조한다.</para>

      <programlisting language="xml">&lt;aop:config&gt;
  &lt;aop:aspect id="myAspect" ref="aBean"&gt;
    ...
  &lt;/aop:aspect&gt;
&lt;/aop:config&gt;

&lt;bean id="aBean" class="..."&gt;
  ...
&lt;/bean&gt;</programlisting>

      <para>관점을 지원하는 빈(이 경우에는 "<literal>aBean</literal>")도 당연히 
      다른 스프링 빈처럼 설정하고 의존성을 주입에 사용할 수 있다.</para>
    </section>

    <section id="aop-schema-pointcuts">
      <title>포인트컷 선언</title>

      <para>이름이 있는 포인트컷은 포인트컷 정의가 여러 관점과 어드바이저 사이에서 공유될 수 
      있도록 &lt;aop:config&gt; 요소내에서 선언할 수 있다.</para>

      <para>서비스 계층의 어떤 비즈니스 서비스의 실행을 나타내는 포인트컷은 다음과 
      같이 정의할 수 있다.</para>

      <programlisting language="xml">&lt;aop:config&gt;

  &lt;aop:pointcut id="businessService" 
        expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;

&lt;/aop:config&gt;</programlisting>

      <para>포인트컷 표현식 자체는 <xref linkend="aop-ataspectj" />에서 설명한 것과 같은
      AspectJ 포인트컷 표현식 언어를 사용한다. 자바 5로 스키마 기반의 선언방식을 사용한다면 
      포인트컷 표현식내 타입(@Aspects)에 선언한 이름있는 포인트컷을 참조할 수 있지만 이 기능은 
      JDK 1.4나 그 이하의 버전에서는 사용할 수 없다.(자바 5의 AspectJ 리플렉션 API에 의존하고 
      있다.) 그러므로 JDK 1.5에서는 위의 포인트컷을 다음과 같이 정의할 수도 있다.</para>

      <programlisting language="xml">&lt;aop:config&gt;

  &lt;aop:pointcut id="businessService" 
        expression="com.xyz.myapp.SystemArchitecture.businessService()"/&gt;

&lt;/aop:config&gt;</programlisting>

      <para><xref linkend="aop-common-pointcuts" />에서 설명한 
      <literal>SystemArchitecture</literal> 관점을 가지고 있다고 가정해 보자.</para>

      <para>관점내부에서 선언한 포인트컷은 최상위수준의 포인트컷을 선언하는 것과 아주 
      유사하다.</para>

      <programlisting language="xml">&lt;aop:config&gt;

  &lt;aop:aspect id="myAspect" ref="aBean"&gt;

    &lt;aop:pointcut id="businessService" 
          expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;
          
    ...
    
  &lt;/aop:aspect&gt;

&lt;/aop:config&gt;</programlisting>

      <para>@AspectJ 관점과 거의 같은 방법으로 스키마 기반의 정의방식을 사용해서 선언한 포인트컷은 
      조인포인트 컨텍스트를 수집할(collect) 것이다. 예를 들어 다음 포인트컷은 조인포인트 컨텍스트로 
      'this' 객체를 수집해서 어드바이스에 전달한다.</para>

      <programlisting language="xml">&lt;aop:config&gt;

  &lt;aop:aspect id="myAspect" ref="aBean"&gt;

    &lt;aop:pointcut id="businessService" 
          expression="execution(* com.xyz.myapp.service.*.*(..)) &amp;amp;&amp;amp; this(service)"/&gt;
    &lt;aop:before pointcut-ref="businessService" method="monitor"/&gt;
    ...
    
  &lt;/aop:aspect&gt;

&lt;/aop:config&gt;</programlisting>

      <para>어드바이스는 일치하는 이름의 파라미터를 포함시켜서 수집된 조인포인트 컨텍스트를 
      받도록 선언해야 한다.</para>

      <programlisting language="java">public void monitor(Object service) {
    ...
}</programlisting>

      <para>포인트컷 하위 표현식을 결합할 때 XML문서에서 '&amp;&amp;'는 다루기가 어려우므로 
      '&amp;&amp;', '||', '!'의 위치에 각각 'and', 'or', 'not' 키워드를 사용할 수 있다. 
      예를 들어 앞의 포인트컷은 다음과 같이 작성하는게 더 낫다.</para>

      <programlisting language="xml">&lt;aop:config&gt;

  &lt;aop:aspect id="myAspect" ref="aBean"&gt;

    &lt;aop:pointcut id="businessService" 
          expression="execution(* com.xyz.myapp.service.*.*(..)) <emphasis
          role="bold">and</emphasis> this(service)"/&gt;
    &lt;aop:before pointcut-ref="businessService" method="monitor"/&gt;
    ...
    
  &lt;/aop:aspect&gt;

&lt;/aop:config&gt;</programlisting>

      <para>이 방법으로 정의한 포인트컷은 해당 XML id로 참조하고 혼합된 형태의 포인트컷의 
      이름이 붙은 포인트컷처럼 사용할 수는 없다. 그러므로 스키마 기반의 정의 방식에서 지원하는 
      이름이 붙은 포인트컷은 @AspectJ 방식이 제공하는 것보다 더 제한적이다.</para>
    </section>

    <section id="aop-schema-advice">
      <title>어드바이스 선언</title>

      <para>@AspectJ 방식과 같은 다섯 종류의 어드바이스를 지원하고 이 어드바이스들은 정확히 같은 의미를 가진다.</para>

      <section id="aop-schema-advice-before">
        <title>Before advice</title>

        <para>Before advice는 매칭된 메서드 실행 이전에 실행된다. Before advice는 
        <literal>&lt;aop:aspect&gt;</literal>내에서 &lt;aop:before&gt;를 
        사용해서 선언한다.</para>

        <programlisting language="xml">&lt;aop:aspect id="beforeExample" ref="aBean"&gt;

    &lt;aop:before 
      pointcut-ref="dataAccessOperation" 
      method="doAccessCheck"/&gt;
          
    ...
    
&lt;/aop:aspect&gt;</programlisting>

        <para>여기서 <literal>dataAccessOperation</literal>는 최상위 
        (<literal>&lt;aop:config&gt;</literal>)에서 정의한 포인트컷의 id이다. 
        포인트컷을 인라인으로 정의하는 대신에 <literal>pointcut-ref</literal> 속성을 
        <literal>pointcut</literal> 속성으로 교체한다.</para>

        <programlisting language="xml">&lt;aop:aspect id="beforeExample" ref="aBean"&gt;

    &lt;aop:before 
      pointcut="execution(* com.xyz.myapp.dao.*.*(..))" 
      method="doAccessCheck"/&gt;
          
    ...
    
&lt;/aop:aspect&gt;</programlisting>

        <para>@AspectJ 방식에서 얘기했듯이 이름이 붙은 포인트컷을 사용하면 코드의 가독성을 
        약간 높힐 수 있다.</para>

        <para>method 속성은 어드바이스의 바디를 제공하는 메서드
        (<literal>doAccessCheck</literal>)를 식별한다. 이 메서드는 반드시 어드바이스를 
        담고 있는 aspect 요소가 참조하는 빈에 정의되어 있어야 한다. 데이터 접근 작업이 
        실행(포인트컷 표현식으로 매칭된 메서드 실행 조인포인트)되기 전에 관점 빈의 
        "doAccessCheck" 메서드가 호출될 것이다.</para>
      </section>

      <section id="aop-schema-advice-after-returning">
        <title>After returning advice</title>

        <para>매칭된 메서드 실행이 정상적으로 완료되었을 때 After returning advice가 
        실행된다. After returning advice는 before advice와 같은 방법으로 
        <literal>&lt;aop:aspect&gt;</literal>에서 선언한다.</para>

        <programlisting language="xml">&lt;aop:aspect id="afterReturningExample" ref="aBean"&gt;

    &lt;aop:after-returning 
      pointcut-ref="dataAccessOperation" 
      method="doAccessCheck"/&gt;
          
    ...
    
&lt;/aop:aspect&gt;</programlisting>

        <para>마치 @AspectJ 방식처럼 어드바이스 바디 내에서 반환값을 획득하는 것이 가능하다. 
        전달해야할 반환값의 파라미터 명을 지정하려면 returning 속성을 사용해라.</para>

        <programlisting language="xml">&lt;aop:aspect id="afterReturningExample" ref="aBean"&gt;

    &lt;aop:after-returning 
      pointcut-ref="dataAccessOperation"
      returning="retVal" 
      method="doAccessCheck"/&gt;
          
    ...
    
&lt;/aop:aspect&gt;</programlisting>

        <para>doAccessCheck 메서드는 <literal>retVal</literal>라는 이름의 
        파라미터를 선언해야 한다. 이 파라미터의 타입은 @AfterReturning에서 설명한 것과 
        같은 방법으로 매칭을 제약한다. 예를 들어 메서드 시그니처를 다음과 같이 선언한다.</para>

        <programlisting language="java">public void doAccessCheck(Object retVal) {...</programlisting>
      </section>

      <section id="aop-schema-advice-after-throwing">
        <title>After throwing advice</title>

        <para>매칭된 메서드 실행이 예외를 던지고 종료되었을 때 after throwing advice가 
        실행된다. after throwing advice는 <literal>&lt;aop:aspect&gt;</literal>에서 
        after-throwing 요소를 사용해서 선언한다.</para>

        <programlisting language="xml">&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt;

    &lt;aop:after-throwing
      pointcut-ref="dataAccessOperation" 
      method="doRecoveryActions"/&gt;
          
    ...
    
&lt;/aop:aspect&gt;</programlisting>

        <para>마치 @AspectJ 방식처럼 던져진 예외를 어드바이스 바디내에서 획득하는 것이 가능하다. 
        예외를 전달할 파라미터 명을 지정하려면 throwing 속성을 사용해라.</para>

        <programlisting language="xml">&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt;

    &lt;aop:after-throwing 
      pointcut-ref="dataAccessOperation"
      throwing="dataAccessEx" 
      method="doRecoveryActions"/&gt;
          
    ...
    
&lt;/aop:aspect&gt;</programlisting>

        <para>doRecoveryActions 메서드는 <literal>dataAccessEx</literal>라는 이름의 
        파라미터를 선언해야 한다. 이 파라미터의 타입은 @AfterThrowing에서 설명한 것과 같은 방법으로 
        매칭을 제약한다. 예를 들어 메서드 시그니처를 다음과 같이 선언한다.</para>

        <programlisting language="java">public void doRecoveryActions(DataAccessException dataAccessEx) {...</programlisting>
      </section>

      <section id="aop-schema-advice-after-finally">
        <title>After (finally) advice</title>

        <para>매칭된 메서드 실행이 종료되면 무조선 after (finally) advice가 실행된다. 
        after (finally) advice는 <literal>after</literal>요소를 사용해서 
        선언한다.</para>

        <programlisting language="xml">&lt;aop:aspect id="afterFinallyExample" ref="aBean"&gt;

    &lt;aop:after
      pointcut-ref="dataAccessOperation" 
      method="doReleaseLock"/&gt;
          
    ...
    
&lt;/aop:aspect&gt;</programlisting>
      </section>

      <section id="aop-schema-advice-around">
        <title>Around advice</title>

        <para>마지막 어드바이드는 around advice다. around advice는 매칭된 메서드 실행 
        "주변에서(around)" 실행된다. around advice는 메서드 실행 이전과 이후에 모두 작업을 
        할 기회를 가지고 언제, 어떻게, 어떤 조건하에서 실행할지를 결정하기 위해 사실 메서드는 무조건 
        실행된다. 쓰레드 세이프한 방법으로 메서드 실행 이전과 이후에 상태를 공유해야 하는 경우 around 
        advice를 종종 사용한다.(예를 들면 타이머를 시작하고 멈추는 작업) 항상 요구사항을 만족시키는 
        어드바이스 중에서 가장 덜 강력한 것을 사용해라. 간단히 어드바이스 이전에 어떤 작업을 하려고 
        around advice를 사용하지 마라.</para>

        <para>around advice는 <literal>aop:around</literal>요소를 사용해서 선언한다. 
        어드바이스 메서드의 첫 파라미터는 반드시 <interfacename>ProceedingJoinPoint</interfacename> 
        타입이어야 한다. 어드바이스 바디내에서 <interfacename>ProceedingJoinPoint</interfacename>의 
        <literal>proceed()</literal>를 호출하면 의존하는 메서드가 실행된다. 
        <literal>proceed</literal> 메서드는 <classname>Object[]</classname>를 
        전달하면서 실행할 수도 있다. - 배열의 값은 진행되면서 메서드실행의 아규먼트로 사용될 것이다. 
        <classname>Object[]</classname>로 proceed를 호출하는 내용은 <xref
        linkend="aop-ataspectj-around-advice" />를 봐라.</para>

        <programlisting language="xml">&lt;aop:aspect id="aroundExample" ref="aBean"&gt;

    &lt;aop:around
      pointcut-ref="businessService" 
      method="doBasicProfiling"/&gt;
          
    ...
    
&lt;/aop:aspect&gt;</programlisting>

        <para><literal>doBasicProfiling</literal> 어드바이스의 구현체는 @AspectJ 
        예제와 완전히 똑같다.(물론 어노테이션은 빼고)</para>

        <programlisting language="java">public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
    <lineannotation>// 스톱워치 시작</lineannotation>
    Object retVal = pjp.proceed();
    <lineannotation>// 스톱워치 멈춤</lineannotation>
    return retVal;
}</programlisting>
      </section>

      <section id="aop-schema-params">
        <title>어드바이스 파라미터</title>

        <para>스키마 기반의 선언 방식은 @AspectJ 지원에서 설명한 것과 같은 방법으로 완전한 
        타입의 어드바이스를 지원한다.(어드바이스 메서드 파라미터에 대해서 이름으로 포인트컷 파라미터를 
        매칭하는 방법) 자세한 내용은 <xref linkend="aop-ataspectj-advice-params" />를 
        봐라. 어드바이스 메서드에 아규먼트의 이름을 명시적으로 지정하고 싶다면(앞에서 설명한 탐지 전력에 
        의존하지 않고) 어드바이스 요소의 <literal>arg-names</literal> 속성을 사용하면 된다. 
        <literal>arg-names</literal> 속성은 <xref
        linkend="aop-ataspectj-advice-params-names" />에서 설명한 어드바이스 
        어노테이션의 "argNames" 요소와 같은 방법으로 다룬다. 다음은 그 예제다.</para>

        <programlisting language="xml">&lt;aop:before
  pointcut="com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)"
  method="audit"
  arg-names="auditable"/&gt;</programlisting>

        <para><literal>arg-names</literal> 속성은 콤마로 구분된 파라미터 
        이름의 리스트를 받는다.</para>

        <para>약간 더 깊히 들어간 다음의 XSD 기반 접근의 예제는 다수의 강타입 파라미터의 
        결합에서 사용한 around advice를 보여준다.</para>

        <programlisting language="java">package x.y.service;

public interface FooService {

   Foo getFoo(String fooName, int age);
}

public class DefaultFooService implements FooService {

   public Foo getFoo(String name, int age) {
      return new Foo(name, age);
   }
}</programlisting>

        <para>다음은 관점이다. <methodname>profile(..)</methodname> 메서드는 
        다수의 강타입 파라미터를 받는데 첫 파라미터는 메서드 호출을 하는데 사용하는 조인포인트가 
        될 것이다. 이 메서드의 존재는 <methodname>profile(..)</methodname>가 
        <literal>around</literal> 어드바이스로 사용된다는 것을 의미한다.</para>

        <programlisting language="java">package x.y;

import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.util.StopWatch;

public class SimpleProfiler {

   public Object profile(ProceedingJoinPoint call, String name, int age) throws Throwable {
      StopWatch clock = new StopWatch(
            "Profiling for '" + name + "' and '" + age + "'");
      try {
         clock.start(call.toShortString());
         return call.proceed();
      } finally {
         clock.stop();
         System.out.println(clock.prettyPrint());
      }
   }
}</programlisting>

        <para>마지막으로 다음은 특정 조인포인트에서 위의 어드바이스가 실행되는데 필요한 
        XML 설정이다.</para>

        <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:aop="http://www.springframework.org/schema/aop"
      xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt;

   <lineannotation>&lt;!-- 이 객체는 스프링 AOP 기반이 프록시할 객체다 --&gt;</lineannotation>
   &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

   <lineannotation>&lt;!-- 이는 그 자체로 실제 어드바이스다 --&gt;</lineannotation>
   &lt;bean id="profiler" class="x.y.SimpleProfiler"/&gt;

   &lt;aop:config&gt;
      &lt;aop:aspect ref="profiler"&gt;

         &lt;aop:pointcut id="theExecutionOfSomeFooServiceMethod"
                    expression="execution(* x.y.service.FooService.getFoo(String,int))
                    and args(name, age)"/&gt;

         &lt;aop:around pointcut-ref="theExecutionOfSomeFooServiceMethod"
                  method="profile"/&gt;

      &lt;/aop:aspect&gt;
   &lt;/aop:config&gt;

&lt;/beans&gt;</programlisting>

        <para>다음의 드라이버 스크립터가 있다면 표준 출력에 다음과 같이 출력될 
        것이다.</para>

        <programlisting language="java">import org.springframework.beans.factory.BeanFactory;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import x.y.service.FooService;

public final class Boot {

   public static void main(final String[] args) throws Exception {
      BeanFactory ctx = new ClassPathXmlApplicationContext("x/y/plain.xml");
      FooService foo = (FooService) ctx.getBean("fooService");
      foo.getFoo("Pengo", 12);
   }
}</programlisting>

        <programlisting>StopWatch 'Profiling for 'Pengo' and '12'': running time (millis) = 0
-----------------------------------------
ms     %     Task name
-----------------------------------------
00000  ?  execution(getFoo)</programlisting>
      </section>

      <section id="aop-ordering">
        <title>어드바이스 순서</title>

        <para>여러 어드바이스가 같은 조인포인트(메서드 실행)에서 실행되어야 할 때 우선순위 
        규칙은 <xref linkend="aop-ataspectj-advice-ordering" />에서 설명했다. 
        관점들 사이의 우선순위는 관점을 지원하는 빈에 <interfacename>Order</interfacename> 
        어노테이션을 추가하거나 빈이 <interfacename>Ordered</interfacename> 
        인터페이스를 구현함으로써 결정된다.</para>
      </section>
    </section>

    <section id="aop-schema-introductions">
      <title>인트로덕션</title>

      <para>인트로덕션(AspectJ에서는 inter-type 선언이라고 부른다)은 관점이 주어진 인터페이스를 
      구현한 어드바이즈된 객체를 선언하고 이러한 객체 대신에 주어진 인터페이스의 구현체를 
      제공하도록 할 수 있다.</para>

      <para>인트로덕션은 <literal>aop:aspect</literal>내에서 
      <literal>aop:declare-parents</literal> 요소를 사용해서 만든다. 이 
      <literal>aop:declare-parents</literal> 요소는 새로운 부모(이름)를 가진 타입과의 
      매칭을 선언하는데 사용한다. 예를 들어 <interfacename>UsageTracked</interfacename> 
      인터페이스가 주어지고 이 인터페이스가 <classname>DefaultUsageTracked</classname>의 
      구현체일 때 서비스 인터페이스의 모든 구현체(implementor)를 선언하는 다음의 관점도 
      <interfacename>UsageTracked</interfacename> 인터페이스를 구현한다.
      (예를 들면 JMX로 통계를 노출하기 위해서)</para>

      <programlisting language="xml">&lt;aop:aspect id="usageTrackerAspect" ref="usageTracking"&gt;

  &lt;aop:declare-parents
      types-matching="com.xzy.myapp.service.*+"
      implement-interface="com.xyz.myapp.service.tracking.UsageTracked"
      default-impl="com.xyz.myapp.service.tracking.DefaultUsageTracked"/&gt;
  
  &lt;aop:before
    pointcut="com.xyz.myapp.SystemArchitecture.businessService()
              and this(usageTracked)"
    method="recordUsage"/&gt;
  
&lt;/aop:aspect&gt;</programlisting>

      <para><literal>usageTracking</literal> 빈을 지원하는 클래스는 다음 
      메서드를 가진다.</para>

      <programlisting language="java">public void recordUsage(UsageTracked usageTracked) {
    usageTracked.incrementUseCount();
}</programlisting>

      <para>구현되어야 할 인터페이스는 <literal>implement-interface</literal> 
      속성으로 결정한다. <literal>types-matching</literal> 속성의 값은 AspectJ 
      타입패턴이다. 매칭되는 타입의 모든 빈은 <interfacename>UsageTracked</interfacename> 
      인터페이스를 구현할 것이다. 위 예제의 before advice에서 서비스 빈을 
      <interfacename>UsageTracked</interfacename>의 구현체로 직접 사용할 수 있다. 
      프로그래밍적으로 빈에 접근하려면 다음과 같이 작성한다.</para>

      <programlisting language="java">UsageTracked usageTracked = (UsageTracked) context.getBean("myService");</programlisting>
    </section>

    <section id="aop-schema-instatiation-models">
      <title>관점 인스턴스화 모델</title>

      <para>스키마로 정의한 관점에서 지원하는 인스턴스화 모델은 싱글톤 모델뿐이다. 다은 인스턴스화 
      모델은 차기 버전에서 지원할 것이다.</para>
    </section>

    <section id="aop-schema-advisors">
      <title>어드바이저(Advisors)</title>

      <para>"어드바이저"의 개념은 스프링 1.2에서 정의한 AOP 지원에서 가져온 것으로 AspectJ에는 
      완전히 같은 것이 없다. 어드바이저는 하나의 어드바이스를 가진 작고 독립적인 관점과 같다. 
      어드바이스 자체는 빈으로 표현하고 <xref linkend="aop-api-advice-types" />에서 
      설명한 어드바이스 인터페이스 중의 하나를 구현해야 한다. 하지만 어드바이저는 AspectJ 
      포인트컷 표현식의 이점을 취할 수 있다.</para>

      <para>스프링 2.0은 어드바이저의 개념을 <literal>&lt;aop:advisor&gt;</literal> 
      요소로 지원한다. 스프링 2.0이 지원하는 전용 네임스페이스도 가진 트랜잭션이 가능한 어드바이스와 
      어드바이저를 결합해서 사용하는 것을 가장 많이 볼 것이다. 다음과 같이 정의한다.</para>

      <programlisting language="xml">&lt;aop:config&gt;

  &lt;aop:pointcut id="businessService"
        expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;

  &lt;aop:advisor 
      pointcut-ref="businessService"
      advice-ref="tx-advice"/&gt;
      
&lt;/aop:config&gt;

&lt;tx:advice id="tx-advice"&gt;
  &lt;tx:attributes&gt;
    &lt;tx:method name="*" propagation="REQUIRED"/&gt;
  &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</programlisting>
    </section>

    <para>위의 예제에서 사용한 <literal>pointcut-ref</literal> 속성처럼 인라인 포인트컷 
    표현식을 정의하는데 <literal>pointcut</literal> 속성을 사용할 수도 있다.</para>

    <para>어드바이스가 순서대로 참여할 수 있도록 어드바이저의 우선순위를 정의하려면 어드바이저의 
    <literal>Ordered</literal> 값을 정의하는 <literal>order</literal> 
    속성을 사용해라.</para>

    <section id="aop-schema-example">
      <title>예제</title>

      <para>스키마 지원을 사용해서 재작성했을 때 <xref linkend="aop-ataspectj-example" />의 
      동시성 락(locking)으로 인한 재시도 예제가 어떻게 되는지 보자.</para>

      <para>비즈니스 서비스의 실행은 종종 동시성 이슈때문에 실패할 수 있다.(예를 들면 데드락 실패) 
      작업을 재시도한다면 이번에는 성공할 가능성이 높아보인다. 재시도를 하는 것이 절적한 이러한 
      상황에서 클라이언트가 <classname>PessimisticLockingFailureException</classname>를 
      보지 않도록 비즈니스 서비스에 대해서 작업 재시도를 투명하게 처리할 것이다. 이는 서비스계층에서 
      여러 서비스에 걸쳐진 명확한 요구사항이므로 관점으로 구현하는 것이 이상적이다.</para>

      <para>작업을 재시도하기를 원하므로 여러번 proceed를 호출할 수 있도록 around advice를 
      사용해야 한다. 다음 예제에서 기본적인 관점 구현체가 어떻게 생겼는지 보여주고 있다.(그냥 
      스키마 지원을 사용하는 보통의 자바클래스다.)</para>

      <programlisting language="java">public class ConcurrentOperationExecutor implements Ordered {
   
   private static final int DEFAULT_MAX_RETRIES = 2;

   private int maxRetries = DEFAULT_MAX_RETRIES;
   private int order = 1;

   public void setMaxRetries(int maxRetries) {
      this.maxRetries = maxRetries;
   }
   
   public int getOrder() {
      return this.order;
   }
   
   public void setOrder(int order) {
      this.order = order;
   }
   
   public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable { 
      int numAttempts = 0;
      PessimisticLockingFailureException lockFailureException;
      do {
         numAttempts++;
         try { 
            return pjp.proceed();
         }
         catch(PessimisticLockingFailureException ex) {
            lockFailureException = ex;
         }
      }
      while(numAttempts &lt;= this.maxRetries);
      throw lockFailureException;
   }

}</programlisting>

      <para>관점이 <interfacename>Ordered</interfacename> 인터페이스를 구현하고 
      있으므로 트랜잭션 어드바이스보다 관점의 우선순위를 높게 설정할 수 있따.(재시도 할 때마다 
      새로운 트랜잭션을 사용하길 원한다.) <literal>maxRetries</literal>와 
      <literal>order</literal> 프로퍼티는 둘다 스프링이 설정할 것이다. 핵심 동작은 
      <literal>doConcurrentOperation</literal> around advice 메서드에서 이뤄진다. 
      proceed를 시도하고 <classname>PessimisticLockingFailureException</classname>로 
      실패했을 때 재시도 횟수를 모두 소진하지 않고 그냥 다시 시도한다.</para>

      <remark>이 클래스는 @AspectJ 예제에서 사용했던 것과 동일하지만 어노테이션은 
      제거했다.</remark>

      <para>동일한 스프링 설정은 다음과 같다.</para>

      <programlisting language="xml">&lt;aop:config&gt;

  &lt;aop:aspect id="concurrentOperationRetry" ref="concurrentOperationExecutor"&gt;

    &lt;aop:pointcut id="idempotentOperation"
        expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;
       
    &lt;aop:around
       pointcut-ref="idempotentOperation"
       method="doConcurrentOperation"/&gt;
  
  &lt;/aop:aspect&gt;

&lt;/aop:config&gt;

&lt;bean id="concurrentOperationExecutor"
  class="com.xyz.myapp.service.impl.ConcurrentOperationExecutor"&gt;
     &lt;property name="maxRetries" value="3"/&gt;
     &lt;property name="order" value="100"/&gt;  
&lt;/bean&gt;</programlisting>

      <para>당장은 모든 비즈니스 서비스가 멱등이라고 가정한다. 순수한 멱등 작업만 재시도하기 
      위해 관점을 개선할 수 있는 상황이 아니라면 
      <interfacename>Idempotent</interfacename> 어노테이션을 사용하고</para>

      <programlisting language="java">@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent {
  <lineannotation>// marker annotation</lineannotation>
}</programlisting>

      <para>서비스 작업의 구현체에 어노테이션을 사용한다. 멱등작업만 재시도하도록 관점을 변경하는 
      것은 <interfacename>@Idempotent</interfacename> 작업만 매칭되도록 포인트컷 
      표현식을 개선하는 것을 포함한다.</para>

      <programlisting language="xml">  &lt;aop:pointcut id="idempotentOperation"
        expression="execution(* com.xyz.myapp.service.*.*(..)) and
                    @annotation(com.xyz.myapp.service.Idempotent)"/&gt;</programlisting>
    </section>
  </section>

  <section id="aop-choosing">
    <title>사용할 AOP 선언방식 선택하기</title>

    <para>일단 주어진 요구사항을 구현하는데 관점이 가장 좋은 접근이라고 결정했다면 스프링 AOP와 
    AspectJ중에서 어느 것을 사용할 것인지, Aspect 언어(code) 방식, @AspectJ 어노테이션 방식, 
    스프링 XML 방식중에서 어느 것을 사용한 것인지 어떻게 결정하는다. 이러한 결정은 어플리케이션의 
    요구사항, 개발 도구, AOP에 대한 팀의 익숙도같은 많은 요소에 영향을 받는다.</para>

    <section id="aop-spring-or-aspectj">
      <title>Spring AOP냐? 완전한 AspectJ냐?</title>

      <para>작업할 수 있는 가장 간단한 것을 사용해라. 스프링 AOP는 개발이나 빌드 프로세스에 
      AspectJ 컴파일러/ 위버(weaver)를 도입해야 하는 요구사항이 없으므로 완전한 AspectJ를 
      사용하는 것보다 간단하다. 스프링 빈에서 작업의 실행을 어드바이즈 하는 것이 필요한 것의 전부라면 
      스프링 AOP가 좋은 선택이다. 스프링 컨테이너가 관리하지 않는 객체(보통 도메인 객체같은)를 
      어드바이즈 해야한다면 AspectJ를 사용해야 할 것이다. 간단한 메서들 실행외에 조인포인트를 
      어드바이즈해야 한다면 마찬가지로 AspectJ를 사용해야 할 것이다.(예를 들면 필드를 가져오거나 
      조인포인트를 설정하는 등)</para>

      <para>AspectJ를 사용하는 경우 AspectJ 언어 문법("code style"이라고도 알려진)과 
      @AspectJ 어노테이션 방식의 선택권이 있다. 알기 쉽게 자바 5이상을 사용하지 않는다면 code 
      style을 사용해야 한다. 설계상 관점이 커다란 역할을 한고 <ulink
      url="http://www.eclipse.org/ajdt/">AspectJ Development Tools (AJDT)</ulink> 
      이클립스 플러그인을 사용할 수 있다면 AspectJ 언어의 문법을 사용하는 것이 더 바람직하다. 
      AspectJ 언어가 관점을 작성하기 위한 목적으로 설계된 언어이기 때문에 더 깔끔하고 간단하다. 
      이클립스를 사용하지 않거나 어플리케이션에서 주요 역할을 하지 않는 약간의 관점만 가지고 있다면 
      IDE에서 일반적인 자바 컴파일과 @AspectJ 방식을 사용하고 빌드스크립트에 관점을 위빙하는 
      단계를 추가하는 것을 고려해라.</para>
    </section>

    <section id="aop-ataspectj-or-xml">
      <title>스프링 AOP에서 @AspectJ냐? XML이냐?</title>

      <para>스프링 AOP를 사용하기로 했다면 @AspectJ방식인지 XML방식인지를 선택해야 한다. 
      알기 쉽게 자바 5이상을 사용하지 않으면 XML 방식이 적절한 선택이다. 자바 5 프로젝트에서는 
      고려해야 할 여러가지 트레이드오프가 있다.</para>

      <para>기존 스프링 사용자들에게는 XML 방식이 가장 친숙할 것이다. XML 방식은 어떤 JDK 
      버전과도 사용할 수 있고(하지만 포인트컷 표현식내에서 이름이 붙은 포인트컷을 참조하는 것은 여전히 
      자바 5이상이 필요하다.) 순수한 POJO가 기반이 될 것이다. 엔터프라이스 서비스를 설정하는 도구로 
      AOP를 사용하는 경우 XML은 좋은 선택이 될 수 있다. (독립적으로 변경하기를 원하는 설정의 일부로 
      포인트컷 표현식을 고려하는 지가 좋은 검사방법이다.) XML방식을 사용하면 시스템에 어떤 관점이 
      있는지가 확실히 더 명확할 것이다.</para>

      <para>XML방식에는 두가지 단점이 있다. 첫째로 한 곳에서 요구사항의 구현부를 완전히 
      감추지(encapsulate) 못한다. DRY 원리에서는 시스템에는 어떤 정보(knowledge)라도 단 
      하나의 신뢰할 수 있고 명확한 정보만 있어야 한다고 말한다. XML 방식을 사용할 때 
      <emphasis>어떻게</emphasis> 요구사항이 구현되었느가 하는 정보는 기반이되는 빈 클래스의 
      선언과 설정파일의 XML에 나누어져 있다. @AspectJ 방식을 사용하는 경우에는 이러한 정보가 
      감추어진(encapsulated) 하나의 모듈(관점)이 있다. 두번째로 XML 방식은 @AspectJ 방식보다 
      표현할 수 있는 것이 약간 더 제한적이다. XML 방식에서는 "싱글톤" 관점 인스턴스화 모델만 지원하고 
      XML에서 선언한 이름이 붙은 포인트컷을 결합할 수 없다. 예를 들어 @AspectJ 방식에서는 
      다음과 같은 것을 작성할 수 있다.</para>

      <programlisting language="java">  @Pointcut(execution(* get*()))
  public void propertyAccess() {}

  @Pointcut(execution(org.xyz.Account+ *(..))
  public void operationReturningAnAccount() {}

  @Pointcut(propertyAccess() &amp;&amp; operationReturningAnAccount())
  public void accountPropertyAccess() {}</programlisting>

      <para>XML 방식으로 처음 두 포인트컷을 선언할 수 있다.</para>

      <programlisting language="xml">  &lt;aop:pointcut id="propertyAccess"
      expression="execution(* get*())"/&gt;

  &lt;aop:pointcut id="operationReturningAnAccount"
      expression="execution(org.xyz.Account+ *(..))"/&gt;</programlisting>

      <para>XML 접근의 단점은 이러한 정의와 결합하는 
      '<literal>accountPropertyAccess</literal>' 포인트컷을 정의할 수 
      없다는 것이다.</para>

      <para>@AspectJ 방식은 추가적인 인스턴스화 모델과 더 풍부한 포인트컷 조합을 지원한다. 
      모듈단위로 관점을 유지할 수 있는 것도 @AspectJ 방식의 장점이다. 또한 스프링 AOP와 AspectJ가 
      모두 @AspectJ 관점을 이해할 수 있다는 점도(그러므로 소비할 수 있다) 장점이다. 그러므로 나중에 
      추가적인 요구사항을 구현하는데 AspectJ의 기능이 필요하다고 결정했다면 아주 쉽게 AspectJ기반의 
      접근으로 마이그레이션 할 수 있다. 결국 스프링팀은 엔터프라이즈 서비스의 간단한 "설정"이상의 관점이 
      있다면 언제나 @AspectJ 방식을 더 선호한다.</para>
    </section>
  </section>

  <section id="aop-mixing-styles">
    <title>관점 타입 섞기</title>

    <para>오토프록시 지원을 사용한 @AspectJ방식의 관점, 스키마로 정의한 
    <literal>&lt;aop:aspect&gt;</literal> 관점, 어드바이저를 선언한 
    <literal>&lt;aop:advisor&gt;</literal>, 심지어 스프링 1.2방식을 사용해서 정의한 
    프록시와 인터셉터를 같은 설정파일에서 섞어서 사용하는 것이 가능하다. 이 모두는 동일한 지원 
    메카니즘에 기반해서 구현되었고 어떤 어려움도 없이 같이 둘 수 있다.</para>
  </section>

  <section id="aop-proxying">
    <title>프록싱 메카니즘</title>

    <para>스프링 AOP는 주어진 대상객체에 대한 프록시를 생성하는데 JDK 동적 프록시와 CGLIB를 
    모두 사용한다. (선택할 수 있을 때는 JDK 동적 프록시를 더 선호한다.)</para>

    <para>프록시되는 대상 객체가 최소 하나의 인터페이스를 구현했다면 JDK 동적 프록시를 사용할 
    것이다. 대상 타입이 구현한 모든 인터페이스는 프록시될 것이다. 대상 객체가 어떤 인터페이스도 
    구현하지 않았다면 CGLIB 프록시가 생성될 것이다.</para>

    <para>CGLIB 프록시를 사용하도록 강제하려면(예를 들어 인터페이스를 구현한 객체가 아니라 
    대상객체가 정의한 모든 메서드를 프록시하는 경우) 할 수 있지만 몇가지 이슈를 
    고려해봐야 한다.</para>

    <itemizedlist>
      <listitem>
        <para><literal>final</literal> 메서드는 오버라이드 할 수 없으므로 
        어드바이즈할 수 없다.</para>
      </listitem>

      <listitem>
        <para>JDK에서 동적 프록시를 사용할 수 있더라도 클래스 패스에 CGLIB 2 바이너리가 
        필요할 것이다. CGLIB이 필요한데 CGLIB 라이브러리 클래스가 클래스패스에 존재하지 않는다면 
        스프링은 자동으로 경고할 것이다.</para>
      </listitem>

      <listitem>
        <para>프록시된 객체의 생성자는 두번 호출될 것이다. 이는 CGLIB 프록시 모델의 자연스러운 
        결과로 각 프록시된 객체마다 하위클래스가 생성된다. 각각의 프록시된 인스턴스마다 실제 프록시된 
        객체와 어드바이스를 구현한 하위클래스의 인스턴스 두 개의 객체가 생성된다. JDK 프록시를 사용할 
        때는 이러한 동작이 없다. 생성자는 보통 할당을 하는 곳이고 실제 로직은 구현되어 있지 않기 때문에 
        보통 프록시된 타입의 생성자를 두번 호출하는 것은 이슈가 아니다.</para>
      </listitem>
    </itemizedlist>

    <para id="aop-autoproxy-force-CGLIB">CGLIB 프록시를 사용하도록 강제하려면 
    <literal>&lt;aop:config&gt;</literal> 요소의 
    <literal>proxy-target-class</literal> 속성의 값을 true로 설정해라.</para>

    <programlisting language="xml">&lt;aop:config <emphasis role="bold">proxy-target-class="true"</emphasis>&gt;
    <lineannotation>&lt;!-- 다른 빈은 여기에 정의한다... --&gt;</lineannotation>
&lt;/aop:config&gt;</programlisting>

    <para>@AspectJ 오토프록시를 사용할 때 CGLIB 프록시를 강제하려면 
    <literal>&lt;aop:aspectj-autoproxy&gt;</literal> 요소의 
    <literal>'proxy-target-class'</literal> 속성을 true로 설정해라.</para>

    <programlisting language="xml">&lt;aop:aspectj-autoproxy <emphasis role="bold">proxy-target-class="true"</emphasis>/&gt;</programlisting>

    <note>
      <para>여러 <literal>&lt;aop:config/&gt;</literal> 부분은 런타임시에 
      <literal>&lt;aop:config/&gt;</literal> 부분에서(보통 여러 XML 빈 정의 파일에서) 
      지정한 설정 중 <emphasis>가장 강력한</emphasis> 프록시 설정을 적용해서 하나의 통일된 
      오토프록시 창조자(creator)로 합쳐진다. 이는 
      <literal>&lt;tx:annotation-driven/&gt;</literal>와
      <literal>&lt;aop:aspectj-autoproxy/&gt;</literal>에도 적용된다.</para>

      <para>분명히 말하자면 <literal>&lt;tx:annotation-driven/&gt;</literal>,
      <literal>&lt;aop:aspectj-autoproxy/&gt;</literal>,
      <literal>&lt;aop:config/&gt;</literal> 요소의 
      '<literal>proxy-target-class="true"</literal>'를 사용하면 
      <emphasis>이 세가지 모두에</emphasis> CGLIB 프록시를 사용하도록 강제할 것이다.</para>
    </note>

    <section id="aop-understanding-aop-proxies">
      <title>AOP 프록시 이해하기</title>

      <para>스프링 AOP는 <emphasis>프록시 기반이다</emphasis>. 자신만의 관점을 작성하거나 
      스프링 프레임워크가 제공하는 스프링 AOP기반의 관점을 사용하기 전에 스프링 AOP가 프록시 
      기반이라는 말이 실제 의미하는 바를 이해하는 것은 무척 중요하다.</para>

      <para>다음 코드가 설명하는 일반적이고, 프록시되지 않고 특별한 것도 없으면서 직관적인 
      객체 참조를 가진 첫 시나리오를 생각해보자.</para>

      <programlisting language="java">public class SimplePojo implements Pojo {

   public void foo() {
      <lineannotation>// 다음의 메서드 호출은 'this' 참조상에서 <emphasis
            role="bold">직접</emphasis> 호출한다</lineannotation>
      this.bar();
   }
   
   public void bar() {
      <lineannotation>// 다른 로직...</lineannotation>
   }
}</programlisting>

      <para>객체 참조상에서 메서드를 호출하면 다음에서 보듯이 해당 객체참조 상에서 메서드가 
      <emphasis>직접</emphasis> 호출된다.</para>

      <para><mediaobject>
          <imageobject role="fo">
            <imagedata align="center"
                       fileref="images/aop-proxy-plain-pojo-call.png"
                       format="PNG" />
          </imageobject>

          <imageobject role="html">
            <imagedata align="center"
                       fileref="images/aop-proxy-plain-pojo-call.png"
                       format="PNG" />
          </imageobject>
        </mediaobject></para>

      <programlisting language="java">public class Main {

   public static void main(String[] args) {
   
      Pojo pojo = new SimplePojo();
      
      <lineannotation>// 이는 'pojo' 참조에서의 <emphasis role="bold">직접</emphasis> 메서드 호출이다</lineannotation>
      pojo.foo();
   }
}</programlisting>

      <para>클라이언트 코드가 가진 참조가 프록시일 경우에는 약간 달라진다. 
      다음 다이어그램과 코드를 보자.</para>

      <para><mediaobject>
          <imageobject role="fo">
            <imagedata align="center" fileref="images/aop-proxy-call.png"
                       format="PNG" />
          </imageobject>

          <imageobject role="html">
            <imagedata align="center" fileref="images/aop-proxy-call.png"
                       format="PNG" />
          </imageobject>
        </mediaobject></para>

      <programlisting language="java">public class Main {

   public static void main(String[] args) {
   
      ProxyFactory factory = new ProxyFactory(new SimplePojo());
      factory.addInterface(Pojo.class);
      factory.addAdvice(new RetryAdvice());

      Pojo pojo = (Pojo) factory.getProxy();
      
      <lineannotation>// 이는 <emphasis role="bold">프록시상에서의</emphasis> 메서드 호출이다!</lineannotation>
      pojo.foo();
   }
}</programlisting>

      <para>여기서 이해해야할 핵심은 <classname>Main</classname> 클래스의 
      <methodname>main(..)</methodname> 내부의 클라이언트 코드가 <emphasis>프록시에 
      대한 참조를 가지고 있다는 것이다</emphasis>. 이는 해당 메서드 참조에서의 메서드 호출은 
      프록시상에서 호출된고 이러한 프록시는 해당 메서드 호출과 관계된 모든 인터셉터(어드바이스)에 위임할 
      수 있다는 것을 의미한다. 하지만 일단 호출되면 결국 대상 객체에 도달한다.(이 경우에는 
      <classname>SimplePojo</classname> 참조) <methodname>this.bar()</methodname>나 
      <methodname>this.foo()</methodname>처럼 그 자체에서 호출된 모든 메서드는 프록시가 
      <emphasis>아니라</emphasis> <emphasis><literal>this</literal></emphasis> 참조에 
      대해서 호출될 것이다. 이는 중요한 의미를 가지는데 자기호출(self-invocation)이 실행될 기회를 
      가진 메서드 호출과 연관된 어드바이스가 되지 <emphasis>않을</emphasis> 것이라는 것을 
      의미한다.</para>

      <para>그래서 이와 관련해서 무엇이 이뤄지는가? 가장 좋은 접근(여기서 좋은 이라는 말은 
      느슨하다(loosely)는 의미로 사용한다.)은 자기호출(self-invocation)이 일어나지 않도록 
      코드를 리팩토링 하는 것이다. 이는 확실히 개발자가 약간의 작업을 해야하지만 그대로 가장 좋고 덜 
      침략적인(least-invasive) 접근이다. 다음 접근은 정말로 터무니 없는 것이기 때문에 이 접근을 
      명확하게 설명하는 것이 조심스럽다. 다음과 같이 해서 클래스내의 로직을 스프링 AOP에 완전히 
      밀접하게 연결할 수 있다.(숨이 막힌다!)</para>

      <programlisting language="java">public class SimplePojo implements Pojo {

   public void foo() {
      <lineannotation>// 이는 동작하기는 하지만...</lineannotation>
      ((Pojo) AopContext.currentProxy()).bar();
   }
   
   public void bar() {
      <lineannotation>// 다른 로직...</lineannotation>
   }
}</programlisting>

      <para>이는 코드가 스프링 AOP에 완전히 커플링되었고 클래스 자체가 AOP를 무시하고 AOP 
      컨텍스트에서 사용된다는 것은 인지하게 만든다. 프록시를 생성했을 때는 추가적인 설정도 
      필요하다.</para>

      <programlisting language="java">public class Main {

   public static void main(String[] args) {
   
      ProxyFactory factory = new ProxyFactory(new SimplePojo());
      factory.adddInterface(Pojo.class);
      factory.addAdvice(new RetryAdvice());
      <lineannotation><emphasis role="bold">factory.setExposeProxy(true);</emphasis></lineannotation>

      Pojo pojo = (Pojo) factory.getProxy();

      <lineannotation>// 이는 <emphasis role="bold">프록시상에서의</emphasis> 메서드 호출이다!</lineannotation>
      pojo.foo();
   }
}</programlisting>

      <para>마지막으로 AspectJ는 프록시기반의 AOP 프레임워크가 아니므로 이러한 
      자기호출(self-invocation) 이슈가 없다는 것을 알아야 한다.</para>
    </section>
  </section>

  <section id="aop-aspectj-programmatic">
    <title>@AspectJ 프록시의 프로그래밍적인 생성</title>

    <para><literal>&lt;aop:config&gt;</literal>나 
    <literal>&lt;aop:aspectj-autoproxy&gt;</literal>를 사용하는 설정에서 관점을 
    선언하는데 추가적으로 프로그래밍적으로 대상객체를 어드바이즈하는 프록시를 생선하는 것도 가능하다. 
    스프링 AOP API의 전체 내용은 다은 장에서 본다. 여기서는 @AspectJ 관점을 사용하는 프록시를 
    자동으로 생성하는 능력에 집중하려고 한다.</para>

    <para>하나 이상의 @AspectJ 관점이 어드바이즈하는 대상객체에 대한 프록시를 생성하는데 
    <classname>org.springframework.aop.aspectj.annotation.AspectJProxyFactory</classname> 
    클래스를 사용할 수 있다. 다음에서 설명하듯이 이 클래스의 기본적인 사용방법은 아주 간단하다. 
    전체 내용은 Javadoc을 봐라.</para>

    <programlisting language="java"><lineannotation>// 주어진 대상객체에 대한 프록시를 만들 수 있는 팩토리를 생성한다</lineannotation>
AspectJProxyFactory factory = new AspectJProxyFactory(targetObject); 

<lineannotation>// 관점을 추가한다, 클래스는 @AspectJ 관점이어야 한다
// 다른 관점과 필요한만큼 여러번 이 메서드를 호출할 수 있다</lineannotation>
factory.addAspect(SecurityManager.class);

<lineannotation>// 이미 존재하는 관점 인스턴스도 추가할 수 있다. 제공된 객체의 타입은 @AspectJ 관점이어야 한다</lineannotation>
factory.addAspect(usageTracker);	

<lineannotation>// 여기서 관점 객체를 획득한다...</lineannotation>
MyInterfaceType proxy = factory.getProxy();</programlisting>
  </section>

  <section id="aop-using-aspectj">
    <title>스프링 어플리케이션에서 AspectJ 사용하기</title>

    <para>이번 장에서 지금까지 본 내용은 전부 순수 스프링 AOP다. 이번 섹션에서는 스프링 AOP가 
    단독으로 제공하는 기능이상이 필요한 경우 어떻게 스프링 AOP 대신(또는 추가적으로) AspectJ 
    컴파일러/위버를 사용하는지 볼 것이다.</para>

    <para>스프링은 <filename class="libraryfile">spring-aspects.jar</filename>에서 
    단독으로 사용할 수 있는 작은 AspectJ 관점 라이브러리를 같이 제공한다. 이 라이브러리의 관점을 
    사용하려면 라이브러리를 클래스 패스에 추가해야 한다. <xref linkend="aop-atconfigurable"/>와 
    <xref linkend="aop-ajlib-other"/>에서 이 라이브러리의 내요와 어떻게 사용하는 지를 설명하고 
    있다. <xref linkend="aop-aj-configure"/>에서는 AspectJ 컴파일러로 위빙된 AspectJ 관점을 
    어떻게 의존성 주입하는 지를 설명한다. 마지막으로 <xref linkend="aop-aj-ltw"/>에서는 AspectJ를 
    사용하는 스프링 어플리케이션의 로드타임 위빙(load-time weaving)에 대한 인트로덕션을 설명한다.</para>

    <section id="aop-atconfigurable">
      <title>스프링에 도메인 객체를 의존성 주입시 AspectJ 사용하기</title>

      <para>스프링 컨테이너는 어플리케이션 컨텍스트에 정의된 빈들을 인스턴스화하고 설정한다. 스프링 
      컨테이너는 주어진 이름의 빈 정의가 담고 있는 설정을 적용하기 위해 <emphasis>미리 존재하는
      </emphasis> 객체를 설정하는 빈 팩토리를 요청할 수도 있다. 
      <filename class="libraryfile">spring-aspects.jar</filename>에는 
      <emphasis>어떠한 빈에도</emphasis> 의존성 주입을 할 수 있는 기능을 이용하는 어노테이션 
      주도(annotation-driven) 관점이 포함되어 있다. 이 기능은 <emphasis>컨테이너의 제어범위 
      밖에서</emphasis> 생성된 객체에 사용하기 위함이다. 도메인 객체는 때로 
      <literal>new</literal> 오퍼레이터나 데이터베이스 쿼리를 위한 ORM 도구를 사용해서 
      프로그래밍적으로 생성하기 때문에 이 범주에 포함되곤 한다.</para>

      <para><interfacename>@Configurable</interfacename> 어노테이션은 클래스가 
      스프링주도(Spring-driven) 설정에 적합함을 나타낸다. 가장 간단한 경우에 단순히 
      마커(marker) 어노테이션으로 사용할 수 있다.</para>

      <programlisting language="java">package com.xyz.myapp.domain;

import org.springframework.beans.factory.annotation.Configurable;

@Configurable
public class Account {
   <lineannotation>// ...</lineannotation>
}</programlisting>

      <para>이 방법으로 마커 인터페이스로 사용할 때 스프링은 정규화된 타입 이름
      (<classname>com.xyz.myapp.domain.Account</classname>)과 같은 이름인 프로토타입 
      범위의 빈 정의를 사용해서 어노테이션이 붙은 타입(이 경우에는 
      <classname>Account</classname>)의 새로운 인스턴스를 설정할 것이다. 빈의 기본 이름이 
      해당 타입의 정규화된 이름이므로 프로토타입 정의를 선언하는 편한 방법은 <literal>id</literal> 
      속성은 그냥 생략하는 것이다.</para>

      <programlisting language="xml">&lt;bean class="com.xyz.myapp.domain.Account" scope="prototype"&gt;
  &lt;property name="fundsTransferService" ref="fundsTransferService"/&gt;
&lt;/bean&gt;</programlisting>

      <para>사용할 프로토타입 빈 정의의 이름을 명시적으로 지정하고 싶다면 어노테이션내에서 
      직접 지정할 수 있다.</para>

      <programlisting language="java">package com.xyz.myapp.domain;

import org.springframework.beans.factory.annotation.Configurable;

@Configurable("account")
public class Account {
   <lineannotation>// ...</lineannotation>
}</programlisting>

      <para>위와 같이 지정하면 스프링은 "<literal>account</literal>"라는 이름의 빈 정의를 
      찾아서 새로운 <classname>Account</classname> 인스턴스를 설정하는 정의로 사용할 
      것이다.</para>

      <para>프로토타입 범위의 빈 정의를 전혀 지정하지 않고 자동연결을 사용할 수도 있다. 스프링이 
      자동연결을 하도록 하려면 <interfacename>@Configurable</interfacename> 어노테이션의 
      '<literal>autowire</literal>' 프로퍼티를 사용해라. 이름이나 타입으로 자동연결하도록 각각 
      <literal>@Configurable(autowire=Autowire.BY_TYPE)</literal>나 
      <literal>@Configurable(autowire=Autowire.BY_NAME</literal>를 지정해라. 
      대안으로는 스프링 2.5에서처럼 필드나 메서드 레벨에서 <interfacename>@Autowired</interfacename>나 
      <interfacename>@Inject</interfacename>를 사용해서 
      <interfacename>@Configurable</interfacename> 빈에 명시적이고 어노테이션 주도적인 
      의존성 주입을 지정하는 것이 바람직하다. (더 자세한 내용은 
      <xref linkend="beans-annotation-config" />를 봐라.)</para>

      <para>마지막으로 <literal>dependencyCheck</literal> 속성을 사용해서 새롭게 생성되고 
      설정된 객체내의 객체 참조들에 대해 스프링이 의존성 검사를 하도록 할 수 있다. (예시: 
      <literal>@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)</literal>) 
      <literal>dependencyCheck</literal>를 true로 설정하면 모든 프로퍼티(<emphasis>프리미티브 
      타입이나 컬렉션은 아니다.</emphasis>)를 설정한 후에 스프링이 유효성검사를 할 것이다.</para>

      <para>어노테이션을 자기자신에게 사용하는 것은 당연히 아무런 의미가 없다. 어노테이션이 있는 
      곳에서 동작하는 <filename class="libraryfile">spring-aspects.jar</filename>의 
      <classname>AnnotationBeanConfigurerAspect</classname>이다. 본질적으로 관점은 
      "<interfacename>@Configurable</interfacename> 어노테이션이 붙은 타입의 새로운 
      객체의 초기화과정이 반환된 후 어노테이션의 프로퍼티에 따라 스프링을 사용해서 새롭게 생성된 객체를 
      설정한다."고 말한다. 이 맥락에서 <interfacename>Serializable</interfacename> 객체가 
      역직렬화를 겪는 것처럼 <emphasis>초기화과정</emphasis>은 새롭게 인스턴스화된 객체를 의미한다. 
      (예시: <ulink
      url="http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html">readResolve()</ulink>를 
      통해서)</para>

      <note>
        <para>위의 문단에서 핵심 중 하나는 '<emphasis>본질적으로</emphasis>'이다. 대부분의 
        경우에서 '<emphasis>새로운 객체의 초기화과정이 반환된 후</emphasis>'의 정확한 의미는 
        충분할 것이다. 이 문맥에서 '<emphasis>초기화 과정 이후</emphasis>'는 객체가 생성된 
        <emphasis>이후에</emphasis> 의존성이 주입될 것이라는 의미이다. 즉, 클래스의 생성자 
        바디에서는 의존성을 사용할 수 없다는 의미이다. 생성자 바디를 실행하기 
        <emphasis>이전에</emphasis> 의존성을 주입해서 생성자의 바디안에서 사용할 수 있게 
        하려면 <interfacename>@Configurable</interfacename> 선언에 다음과 같이 
        정의해야 한다.</para>

        <programlisting language="java">@Configurable(preConstruction=true)</programlisting>

        <para>AspectJ의 다양한 포인트컷 타입의 언어 시맨틱에 대한 자세한 내용은 <ulink
        url="http://www.eclipse.org/aspectj/doc/next/progguide/index.html">AspectJ
        Programming Guide</ulink>의 <ulink
        url="http://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html">부록
        </ulink>을 참고해라.</para>
      </note>

      <para>이것이 동작하려면 어노테이션이 붙은 타입이 AspectJ 위버로 위빙되어야 한다. - 이 
      작업을 할 빌드시점의 Ant나 Maven 태스크(<ulink
      url="http://www.eclipse.org/aspectj/doc/released/devguide/antTasks.html">AspectJ
      Development Environment Guide</ulink>의 예제를 봐라.)를 사용하거나 로딩시점의 위빙(<xref
      linkend="aop-aj-ltw"/>를 봐라.)을 사용할 수 있다. 
      <classname>AnnotationBeanConfigurerAspect</classname> 자체가 스프링으로 설정되어야 
      한다.(새로운 객체를 설정하는데 사용할 빈 팩토리에 대한 참조를 획득하기 위해서) 스프링 <link
      linkend="xsd-config-body-schemas-context"><literal>context</literal>
      네임스페이스</link>는 이 작업을 하는 편리한 태그를 정의한다. 어플리케이션 컨텍스트 
      설정에 다음을 포함시켜라.</para>

      <programlisting language="xml">&lt;context:spring-configured/&gt;</programlisting>

      <para>스키마 대신에 DTD를 사용하면 다음 정의가 똑같은 역할을 한다.</para>

      <programlisting language="xml">&lt;bean 
      class="org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect"
      factory-method="aspectOf"/&gt;</programlisting>

      <para>관점이 설정되기 <emphasis>이전에</emphasis> 생성된 
      <interfacename>@Configurable</interfacename> 객체의 인스턴스는 로깅을 하는데 
      이슈가 될 수 있고 생성되는 객체의 설정이 없다는 경고가 나올 것이다. 예제는 스프링이 초기화할 
      때 도메인 객체들을 생성하는 스프링 설정의 빈이 될 것이다. 이 경우에 수동으로 설정 관점에 
      의존하는 빈을 지정하는 "depends-on" 빈 속성을 사용할 수 있다.</para>

      <programlisting language="xml">&lt;bean id="myService"
  class="com.xzy.myapp.service.MyService"
  depends-on="org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect"&gt;

  <lineannotation>&lt;!-- ... --&gt;</lineannotation>

&lt;/bean&gt;</programlisting>

      <note>
        <para><interfacename>@Configurable</interfacename>
        실제로 런타임시에 해당 시맨틱에 의존하려는 의도가 없다면 빈 설정자 관점(bean 
        configurer aspect)을 통해서 <interfacename>@Configurable</interfacename> 
        처리를 활성화하지 말아라. 특히 일반적인 스프링 빈처럼 컨테이너에 등록된 빈 클래스에 
        <interfacename>@Configurable</interfacename>를 사용하지 말아라. 그렇지 
        않으면 초기화가 컨테이너에서 한번, 관점에서 한번, 이렇게 두번 발생한다.</para>
      </note>

      <section id="aop-configurable-testing">
        <title><interfacename>@Configurable</interfacename> 객체의 
        유닛테스트</title>

        <para><interfacename>@Configurable</interfacename> 지원의 목표 중 하나는 
        하드 코딩된 검색과 연관되는 어려움없이 도메인 객체의 독립적인 유닛 테스팅을 가능하게 하는 
        것이다. <interfacename>@Configurable</interfacename> 타입이 AspectJ로 위빙되지 
        않았다면 어노테이션은 유닛테스트에는 영향을 미치지 않으므로 테스트 객체에서 목(mock)이나 
        스텁(stub) 프로퍼티 참조를 설정해서 평소처럼 처리할 수 있다. 
        <interfacename>@Configurable</interfacename> 타입이 AspectJ로 
        <emphasis>위빙된</emphasis> 경우에도 평소처럼 컨테이너밖에서 유닛테스트를 할 수 있지만 
        <interfacename>@Configurable</interfacename> 객체를 생성할 때마다 해당 객체는 
        스프링이 설정하지 않았다는 경고메시지를 볼 것이다.</para>
      </section>

      <section id="aop-configurable-container">
        <title>여러 어플리케이션 컨텍스트에서 동작하기</title>

        <para><interfacename>@Configurable</interfacename> 지원을 구현하는데 사용한 
        <classname>AnnotationBeanConfigurerAspect</classname>는 AspectJ 싱글톤 
        관점이다. 싱글톤 관점의 범위는 <literal>static</literal> 멤버의 범위와 같다. 즉, 
        타입을 정의하는 클래스로더마다 하나의 관점 인스턴스가 존재한다. 이는 같은 클래스로더 계층내에서 
        여러 어플리케이션 컨텍스트를 정의한 경우 어디에 
        <literal>&lt;context:spring-configured/&gt;</literal> 빈을 정의하고 클래스패스 
        어디에 <filename class="libraryfile">spring-aspects.jar</filename> 파일을 
        둘 것인지를 고려해봐야 한다.</para>

        <para>공통의 비즈니스 서비스들과 이 서비스가 필요로하는 모든 것들을 정의하는 부모 
        어플리케이션 컨텍스트를 공유하고 해당 서블릿마다 개별적인 정의를 담고 있는 하나의 자식 
        어플리케이션 컨텍스트를 가진 전형적인 스프링 웹앱 설정을 생각해 보자. 이러한 컨텍스트들은 
        모두 같은 클래스로더 계층내에서 같이 존재할 것이므로 
        <literal>AnnotationBeanConfigurerAspect</literal>는 컨텍스트 중 하나에 대한 
        참조만 가질 수 있다. 이 경우에는 공유된 (부모) 어플리케이션 컨텍스트에 
        <literal>&lt;context:spring-configured/&gt;</literal> 빈을 정의하기를 권장한다. 
        이는 도메인 객체에 주입할 서비스를 정의한다. 그 결과 @Configurable 메카니즘을 사용해서 
        자식(서블릿에 한정된) 컨텍스트에서 정의한 빈에 대한 참조를 가진 도메인 객체를 설정할 수 
        없다.(어쨌든 당신이 하려고 하는 것은 아닐 것이다.)</para>

        <para>같은 컨테이너안에 여러 웹 어플리케이션을 배포한다면 각 웹 어플리케이션이 각자의 
        클래스로더를 사용해서 <filename class="libraryfile">spring-aspects.jar</filename>의 
        타입을 로드하는 것을 보장해야 한다.(예를 들면 <filename class="directory">
        'WEB-INF/lib'</filename>에 <filename class="libraryfile">spring-aspects.jar
        </filename>를 둠으로써) <filename class="libraryfile">spring-aspects.jar
        </filename>만을 컨테이너 범위의 클래스패스(container wide classpath)에 추가했다면 
        아마도 원하지 않는 동일한 관점 인스턴스를 모든 웹 어플리케이션이 공유할 것이다.</para>
      </section>
    </section>

    <section id="aop-ajlib-other">
      <title>AspectJ에 대한 스프링의 다른 관점들(aspects)</title>

      <para><interfacename>@Configurable</interfacename> 관점에 추가적으로 
      <filename class="libraryfile">spring-aspects.jar</filename>는 
      <interfacename>@Transactional</interfacename> 어노테이션이 붙은 타입과 
      메서드의 스프링의 트랜잭션 관리에 사용할 수 있는 AspectJ 관점을 담고 있다. 이는 
      스프링 컨테이너 외부에서 스프링 프레임워크의 트랜잭션 지원을 사용하려는 사용자를 
      위한 것이 주목적이다.</para>

      <para><interfacename>@Transactional</interfacename> 어노테이션은 해석하는 관점은 
      <classname>AnnotationTransactionAspect</classname>이다. 이 
      <classname>AnnotationTransactionAspect</classname> 관점을 사용하는 경우에는 
      반드시 구현한 인터페이스(존재한다면)가 <emphasis>아니라</emphasis> 
      <emphasis>구현(implementation)</emphasis> 클래스에 어노테이션을 붙혀야 한다.(또는 
      해당 클래스의 메서드에) AspectJ는 인터페이스에 붙은 어노테이션은 <emphasis>상속되지 
      않는다</emphasis>는 자바의 규칙을 따른다.</para>

      <para>클래스에 붙은 <interfacename>@Transactional</interfacename> 어노테이션은 
      해당 클래스의 모든 <emphasis>퍼블릭</emphasis> 작업의 실행에 기본 트랜잭션 
      의미(semantics)를 지정한다.</para>

      <para>클래스내의 메서드에 붙은 <interfacename>@Transactional</interfacename> 
      어노테이션은 클래스 어노테이션(존재한다면)의 기본 트랜잭션 의미를 덮어쓴다. 
      <literal>public</literal>, <literal>protected</literal>, 기본 가시성의 
      메서드는 모두 어노테이션이 붙을 것이다. <literal>protected</literal>와 기본 가시성을 
      가진 메서드에 직접 어노테이션을 붙히는 것이 이러한 메서드의 실행에 대한 트랜잭션 경계를 
      얻는 유일한 방법이다.</para>

      <para>스프링 설정과 트랜잭션 관리는 사용하고 싶지만 어노테이션은 사용하고 싶지 않은(또는 
      사용할 수 없는) AspectJ 프로그래머들을 위해서 자신만의 포인트컷 정의를 제공하려고 확장할 
      수 있는 <literal>abstract</literal> 관점도 
      <filename class="libraryfile">spring-aspects.jar</filename>에 포함되어 있다. 
      더 자세한 내용은 <classname>AbstractBeanConfigurerAspect</classname>와 
      <classname>AbstractTransactionAspect</classname> 관점의 소스를 봐라. 예제로써 
      정규화된 클래스 이름을 매칭하는 프로토타입 빈 정의를 사용한 도메인 모델에서 정의한 객체의 모든 
      인스턴스를 설정하는 관점을 어떻게 작성할 수 있는지 다음의 발췌한 소스에서 보여준다.</para>

      <programlisting language="java">public aspect DomainObjectConfiguration extends AbstractBeanConfigurerAspect {

  public DomainObjectConfiguration() {
    setBeanWiringInfoResolver(new ClassNameBeanWiringInfoResolver());
  }

  <lineannotation>// 새로운 빈의 생성 (도메인 모델의 어떤 객체)</lineannotation>
  protected pointcut beanCreation(Object beanInstance) :
    initialization(new(..)) &amp;&amp;
    SystemArchitecture.inDomainModel() &amp;&amp; 
    this(beanInstance);
		   		   
}</programlisting>
    </section>

    <section id="aop-aj-configure">
      <title>스프링 IoC를 사용해서 AspectJ 관점 설정하기</title>

      <para>스프링 어플리케이션에서 AspectJ 관점을 사용할 때 스프링을 사용해서 이러한 관점을 
      설정할 수 있기를 원하고 기대하는 것은 자연스럽다. AspectJ 런타임 스스로가 관점을 생성하는 
      책임이 있고 관점이 사용하는 AspectJ 인스턴스화 모델('<literal>per-xxx</literal>' 
      절)에 의존하는 스프링으로 관점을 생성하는 AspectJ를 설정하는 방법이다.</para>

      <para>대부분의 AspectJ 관점은 <emphasis>싱글톤</emphasis> 관점이다. 이러한 관점의 
      설정은 아주 쉽다. 그냥 평소처럼 관점 타입을 참조하는 빈 정의를 생성하고 
      <literal>'factory-method="aspectOf"'</literal> 빈 속성을 포함한다. 이는 
      스프링이 스스로 인스턴스를 생성하려고 시도하지 않고 AspectJ에 관점 인스턴스를 요청해서 
      획득하도록 한다. 예를 들면 다음과 같다.</para>

      <programlisting language="xml">&lt;bean id="profiler" class="com.xyz.profiler.Profiler"
      <emphasis role="bold">factory-method="aspectOf"</emphasis>&gt;
  &lt;property name="profilingStrategy" ref="jamonProfilingStrategy"/&gt;
&lt;/bean&gt;</programlisting>

      <para>싱글톤이 아닌 관점을 설정하기가 약간 더 어렵다. 하지만 프로토타입 빈 정의를 생성하고 
      AspectJ 런타임이 일단 생성한 관점 인스턴스를 설정하는데 <filename 
      class="libraryfile">spring-aspects.jar</filename>의 
      <interfacename>@Configurable</interfacename> 지원을 사용해서 
      설정할 수 있다.</para>

      <para>AspectJ로 위빙하려는 몇몇 @AspectJ 관점들(예를 들어 도메인 모델 타입에 
      로드타임(load-time) 위빙을 사용하는 경우)과 스프링 AOP로 사용하려는 다른 @AspectJ 
      관점들(이러한 관점들은 모두 스르링을 사용해서 설정한다.)이 있다면 설정에서 정의한 @AspectJ 
      관점들의 정확한 서브셋인 스프링 AOP @AspectJ 오토프록싱을 오토프록싱에 사용하도록 지정해야 
      한다. 이는 <literal>&lt;aop:aspectj-autoproxy/&gt;</literal> 선언내부에서 하나 
      이상의 <literal>&lt;include/&gt;</literal> 요소를 사용해서 지정할 수 있다. 각 
      <literal>&lt;include/&gt;</literal> 요소는 이름패턴을 지정해서 최소 하나이상의 
      패턴과 매칭된 이름을 가진 빈에만 스프링 AOP 오토프록시 설정을 사용한다.</para>

      <programlisting language="xml">&lt;aop:aspectj-autoproxy&gt;
  &lt;aop:include name="thisBean"/&gt;
  &lt;aop:include name="thatBean"/&gt;
&lt;/aop:aspectj-autoproxy&gt;</programlisting>

      <note>
        <para><literal>&lt;aop:aspectj-autoproxy/&gt;</literal> 요소의 이름때문에 
        오해하지 말아라. <literal>&lt;aop:aspectj-autoproxy/&gt;</literal>를 사용하면 
        <emphasis>스프링 AOP 프록시</emphasis>를 생성할 것이다. @AspectJ 방식의 관점 
        선언을 여기서 사용하지만 AspectJ 런타임은 포함되지 <emphasis>않는다</emphasis>.</para>
      </note>
    </section>

    <section id="aop-aj-ltw">
      <title>스프링 프레임워크에서 AspectJ를 사용한 로드타임 위빙(Load-time weaving)</title>

      <para>로드타임 위빙(Load-time weaving, LTW)은 AspectJ 관점들이 자바 버츄얼 머신 
      (JVM)에 로딩되듯이 어플리케이션의 클래스 파일에 위빙되는 과정을 말한다. 이번 섹션은 스프링 
      프레임워크의 특정 컨텍스트에서 LTW를 설정하고 사용하는데 집중한다. 이번 섹션은 LTW를 소개하는 
      섹션이 아니다. LTW의 구체적인 내용과 AspectJ로 LTW를 설정하는 자세한 내용(스프링은 전혀 
      사용하지 않고)은 <ulink
      url="http://www.eclipse.org/aspectj/doc/released/devguide/ltw.html">AspectJ 
      개발환경 가이드의 LTW 부분</ulink>을 봐라.</para>

      <para>스프링 프레임워크에 AspectJ LTW를 적용해서 얻는 이득은 위빙과정보다 훨씬 세밀한 제어를 
      할 수 있다는 것이다. '평범한' AspectJ LTW는 JVM을 기동할 때 VM 아규먼트를 지정해서 켜지는 
      자바 (5+) 에이전트의 영향을 받는다. 그러므로 이는 JVM의 설정이고 몇몇 경우에는 잘 동작할 것이지만 
      때로는 너무 거친 설정이다. 스프링에 적용된 LTW는 명확히 훨씬 세밀하고 '하나의 JVM에서 여러 
      어플리케이션을 사용하는' 환경(일반적인 어플리케이션 서버환경처럼)에 더 적합한 
      <emphasis><classname>ClassLoader</classname>마다</emphasis> 
      LTW를 켤 수 있다.</para>

      <para>더군다나, <link linkend="aop-aj-ltw-environments">어떤 환경에서는</link> 
      이 지원으로 <literal>-javaagent:path/to/aspectjweaver.jar</literal> 
      (이 섹션 후반에서 설명한다)나 
      <literal>-javaagent:path/to/org.springframework.instrument-{version}.jar</literal>를
      (앞에서 <literal>spring-agent.jar</literal>라고 얘기한) 추가해야 하는 <emphasis>
      어플리케이션 서버의 실행 스크립트를 수정하지 않고도</emphasis> 로드타입 위빙을 적용할 수 있다. 
      개발자들은 보통 실행 스크립트 같은 배포설정을 담당하는 관리자들에게 의존하지 않고도 어플리케이션 
      컨텍스트를 구성하는 하나 이상의 파일에 로드타임 위빙을 사용하도록 수정할 수 있다.</para>

      <para>이제 설득은 그만하고 스프링을 사용하는 AspectJ LTW의 간단한 예제를 보자. 
      다음 에제에서 사용한 요소에 대한 제사한 내용은 이어서 설명한다. 전체 예제는 Petclinic 
      <link linkend="new-in-3.0-samples">샘플</link> 러플리케이션을 보길 바란다.</para>

      <section id="aop-aj-ltw-first-example">
        <title>첫 예제</title>

        <para>시스템의 성능 문제의 원인을 찾는 어플리케이션 개발자라고 가정해 보자. 프로파일링 
        도구를 사용하는 대신에 우리가 할 작업은 성능 매트릭스를 아주 빠르게 얻을 수 있는 간단한 
        프로파일링 관점을 적용해서 즉시 특정영역에 세밀한 프로파일링 도구를 적용할 수 있도록 
        한다.</para>

        <para>다음은 프로파일링 관점이다. 아주 고급스러운 것은 없고 단순히 @AspectJ 방식의 
        관점 선언을 사용해서 빠르고 거친(quick-and-dirty) 시간에 기반한 
        프로파일러다.</para>

        <programlisting language="java">package foo;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.util.StopWatch;
import org.springframework.core.annotation.Order;

@Aspect
public class ProfilingAspect {

    @Around("methodsToBeProfiled()")
    public Object profile(ProceedingJoinPoint pjp) throws Throwable {
        StopWatch sw = new StopWatch(getClass().getSimpleName());
        try {
            sw.start(pjp.getSignature().getName());
            return pjp.proceed();
        } finally {
            sw.stop();
            System.out.println(sw.prettyPrint());
        }
    }

    @Pointcut("execution(public * foo..*.*(..))")
    public void methodsToBeProfiled(){}
}
</programlisting>

        <para>클래스에 <classname>ProfilingAspect</classname>를 위빙하려는 AspectJ 
        위버를 알려주도록 '<filename>META-INF/aop.xml</filename>' 파일을 생성할 필요도 
        있을 것이다. 주로 ' <filename>META-INF/aop.xml</filename>'라는 파일을 자바 
        클래스패스에 두는 것이 표준 AspectJ의 관례이다.</para>

        <programlisting language="xml">&lt;!DOCTYPE aspectj PUBLIC
        "-//AspectJ//DTD//EN" "http://www.eclipse.org/aspectj/dtd/aspectj.dtd"&gt;
&lt;aspectj&gt;

    &lt;weaver&gt;

        <lineannotation>&lt;!-- 어틀리케이션에 한정된 팩키지의 클래스만 위빙한다 --&gt;</lineannotation>
        &lt;include within="foo.*"/&gt;

    &lt;/weaver&gt;

    &lt;aspects&gt;

        <lineannotation>&lt;!-- 이 관점을 위빙한다 --&gt;</lineannotation>        
        &lt;aspect name="foo.ProfilingAspect"/&gt;

    &lt;/aspects&gt;

  &lt;/aspectj&gt;</programlisting>

        <para>이제 스프링에 설정을 할 차례다. <interfacename>LoadTimeWeaver</interfacename>
        를(뒤에서 자세히 설명할 것이므로 지금은 그냥 알아만 둬라.) 설정해야 한다. 이 로드타임 위버가 하나 
        이상의 '<filename>META-INF/aop.xml</filename>' 파일의 관점 설정을 어플리케이션의 
        클래스들에 위빙하는 책임을 가지는 핵심 컴포넌트다. 다음에서 보듯이 많은 설명이 필요하지 않다는 
        것은 좋은 일이다.(지정할 수 있는 옵션은 더 있지만 자세한건 뒤에서 설명한다.)</para>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
http://www.springframework.org/schema/context 
    http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;

    <lineannotation>&lt;!-- 서비스 객체로 이 객체의 메서드를 프로파일링 할 것이다. --&gt;</lineannotation>
    &lt;bean id="entitlementCalculationService"
          class="foo.StubEntitlementCalculationService"/&gt;

    <lineannotation>&lt;!-- 로드타임 위빙을 킨다 --&gt;</lineannotation>
    <emphasis role="bold">&lt;context:load-time-weaver/&gt;</emphasis>

&lt;/beans&gt;</programlisting>

        <para>이제 필요한 것은 모두 준비되었다.(관점, 
        '<filename>META-INF/aop.xml</filename>' 파일, 스프링 설정) 동작할 때 LTW를 
        보여주기 위해 <methodname>main(..)</methodname> 메서드를 가진 간단한 
        드라이버 클래스를 생성하자.</para>

        <programlisting language="java">package foo;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Main {

    public static void main(String[] args) {

        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml", Main.class);

        EntitlementCalculationService entitlementCalculationService
            = (EntitlementCalculationService) ctx.getBean("entitlementCalculationService");

        <lineannotation>// 프로파일링 관점은 이 메서드 실행의 주변에서(around) '위빙된다'</lineannotation>
        entitlementCalculationService.calculateEntitlement();
    }
}</programlisting>

        <para>해야할 작업이 하나 남았다. 스프링에서 <classname>ClassLoader</classname>마다 
        선택적으로 LTW를 적용할 수 있다고 이 섹션의 도입부에서 얘기한 것은 사실이다. 하지만 이 
        예제에서는 LTW를 적용하는데 자바 에이전트(스프링이 제공하는)를 사용할 것이다. 다음은 위의 
        <classname>Main</classname> 클래스를 실행하기 위해 사용하는 커맨드라인 
        명령어이다.</para>

        <programlisting>java -javaagent:C:/projects/foo/lib/global/spring-instrument.jar foo.Main</programlisting>

        <para><ulink
        url="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/instrument/package-summary.html">
        JVM상에서 동작하는 프로그램을 위한 에이전트</ulink>를 지정하고 활성화하는 
        '<literal>-javaagent</literal>'는 Java 5+의 플래그이다. 스프링 프레임워크는 위의 
        예제에서 <literal>-javaagent</literal> 아규먼트와 같은 역할로써 제공하는 
        <classname>InstrumentationSavingAgent</classname>같은 에이전트를 
        <filename class="libraryfile">spring-instrument.jar</filename>에 
        팩키징해서 제공하고 있다.</para>

        <para><classname>Main</classname> 프로그램을 실행하면 다음과 같이 출력된다. 
        (<methodname>calculateEntitlement()</methodname> 구현부에 
        <methodname>Thread.sleep(..)</methodname>문을 추가했으므로 프로파일러가 
        0 밀리초 외의 것을 실제로 잡아낸다. <literal>01234</literal> 밀리초는 AOP로 
        인한 오버헤드가 <emphasis>아니다</emphasis>. :))</para>

        <programlisting>Calculating entitlement

StopWatch 'ProfilingAspect': running time (millis) = 1234
------ ----- ----------------------------
ms     %     Task name
------ ----- ----------------------------
01234  100%  calculateEntitlement</programlisting>

        <para>이 LTW가 완전한 AspectJ를 사용하기 때문에 스프링 빈을 어드바이징 하는데 제약이 
        없다. 약간 변형한 다음의 <classname>Main</classname> 프로그램은 같은 결과를 
        출력할 것이다.</para>

        <programlisting language="java">package foo;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Main {

    public static void main(String[] args) {

        new ClassPathXmlApplicationContext("beans.xml", Main.class);

        EntitlementCalculationService entitlementCalculationService =
            new StubEntitlementCalculationService();

        <lineannotation>// 프로파일링 관점은 이 메서드 실행의 주변에서(around) '위빙된다'</lineannotation>
        entitlementCalculationService.calculateEntitlement();
    }
}</programlisting>

        <para>위의 프로그램에서 얼마나 간단하게 스프링 컨테이너를 구성하고 스프링 컨텍스트와 완전히 
        분리된 <classname>StubEntitlementCalculationService</classname>의 새로운 
        인스턴스를 생성했는지 주목해라. 프로파일링 어드바이드는 여전히 위빙된다.</para>

        <para>확실히 이 예제는 극도로 단순하다... 하지만 스프링의 LTW 지원의 기본은 위 예제에서 
        모두 소개했고 이 섹션의 나머지 부분에서는 각 설정과 사용방법의 세부사항에 대한 
        '이유'를 살펴본다.</para>

        <note>
          <para>이 예제에서 사용한 <classname>ProfilingAspect</classname>는 기초적인 
          것이지만 아주 유용하다. 개발자가 개발하는데 사용할 수 있는 개발시간(development-time) 
          관점의 좋은 예제이고 UAT나 프로덕션에 배포하는 어플리케이션 빌드에서 아주 쉽게 
          제외시킬 수 있다.</para>
        </note>
      </section>

      <section id="aop-aj-ltw-the-aspects">
        <title>관점</title>

        <para>LTW에서 사용하는 관점은 AspectJ 관점이어야 한다. 이 관점은 AspectJ 언어로 
        작성할 수도 있고 @AspectJ 방식으로도 작성할 수 있다. @AspectJ 방식은 당연히 
        자바 5이상을 사용할 때만 사용할 수 있지만 이는 관점이 유효한 AspectJ
        <emphasis>이면서</emphasis> 스프링 AOP 관점이라는 의미이다. 게다가 컴파일된 관점 
        클래스는 클래스패스에서 사용할 수 있어야 한다.</para>
      </section>

      <section id="aop-aj-ltw-aop_dot_xml">
        <title>'<filename>META-INF/aop.xml</filename>'</title>

        <para>AspectJ LTW 인프라는 자바 클래스패스에 존재하는(파일을 바로 두거나 jar 파일안에 
        두는 것이 더 일반적이다) 하나 이상의 '<filename>META-INF/aop.xml</filename>' 
        파일을 사용해서 설정한다.</para>

        <para>이 파일의 구조와 내용은 메인 AspectJ 레퍼런스 문서에 자세히 나와있고 관심있다면 <ulink
        url="http://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html">해당 
        문서를 참고해라</ulink>. (이 섹션이 간결하지만 '<filename>aop.xml</filename>' 
        파일이 100% AspectJ라는 점을 인정한다. 여기에 적용할 수 있는 스프링에 한정된 정보나 
        시맨틱은 없으므로 여기서 제공할 수 있는 추가적인 가치는 없다. 그래서 AspectJ 개발자들이 
        작성한 충분히 만족스런 섹견을 다시 만들기 보다는 해당 문서를 참고하도록 하고 있다.)</para>
      </section>

      <section id="aop-aj-ltw-libraries">
        <title>필수 라이브러리 (JARS)</title>

        <para>스프링 프레임워크의 AspectJ LTW 지원을 사용하려면 최소한 다음의 라이브러리들이 
        필요하다.</para>

        <orderedlist>
          <listitem>
            <para><filename class="libraryfile">spring-aop.jar</filename> (버전 2.5 
            이상과 필요한 모든 의존성 포함)</para>
          </listitem>

          <listitem>
            <para><filename class="libraryfile">aspectjweaver.jar</filename>
            (버전 1.6.8 이상)</para>
          </listitem>
        </orderedlist>

        <para><link linkend="aop-aj-ltw-environment-generic">인스트루멘테이션
        (instrumentation)을 활성화하는데 스프링이 제공하는 에이전트를</link> 사용하려면 
        다음 라이브러리도 필요하다.</para>

        <orderedlist>
          <listitem>
            <para><filename
            class="libraryfile">spring-instrument.jar</filename></para>
          </listitem>
        </orderedlist>
      </section>

      <section id="aop-aj-ltw-spring">
        <title>스프링 설정</title>

        <para>스프링 LTW 지원에서 <interfacename>LoadTimeWeaver</interfacename> 
        인터페이스가 핵심 컴포넌트다. (<literal>org.springframework.instrument.classloading</literal> 
        패키지에 있다) 이 인터페이스와 인터페이스를 구현한 수많은 구현체는 스프링 배포판에 포함되어 있다. 
        <interfacename>LoadTimeWeaver</interfacename>는 런타임시에 
        <classname>ClassLoader</classname>에 하나 이상의 
        <classname>java.lang.instrument.ClassFileTransformers</classname> 추가에 
        대한 담당을 하고 해당 어플리케이션의 모든 방법을 가능하게 하는 것이 관점 LTW에서 
        이뤄지는 작업 중 하나이다.</para>

        <tip>
          <para>런타임 클래스 파일 변형의 개념에 익숙하지 않다면 계속 읽기 전에 
          <literal>java.lang.instrument</literal> 패키지에 대한 Javadoc API를 
          읽어보기를 권장한다. 이는 훌륭한 문서이므로 읽어보는 것이 아깝지 않다. 이번 섹션을 
          읽는내내 참조할 핵심 인터페이스와 클래스가 나와 있다.</para>
        </tip>

        <para>특정 <interfacename>ApplicationContext</interfacename>에서 XML을 
        사용해서 <interfacename>LoadTimeWeaver</interfacename>를 설정하는 것은 한 줄만 
        추가하면 될 정도로 쉽다. (확실히 스프링 컨테이너로 
        <interfacename>ApplicationContext</interfacename>를 사용해야 할 것이다. 
        일반적으로 <interfacename>BeanFactory</interfacename>는 LTW 지원이 
        <interfacename>BeanFactoryPostProcessors</interfacename>를 사용하기 
        때문에 충분치 않다.)</para>

        <para>스프링 프레임워크의 LTW 지원을 활성화하려면 
        <interfacename>LoadTimeWeaver</interfacename>를 설정해야 한다. 
        <interfacename>LoadTimeWeaver</interfacename>는 일반적으로 
        <literal>&lt;context:load-time-weaver/&gt;</literal> 요
        소를 사용해서 설정한다. 다음 예제에서 기본 설정을 사용하는 유효한 
        <literal>&lt;context:load-time-weaver/&gt;</literal> 정의를 
        볼 수 있다.</para>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;

    &lt;context:load-time-weaver/&gt;

&lt;/beans&gt;</programlisting>

        <para>위의 <literal>&lt;context:load-time-weaver/&gt;</literal> 정의는 
        <interfacename>LoadTimeWeaver</interfacename>와 
        <classname>AspectJWeavingEnabler</classname>같은 LTW에 특화된 기반(infrastructure) 
        빈을 다수 정의하고 등록한다. '<literal>context</literal>' 네임스페이스에서 어떻게 
        <literal>&lt;context:load-time-weaver/&gt;</literal>를 정의했는지 잘 봐라. 
        참조한 XML 스키마 파일은 스프링 2.5 이상의 버전에서만 사용할 수 있다는 것을 기억해라.</para>


        <para>위의 설정은 개발자를 위해서 기본 <interfacename>LoadTimeWeaver</interfacename> 
        빈을 정의하고 등록한다. 기존 <interfacename>LoadTimeWeaver</interfacename>는 
        자동으로 탐지된 <interfacename>LoadTimeWeaver</interfacename>를 데코레이트하는 
        <classname>DefaultContextLoadTimeWeaver</classname> 클래스이다. '자동으로 
        탐지되는' <interfacename>LoadTimeWeaver</interfacename>의 정확한 타입은 
        런타임환경에 의존한다.(다음 표에 요약되어 있다.)</para>

        <table id="aop-aj-ltw-spring-env-impls" pgwide="1">
          <title><classname>DefaultContextLoadTimeWeaver</classname>
          <interfacename>LoadTimeWeavers</interfacename></title>

          <tgroup cols="2">
            <colspec align="left" />

            <thead>
              <row>
                <entry>런타임 환경</entry>
                <entry><interfacename>LoadTimeWeaver</interfacename> 구현체</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><para><ulink
                url="http://www.bea.com/framework.jsp?CNT=index.htm&amp;FP=/content/products/weblogic/server">BEA의 
                웹로직 10</ulink>에서 동작</para></entry>
                <entry><para><classname>WebLogicLoadTimeWeaver</classname></para></entry>
              </row>

              <row>
                <entry><para><ulink
                url="http://www-01.ibm.com/software/webservers/appserv/was/">IBM 웹스피어 어플리케이션 서버 7</ulink>에서 동작</para></entry>
                <entry><para><classname>WebSphereLoadTimeWeaver</classname></para></entry>
              </row>

              <row>
                <entry><para><ulink
                url="http://www.oracle.com/technology/products/oc4j/index.html">Oracle의 
                OC4J</ulink>에서 동작</para></entry>
                <entry><para><classname>OC4JLoadTimeWeaver</classname></para></entry>
              </row>

              <row>
                <entry><para><ulink url="http://glassfish.dev.java.net/">글래스피쉬</ulink>에서 동작</para></entry>
                <entry><para><classname>GlassFishLoadTimeWeaver</classname></para></entry>
              </row>

              <row>
                <entry><para><ulink url="http://www.jboss.org/jbossas/">JBoss AS</ulink>에서 동작</para></entry>
                <entry><para><classname>JBossLoadTimeWeaver</classname></para></entry>
              </row>

              <row>
                <entry><para>스프링
                <classname>InstrumentationSavingAgent</classname>으로 시작된 JVM</para>
                <para><emphasis><literal>(java
                -javaagent:path/to/spring-instrument.jar)</literal></emphasis></para></entry>
                <entry><para><classname>InstrumentationLoadTimeWeaver</classname></para></entry>
              </row>

              <row>
                <entry><para>폴백(Fallback), 기반하는 클래스로더가 다음의 일반적인 관례를 따르기를 기대한다.
                (예시: <classname>TomcatInstrumentableClassLoader</classname>와 
                <ulink url="http://www.caucho.com/">Resin</ulink>에 적용할 수 있다)</para></entry>
                <entry><para><classname>ReflectiveLoadTimeWeaver</classname></para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>이 로드타임 위버들은 <classname>DefaultContextLoadTimeWeaver</classname>를 
        사용하는 경우 자동으로 탐지되는 <interfacename>LoadTimeWeavers</interfacename>이다. 
        물론 <literal>&lt;context:load-time-weaver/&gt;</literal> 요소의 
        '<literal>weaver-class</literal>' 속성값으로 정규화된 클래스이름을 지정함으로써 
        어떤 <interfacename>LoadTimeWeaver</interfacename> 구현체를 사용할 것인지를 
        정확히 지정하는 것도 가능하다. 다음 예제에서와 같이 지정한다.</para>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;

    &lt;context:load-time-weaver
            <emphasis role="bold">weaver-class="org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"</emphasis>/&gt;

&lt;/beans&gt;</programlisting>

        <para><literal>&lt;context:load-time-weaver/&gt;</literal> 요소로 정의하고 
        등록한 <interfacename>LoadTimeWeaver</interfacename>는 잘 알려진 
        '<literal>loadTimeWeaver</literal>'라는 이름을 사용해서 스프링 컨테이너에서 나중에 
        획득할 수 있다. <interfacename>LoadTimeWeaver</interfacename>는 마치 하나 이상의 
        <interfacename>ClassFileTransformers</interfacename>를 추가하는 스프링의 LTW 
        인프라스트럭처 메카니즘처럼 존재한다는 것을 기억해라. LTW를 하는 
        <classname>ClassFileTransformer</classname>는 
        <classname>ClassPreProcessorAgentAdapter</classname> 클래스
        (<literal>org.aspectj.weaver.loadtime</literal> 패키지에 있다)이다. 위빙이 
        실제로 어떻게 영향을 받는지에 대한 상세 내용은 이 섹션의 범위를 벗어나므로 더 자세한 내용은 
        <classname>ClassPreProcessorAgentAdapter</classname> 클래스에 대한 
        Javadoc의 클래스부분을 봐라.</para>

        <para>이제 얘기할 마지막 속성은 <literal>&lt;context:load-time-weaver/&gt;</literal>
        이다. 이 속성은 LTW를 활성화할 것인지 아닌지를 제어하는 간단한 속성이다. 이 속성은 아래에 
        정리해놓은 3가지 값을 지정할 수 있고 이 속성을 지정하지 않으면 기본값인 
        '<literal>autodetect</literal>'를 사용한다.</para>

        <table id="aop-aj-ltw-ltw-tag-attrs" pgwide="1">
          <title>'<literal>aspectj-weaving</literal>' 속성 값</title>

          <tgroup cols="2">
            <colspec align="left" />

            <thead>
              <row>
                <entry>속성 값</entry>
                <entry>설명</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><para><literal>on</literal></para></entry>
                <entry><para>AspectJ 위빙이 활성화되고 관점은 적절한 로드타임에
                위빙될 것이다.</para></entry>
              </row>

              <row>
                <entry><para><literal>off</literal></para></entry>
                <entry><para>LTW가 비활성화된다. 로드타임에 위빙되는 관점은 
                없다.</para></entry>
              </row>

              <row>
                <entry><para><literal>autodetect</literal></para></entry>
                <entry><para>스프링 LTW 인프라스트럭처가 최소 하나이상의 
                '<filename>META-INF/aop.xml</filename>' 파일을 발견하면 AspectJ 
                위빙이 활성화되고 발견하지 못하면 비활성화된다. 이 값이 
                기본값이다.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section id="aop-aj-ltw-environments">
        <title>Environment-specific configuration</title>

        <para>이 마지막 부분은 어플리케이션 서버와 웹 컨테이너 같은 환경에서 스프링의 LTW 지원을 
        사용하는 경우 필요한 추가적인 설정을 설명한다.</para>

        <section id="aop-aj-ltw-environment-tomcat">
          <title>톰캣</title>

      <para><ulink url="http://tomcat.apache.org/">아파치 톰캣</ulink>의 기본 클래스 로더는 클래스 
      변형(class transformation)을 지원하지 않기 때문에 스프링은 클래스 변형이 필요한 곳에 개선된 구현체를 
      제공한다. <classname>TomcatInstrumentableClassLoader</classname>라는 이름의 로더는 톰캣 5.0 
      이상에서 동작하고 다음과 같이 <emphasis>각</emphasis> 웹 어플리케이션마다 개별적으로 등록할 수 있다.</para>
		  
          <itemizedlist>
            <listitem>
              <para>톰캣 6.0.x이나 그 상위 버전</para>

            <orderedlist>
              <listitem>
                <para><literal>org.springframework.instrument.tomcat.jar</literal>를 
                <emphasis>$CATALINA_HOME</emphasis>/lib에 복사해라.
                (<emphasis>$CATALINA_HOME</emphasis>은 톰캣이 설치된 루트경로를 의미한다.)</para>
              </listitem>

              <listitem>
                <para>웹 어플리케이션 컨텍스트 파일을 수정해서 톰캣이 커스텀 클래스로더(기본 
                클래스로더 대신)를 사용하도록 한다.</para>

                <programlisting language="xml">&lt;Context path="/myWebApp" docBase="/my/webApp/location"&gt;
    &lt;Loader
        loaderClass="org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"/&gt;
&lt;/Context&gt;</programlisting>

                <para>아파치 톰캣 6.0.x (5.0.x/5.5.x와 비슷하다)는 다수의 컨텍스트 위치를 지원한다.</para>
					<itemizedlist>
						<listitem>서버 설정 파일 - <emphasis>$CATALINA_HOME/conf/server.xml</emphasis> </listitem> 
						<listitem>기본 컨텍스트 설정 - <emphasis>$CATALINA_HOME/conf/context.xml</emphasis> - 이 파일은 배포된 모든 웹 어플리케이션에 영향을 준다</listitem>
            <listitem>웹 어플리케이션 개별 설정은 서버측의 
            <emphasis>$CATALINA_HOME/conf/[enginename]/[hostname]/[webapp]-context.xml</emphasis>이나 
            웹어플리케이션 아카이브내에 포함된 <emphasis>META-INF/context.xml</emphasis>에 
            배포할 수 있다.</listitem>
					</itemizedlist>
                <para>효율성을 위헤서 각 웹어플리케이션에 내장된 설정방식을<!--Which one is inside the web-app config style? Reword. TR: REVISED, PLS REVIEW. Same change as for 5.0/5.5--> 추천한다. 
                그 이유는 이 방식이 커스텀 클래스 로더를 사용하는 어플리케이션에만 영항을 주고 서버 설정은 변경할 
                필요가 없기 때문이다. 사용할 수 있는 컨텍스트 위치에 대한 자세한 내용은 톰캣 6.0.x <ulink 
                url="http://tomcat.apache.org/tomcat-6.0-doc/config/context.html">문서</ulink>를 
                봐라.</para>
              </listitem>
            </orderedlist>
	        </listitem>
              
          <listitem>
              <para>톰캣 5.0.x/5.5.x</para>

            <orderedlist>
              <listitem>
                <para><literal>org.springframework.instrument.tomcat.jar</literal>를 
                <emphasis>$CATALINA_HOME</emphasis>/server/lib에 복사해라.
                (<emphasis>$CATALINA_HOME</emphasis>은 톰캣이 설치된 루트경로를 의미한다.)</para>
              </listitem>

              <listitem>
                <para>웹 어플리케이션 컨텍스트 파일을 수정해서 톰캣이 기본 클래스로더 대신 커스텀 
                클래스로더를 사용하도록 한다.</para>

                <programlisting language="xml">&lt;Context path="/myWebApp" docBase="/my/webApp/location"&gt;
    &lt;Loader
        loaderClass="org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"/&gt;
&lt;/Context&gt;</programlisting>

                <para>톰캣 5.0.x과 5.5.x은 다중 컨텍스트 위치를 지원한다.</para>
                	<itemizedlist>
						<listitem>서버 설정 파일 - <emphasis>$CATALINA_HOME/conf/server.xml</emphasis> </listitem>
						<listitem>기본 컨텍스트 설정 - <emphasis>$CATALINA_HOME/conf/context.xml</emphasis> - 이 
            파일은 배포된 모든 웹 어플리케이션에 영향을 준다.</listitem>
						<listitem>웹 어플리케이션 개별 설정은 서버측의 
            <emphasis>$CATALINA_HOME/conf/[enginename]/[hostname]/[webapp]-context.xml</emphasis>이나 
            웹어플리케이션 아카이브내에 포함된 <emphasis>META-INF/context.xml</emphasis>에 
            배포할 수 있다.</listitem>
					</itemizedlist>
                <para>효율성을 위해서 웹 어플리케이션에 내장된 설정 방식을<!--Which of the preceding is *inside the web-app config style*? Two paths contain webapp. 
TR: REVISED, PLS REVIEW. Chnaged the last one to *inside*--> 추천한다 그 이유는 
                이 방식은 클래스 로더를 사용하는 어플리케이션에만 영향을 주기 때문이다. 사용할 수 있는 컨텍스트 위치에 
                대한 자세한 내용은 톰캣 5.x <ulink
                url="http://tomcat.apache.org/tomcat-5.5-doc/config/context.html">문서</ulink>를 
                참고해라.</para>

                <para>톰캣 5.5.20 이전 버전에서는 클래스 로더를 지정하든지 공식 클래스 로더든 
                커스텀 클래스 로더든 상관없이 <emphasis>server.xml</emphasis> 설정내부에서 
                <literal>Loader</literal> 태그의 사용을 막는 XML 설정 버그가 있다. <ulink
                url="http://issues.apache.org/bugzilla/show_bug.cgi?id=39704">자세한 
                내용</ulink>은 톰캣의 버그질라를 참고해라.</para><!--Will reader know what Tomcat's bugzilla is and where to find it? TR: OK AS IS. They just need to click on the hyerlink.-->

                <para>톰캣 5.5.x의 5.5.20 이상버전에서는 이 문제를 해결하기 위해 
                <emphasis>useSystemClassLoaderAsParent</emphasis>를 
                <literal>false</literal>로 설정해야 한다.
                </para>
                <programlisting
                language="xml">&lt;Context path="/myWebApp" docBase="/my/webApp/location"&gt;
    &lt;Loader
        loaderClass="org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"
            <emphasis role="bold">useSystemClassLoaderAsParent="false"</emphasis>/&gt;
&lt;/Context&gt;</programlisting><para>이 설정은 톰캣 6 이상에서는 필요없다.</para>
              </listitem>
            </orderedlist>
            
            </listitem>
            
          </itemizedlist>

          <para>또 다른 방법으로는 톰캣의 실행스크립트(상단 참조)에서 지정된 스프링이 제공하는 
          제너릭 VM 에이전트의 사용을 고래햐 볼 수 있다. 이는 어떤 클래스로더에서 동작하는지 
          상관없이 배포된 모든 웹 어플리케이션에서 사용할 수 있다.</para>
        </section>

        <section id="aop-aj-ltw-environments-weblogic-oc4j-resin-glassfish-jboss">
          <title>WebLogic, WebSphere, OC4J, Resin, GlassFish, JBoss</title>

          <para>BEA 웹로직(버전 10 이상), IBM 웹스피어 어플리케이션 서버(버전 7 이상) Java EE에 
          대한 오라클 컨테이너(OC4J 10.1.3.1이상), 레진(3.1 이상), JBoss(5.x 이상)의 최신 
          버전들은 로컬 인스트루멘테이션의 기능을 가진 클래스로더를 제공한다. 앞에서 설명했듯이 
          <literal>context:load-time-weaver</literal>를 활성화해서 LTW를 사용할 수 있다. 
          특히 <literal>-javaagent:path/to/spring-instrument.jar</literal>를 추가하기 
          위해 실행스크립트를 수정할 필요가 <emphasis>없다</emphasis>.</para>

          <para>글래스피쉬의 인스투르멘테이션 기능을 가진 클래스로더는 글래스피쉬의 EAR 환경에서만 사용할 수 있다. 
          글래스피쉬 웹 어플리케이션에서는 위에서 설명한 톰캣의 설정 가이드를 따른다.</para>
          
          <para>JBoss 6.x에서는 어플리케이션이 실제로 시작되기 전에 클래스를 로딩하는 것을 막기 위해 어플리케이션 서버 
          스캐닝을 비활성화 해야 한다. 다음의 내용으로 
          <filename class="libraryfile">WEB-INF/jboss-scanning.xml</filename> 라는 파일을 
          어플리케이션에 추가해서 간단히 회피할 수 있다.</para>
          
          <programlisting language="xml">&lt;scanning xmlns="urn:jboss:scanning:1.0"/&gt;</programlisting>
          </section>
        
        <section id="aop-aj-ltw-environment-generic">
          <title>일반적인 자바 어플리케이션</title>

          <para>클래스 인스트루맨테이션을 지원하지 않는 환경에서 클래스 인스트루맨테이션이 필요하거나 존재하는 
          <classname>LoadTimeWeaver</classname> 구현체가 지원하지 않는 경우<!--OK? If you mean environments that are not supported by existing impl, revise as shown. If you mean class instrumentation is not supp--><!--orted, say *For environments that require class instrumentation that is not supported...*-->에는 
          JDK가 유일한 해결책이다. 이러한 경우에 스프링은 스프링에 한정된(하지만 아주 일반적인) VM 에이전트
          <classname>InstrumentationLoadTimeWeaver</classname>를 
          <filename class="libraryfile">org.springframework.instrument-{version}.jar</filename>에서 
          제공한다.(이전에는 <filename class="libraryfile">spring-agent.jar</filename>라는 이름이었다.)</para>
          
          <para>이를 사용하려면 반드시 다음의 JVM 옵션을 사용해서 스프링 에이전트로 가상머신을 
          시작해야 한다.</para>
          <programlisting>-javaagent:/path/to/org.springframework.instrument-{version}.jar</programlisting>
          
      <para>         
          어플리케이션 서버 환경이(운영정책에 달려있다) 스프링의 VM 에이전트를 사용하는 것을 막을 수도 있으므로 VM 실행스크립트를 
          수정해야할 필요가 있다. 게다가 JDK 에이전트는 비용이 많이 들 수 있는 <emphasis>전체</emphasis> VM을 사용할 
          것이다.</para>
          <para>성능때문에 사용하는 환경(<ulink url="http://www.eclipse.org/jetty/">Jetty</ulink>처럼)이 전용 LTW를 갖지 않은(또는 지원하지 않는) 경우에만 이 설정을 사용하기를 권한다.</para>
        </section>
        
      </section>
    </section>
  </section>

  <section id="aop-resources">
    <title>추가 자료</title>

    <para><ulink url="http://www.eclipse.org/aspectj">AspectJ 웹사이트
    </ulink>에서 AspectJ에 대한 더 자세한 내용을 볼 수 있다.</para>

    <para>Adrian Colyer et. al.이 쓴 <emphasis>Eclipse AspectJ</emphasis> 
    (Addison-Wesley, 2005)에 AspectJ 언어에 대한 광범위한 소개와 레퍼런스가 
    나와있다.</para>

    <para>Ramnivas Laddad가 쓴 <emphasis>AspectJ in Action</emphasis> 
    (Manning, 2003)를 강력히 추천한다. 이 책은 AspectJ에 초점을 맞추고 있지만 일반적인 
    AOP 주제들을 많이 다루고 있다.(꽤 상세하게)</para>
  </section>

</chapter>
