<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="cci">
  <title>JCA CCI</title>

  <section id="cci-introduction">
    <title>소개</title>

    <para>Java EE는 엔터프라이즈 인포메이션 시스템(EIS, Enterprise Information
    Systems)에 대한 표준화된 접근의 명세 JCA(J2EE Connector Architecture)를 제공한다.
    이 명세는 여러 부분으로 나누어져 있다.</para>

    <itemizedlist>
      <listitem>
        <para>커넥터 프로바이더인 SPI (Service provider interfaces)는 반드시 구현해야
        한다. 이러한 인터페이스는 Java EE 애플리케이션 서버에 배포할 수 있는 리소스 어댑터다. 이런
        시나리오에서 서버는 커넥션 풀, 트랜잭션, 보안(관리 모드)를 관리한다. 애플리케이션 서버는
        클라이언트 애플리케이션 외부에 있는 구성도 관리한다. 애플리케이션 서버 없이도 커넥터를
        사용할 수 있는데 이 경우에는 애플리케이션이 커넥터를 직접 구성해야 한다.(비관리 모드)</para>
      </listitem>

      <listitem>
        <para>애플리케이션이 사용할 수 있는 CCI (Common Client Interface) 는 커넥터와
        상호작용하므로 EIS로 통신한다. 로컬 트랜잭션 경계에 대한 API도 제공된다.</para>
      </listitem>
    </itemizedlist>

    <para>스프링 CCI 지원은 스프링 프레임워크의 일반적인 리소스 관리와 트랜잭션 관리 기능을
    사용하면서 일반적인 스프링 방식으로 CCI 커넥터에 접근하는 클래스를 제공한다. </para>

    <note>
      <para>커넥터의 클라이언트 측이 항상 CCI를 사용하는 것은 아니다. 어떤 커넥터는 자신만의
      API를 가지고 Java EE 컨테이너의 시스템 규약(커넥션 풀링, 전역 트랜잭션, 보안)을 사용하는
      JCA 리소스 어댑터만 제공하기도 한다. 이렇게 커넥터에 특화된 API를 스프링이 따로
      지원하진 않는다.</para>
    </note>
  </section>

  <section id="cci-config">
    <title>CCI 구성</title>

    <section id="cci-config-connector">
      <title>커넥터 구성</title>

      <para>JCA CCI를 사용하는 기반은
      <interfacename>ConnectionFactory</interfacename> 인터페이스다. 사용하는 커넥터는
      반드시 이 인터페이스의 구현체를 제공해야 한다.</para>

      <para>커넥터를 사용하려면 애플리케이션 서버에 커넥터를 배포하고 서버의 JNDI 환경에서
      <interfacename>ConnectionFactory</interfacename>를 가져올 수 있어야 한다.(관리
      모드) 커넥터를 RAR 파일(resource adapter archive)로 패키징해야 하고 배포와 관련된
      정보를 담고 있는 <filename>ra.xml</filename>이 포함되어 있어야 한다. 리소스의 실제
      이름은 배포할 때 지정한다. 스프링 내에서 커넥터에 접근하려면 JNDI 이름으로 팩토리를 가져오는
      스프링의 <classname>JndiObjectFactoryBean</classname> /
      <literal>&lt;jee:jndi-lookup&gt;</literal>를 사용하면 된다.</para>

      <para>어플리케이션서버를 사용해서 배포하고 구성하는 대신 애플리케이션에 커넥터를 내장시키는
      것도 커넥터를 사용하는 또 하나의 방법이다.(비관리 모드) 스프링에서는 제공된
      <literal>FactoryBean</literal>으로 커넥터를 빈으로 구성할 수 있다. 이 방법을 사용할
      때는 클래스패스에 커넥터 라이브러리만 넣으면 된다.(RAR 파일이나
      <filename>ra.xml</filename> 디스크립터가 필요 없다.) 필요하다만 커넥터의 RAR 파일에서
      라이브러리만 추출해야 한다.</para>

      <para>일단 <interfacename>ConnectionFactory</interfacename> 인스턴스에 접근하고
      나면 컴포넌트에 주입할 수 있다. 이러한 컴포넌트는 평범한 CCI API를 기반으로 작성하거나
      스프링의 CCI 접근 지원 클래스(<classname>CciTemplate</classname> 같은)를
      기반으로 작성할 수 있다.</para>

      <note>
        <para>비관리 모드에서 커넥터를 사용할 때는 현재 스레드의 현재 전역 트랜잭션에 리소스가
        절대 추가되거나 빠지지 않으므로 전역 트랜잭션을 사용할 수 없다. 리소스는 어떤 전역
        Java EE 트랜잭션도 인지하지 못한다.</para>
      </note>
    </section>

    <section id="cci-config-connectionfactory">
      <title>스프링에서 <interfacename>ConnectionFactory</interfacename>의
      구성</title>

      <para>EIS에 연결하려고 할 때 관리 모드인 경우에는 애플리케이션 서버에서
      <interfacename>ConnectionFactory</interfacename>를 얻어야 하고 비관리 모드인
      경우에는 스프링에서 직접 <interfacename>ConnectionFactory</interfacename>를
      가져와야 한다.</para>

      <para>관리 모드에서는 JNDI에서
      <interfacename>ConnectionFactory</interfacename>에 접근한다.
      <interfacename>ConnectionFactory</interfacename>의 프로퍼티는 애플리케이션
      서버에서 설정할 것이다.</para>

      <programlisting language="xml">&lt;jee:jndi-lookup id="eciConnectionFactory" jndi-name="eis/cicseci"/&gt;</programlisting>

      <para>비관리 모드에서는 스프링 설정에서 사용할
      <interfacename>ConnectionFactory</interfacename>를 JavaBean으로 설정해야 한다.
      <classname>LocalConnectionFactoryBean</classname> 클래스가 커넥터의
      <classname>ManagedConnectionFactory</classname> 구현체를 전달하고 애플리케이션
      수준의 CCI <interfacename>ConnectionFactory</interfacename>를 노출시켜서
      이러한 설정 방법을 제공한다.</para>

      <programlisting language="xml">&lt;bean id="eciManagedConnectionFactory" class="com.ibm.connector2.cics.ECIManagedConnectionFactory"&gt;
  &lt;property name="serverName" value="TXSERIES"/&gt;
  &lt;property name="connectionURL" value="tcp://localhost/"/&gt;
  &lt;property name="portNumber" value="2006"/&gt;
&lt;/bean&gt;

&lt;bean id="eciConnectionFactory" class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
  &lt;property name="managedConnectionFactory" ref="eciManagedConnectionFactory"/&gt;
&lt;/bean&gt;</programlisting>

      <note>
        <para>특정 <interfacename>ConnectionFactory</interfacename>를 직접
        인스턴스화 할 수는 없다. 커넥터에 대한
        <classname>ManagedConnectionFactory</classname> 인터페이스의 대응되는 구현체를
        통해야 한다. 이 인터페이스는 JCA SPI 명세에 포함된 내용이다.</para>
      </note>
    </section>

    <section id="cci-config-cci-connections">
      <title>CCI 연결 구성</title>

      <para>개발자는 JCA CCI를 사용해서 커넥터의
      <interfacename>ConnectionSpec</interfacename> 구현체를 사용해서 EIS에 대한 연결을
      구성할 수 있다. <interfacename>ConnectionSpec</interfacename>의 프로퍼티를
      설정하려면 전용 어댑터
      <classname>ConnectionSpecConnectionFactoryAdapter</classname>로 대상 커넥션
      팩토리를 감싸야 한다. 그래서 전용 <interfacename>ConnectionSpec</interfacename>를
      <literal>connectionSpec</literal> 프로퍼티(내부 빈으로)로 설정할 수 있다.</para>

      <para>CCI <interfacename>ConnectionFactory</interfacename> 인터페이스는 CCI
      연결을 얻는 두 가지 방법을 정의하고 있으므로 이 프로퍼티는 의무사항은 아니다.
      <interfacename>ConnectionSpec</interfacename> 프로퍼티 중 일부는 애플리케이션
      서버에서 설정하거나(관리모드에서) 대응되는 로컬
      <classname>ManagedConnectionFactory</classname> 구현체에서
      설정할 수 있다.</para>

      <programlisting language="java">public interface ConnectionFactory implements Serializable, Referenceable {
  ...
  Connection getConnection() throws ResourceException;
  Connection getConnection(ConnectionSpec connectionSpec) throws ResourceException;
  ...
}</programlisting>

      <para>스프링은 해당 팩토리의 모든 동작을 사용할 수 있도록
      <interfacename>ConnectionSpec</interfacename> 인스턴스를 지정할 수 있는
      <classname>ConnectionSpecConnectionFactoryAdapter</classname>를 제공한다.
      이 어댑터의 <literal>connectionSpec</literal> 프로퍼티를 지정했다면 어댑터는 인자 없이
      <literal>getConnection</literal> 계열을 사용하고 지정하지 않았다면
      <interfacename>ConnectionSpec</interfacename> 인자와 함께 사용한다.</para>

      <programlisting language="xml">&lt;bean id="managedConnectionFactory"
    class="com.sun.connector.cciblackbox.CciLocalTxManagedConnectionFactory"&gt;
  &lt;property name="connectionURL" value="jdbc:hsqldb:hsql://localhost:9001"/&gt;
  &lt;property name="driverName" value="org.hsqldb.jdbcDriver"/&gt;
&lt;/bean&gt;

&lt;bean id="targetConnectionFactory"
    class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
  &lt;property name="managedConnectionFactory" ref="managedConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;bean id="connectionFactory"
    class="org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"&gt;
  &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt;
  &lt;property name="connectionSpec"&gt;
    &lt;bean class="com.sun.connector.cciblackbox.CciConnectionSpec"&gt;
      &lt;property name="user" value="sa"/&gt;
      &lt;property name="password" value=""/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>
    </section>

    <section id="cci-config-single-connection">
      <title>단일 CCI 연결의 사용</title>

      <para>단일 CCI 연결을 사용하고 싶은 경우를 위해서 스프링은
      <interfacename>ConnectionFactory</interfacename> 어댑터로 이를 관리할 수 있게
      한다. <classname>SingleConnectionFactory</classname> 어댑터 클래스가 단일 연결을
      지연해서 열고 애플리케이션 종료 시 해당 빈이 파괴될 때 연결을 닫는다. 이 클래스는 물리적 연결에
      기반을 둬서 같은 연결을 공유하면서 상황에 따라 적절하게 동작하는 전용
      <interfacename>Connection</interfacename> 프록시를 노출할 것이다.</para>

      <programlisting language="xml">&lt;bean id="eciManagedConnectionFactory"
    class="com.ibm.connector2.cics.ECIManagedConnectionFactory"&gt;
  &lt;property name="serverName" value="TEST"/&gt;
  &lt;property name="connectionURL" value="tcp://localhost/"/&gt;
  &lt;property name="portNumber" value="2006"/&gt;
&lt;/bean&gt;

&lt;bean id="targetEciConnectionFactory"
    class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
  &lt;property name="managedConnectionFactory" ref="eciManagedConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;bean id="eciConnectionFactory"
    class="org.springframework.jca.cci.connection.SingleConnectionFactory"&gt;
  &lt;property name="targetConnectionFactory" ref="targetEciConnectionFactory"/&gt;
&lt;/bean&gt;</programlisting>

      <note>
        <para>이 <interfacename>ConnectionFactory</interfacename> 어댑터는
        <interfacename>ConnectionSpec</interfacename>로 직접 설정할 수 없다. 특정
        <interfacename>ConnectionSpec</interfacename>에 대한 단일 커넥션이 필요한
        경우에는 <classname>SingleConnectionFactory</classname>와 통신하는
        <classname>ConnectionSpecConnectionFactoryAdapter</classname>로 중개해서
        사용해라.</para>
      </note>
    </section>
  </section>

  <section id="cci-using">
    <title>스프링의 CCI 접근에 대한 지원 사용하기</title>

    <section id="cci-record-creator">
      <title>레코드(Record) 변환</title>

      <para>JCA CCI 지원 중 하나는 CCI 레코드를 편리하게 조작할 수 있도록 하는 것이다. 개발자는
      스프링의 <classname>CciTemplate</classname>를 사용해서 레코드를 생성하고 레코드에서
      데이터를 추출하는 전략을 지정할 수 있다. 다음 인터페이스들은 애플리케이션에서 레코드를 직접
      다루길 원하지 않는 경우 입력과 출력 레코드를 사용하는 전략을 설정할 것이다.</para>

      <para>입력 <interfacename>Record</interfacename>를 생성하기 위해 개발자가
      <interfacename>RecordCreator</interfacename> 인터페이스의 전용 구현체를
      사용할 수 있다.</para>

      <programlisting language="java">public interface RecordCreator {

  Record createRecord(RecordFactory recordFactory) throws ResourceException, DataAccessException;
}</programlisting>

      <para>여기서 보듯이 <literal>createRecord(..)</literal> 메서드는 파라미터로
      <interfacename>RecordFactory</interfacename>를 받는다. 이 파라미터는 사용한
      <interfacename>ConnectionFactory</interfacename>의
      <interfacename>RecordFactory</interfacename>를 가리키는데
      <interfacename>IndexedRecord</interfacename>나
      <interfacename>MappedRecord</interfacename>를 생성하는 데 사용한다. 다음 예제는
      <interfacename>RecordCreator</interfacename> 인터페이스와 색인 되거나(indexed)
      매핑된(mapped) 레코드를 사용하는 방법을 보여준다.</para>

      <programlisting language="java">public class MyRecordCreator implements RecordCreator {

  public Record createRecord(RecordFactory recordFactory) throws ResourceException {
    IndexedRecord input = recordFactory.createIndexedRecord("input");
    input.add(new Integer(id));
    return input;
  }
}</programlisting>

      <para>EIS에서 다시 데이터를 받을 때 출력 <interfacename>Record</interfacename>를
      사용할 수도 있다. 그러므로 출력 <interfacename>Record</interfacename>의 데이터를
      추출하기 위해 <interfacename>RecordExtractor</interfacename> 인터페이스의 특정
      구현체를 스프링 <classname>CciTemplate</classname>에 전달할 수 있다.</para>

      <programlisting language="java">public interface RecordExtractor {

  Object extractData(Record record) throws ResourceException, SQLException, DataAccessException;
}</programlisting>

      <para>다음 예제는 <interfacename>RecordExtractor</interfacename> 인터페이스를
      사용하는 방법을 보여준다.</para>

      <programlisting language="java">public class MyRecordExtractor implements RecordExtractor {

  public Object extractData(Record record) throws ResourceException {
    CommAreaRecord commAreaRecord = (CommAreaRecord) record;
    String str = new String(commAreaRecord.toByteArray());
    String field1 = string.substring(0,6);
    String field2 = string.substring(6,1);
    return new OutputObject(Long.parseLong(field1), field2);
  }
}</programlisting>
    </section>

    <section id="cci-using-template">
      <title><classname>CciTemplate</classname></title>

      <para><classname>CciTemplate</classname>은 핵심 CCI 지원 패키지
      (<literal>org.springframework.jca.cci.core</literal>)의 중심이 되는 클래스다.
      <classname>CciTemplate</classname>는 리소스의 생성과 해제를 관리해서 CCI를 쉽게
      사용할 수 있도록 한다. 그리고 연결을 닫는 것을 잊어버리는 등의 일반적인 오류를 피할 수 있게
      해준다. <classname>CciTemplate</classname>는 연결과 상호작용(interaction) 객체의
      생명주기를 관리해서 애플리케이션 코드는 애플리케이션에서 입력 레코드를 생성하고 출력 레코드에서
      애플리케이션 데이터를 추출하는 데 집중하도록 한다.</para>

      <para>JCA CCI 명세는 EIS에서 작업을 호출하는 별개의 두 메서드를 정의하고 있다. CCI
      <interfacename>Interaction</interfacename> 인터페이스는
      두 가지 execute 메서드 시그니처를 제공한다.</para>

      <programlisting language="java">public interface javax.resource.cci.Interaction {
  ...
  boolean execute(InteractionSpec spec, Record input, Record output) throws ResourceException;

  Record execute(InteractionSpec spec, Record input) throws ResourceException;
  ...
}</programlisting>

      <para>호출된 템플릿 메서드에 따라 <classname>CciTemplate</classname>이 상호작용에
      어떤 <literal>execute</literal> 메서드를 호출할지 알 수 있다. 어떤 경우에든 제대로
      초기화된 <interfacename>InteractionSpec</interfacename> 인스턴스가
      필요하다.</para>

      <para><literal>CciTemplate.execute(..)</literal>는 두 가지로 사용할 수
      있다.</para>

      <itemizedlist>
        <listitem>
          <para>직접 <interfacename>Record</interfacename> 인자로 사용하는 방법.
          이 경우 CCI 입력 레코드를 전달해야 하고 반환된 객체는 CCI 출력 레코드에
          대응된다.</para>
        </listitem>

        <listitem>
          <para>레코드 매핑을 사용해서 애플리케이션 객체를 사용하는 방법. 이 경우에는 대응되는
          <interfacename>RecordCreator</interfacename>와
          <interfacename>RecordExtractor</interfacename> 인스턴스를 제공해야 한다.</para>
        </listitem>
      </itemizedlist>

      <para>첫번째 방법을 사용하면 템플릿의 다음 메서드를 사용할 것이다. 이 메서드들은
      <interfacename>Interaction</interfacename> 인터페이스의 메서드들과 직접
      대응된다.</para>

      <programlisting language="java">public class CciTemplate implements CciOperations {

  public Record execute(InteractionSpec spec, Record inputRecord)
      throws DataAccessException { ... }

  public void execute(InteractionSpec spec, Record inputRecord, Record outputRecord)
      throws DataAccessException { ... }

}</programlisting>

      <para>두번째 방법을 사용하면 인자로 레코드 생성 전략과 레코드 추출 전략을 지정해야 한다.
      레코드 변환에 사용하는 인터페이스는 이전 장에서 설명했다. 대응되는
      <classname>CciTemplate</classname> 메서드는 다음과 같다.</para>

      <programlisting language="java">public class CciTemplate implements CciOperations {

  public Record execute(InteractionSpec spec, RecordCreator inputCreator)
      throws DataAccessException { ... }

  public Object execute(InteractionSpec spec, Record inputRecord, RecordExtractor outputExtractor)
      throws DataAccessException { ... }

  public Object execute(InteractionSpec spec, RecordCreator creator, RecordExtractor extractor)
      throws DataAccessException { ... }

}</programlisting>

      <para>템플릿에 <literal>outputRecordCreator</literal> 프로퍼티를 설정하지
      않으면(다음 장 참고) 모든 메서드가 적절한 CCI
      <interfacename>Interaction</interfacename>의 <literal>execute</literal>
      메서드를 두 개의 파라미터 <interfacename>InteractionSpec</interfacename>와 입력
      <interfacename>Record</interfacename>로 호출할 것이고 이 메서드는 출력
      <interfacename>Record</interfacename>를 반환한다.</para>

      <para><classname>CciTemplate</classname>은
      <interfacename>RecordCreator</interfacename> 구현체 외부에서
      <literal>IndexRecord</literal>와 <literal>MappedRecord</literal>를 생성하는
      <literal>createIndexRecord(..)</literal>와
      <literal>createMappedRecord(..)</literal> 메서드도 제공한다. 해당
      <literal>CciTemplate.execute(..)</literal> 메서드에 전달할
      <interfacename>Record</interfacename> 인스턴스를 생성하기 위해서 DAO 구현체 내에서
      이 메서드를 사용할 수 있다.</para>

      <programlisting language="java">public class CciTemplate implements CciOperations {

  public IndexedRecord createIndexedRecord(String name) throws DataAccessException { ... }

  public MappedRecord createMappedRecord(String name) throws DataAccessException { ... }

}</programlisting>
    </section>

    <section id="cci-using-dao">
      <title>DAO 지원</title>

      <para>스프링의 CCI 지원은 DAO에 대한 추상 클래스를 제공하고
      <interfacename>ConnectionFactory</interfacename>나
      <classname>CciTemplate</classname> 인스턴스의 주입을 지원한다. 클래스 이름은
      <classname>CciDaoSupport</classname>이고
      <literal>setConnectionFactory</literal>와
      <literal>setCciTemplate</literal> 메서드를 제공한다. 내부적으로 이 클래스는
      하위클래스에서 데이터 접근 구현체를 구현할 수 있게 <classname>CciTemplate</classname>
      인스턴스를 노출하는 해당 <interfacename>ConnectionFactory</interfacename>를
      위해서 <classname>CciTemplate</classname> 인스턴스를 생성할 것이다.</para>

      <programlisting language="java">public abstract class CciDaoSupport {

  public void setConnectionFactory(ConnectionFactory connectionFactory) { ... }
  public ConnectionFactory getConnectionFactory() { ... }

  public void setCciTemplate(CciTemplate cciTemplate) { ... }
  public CciTemplate getCciTemplate() { ... }

}</programlisting>
    </section>

    <section id="automatic-output-generation">
      <title>출력 레코드 자동 생성</title>

      <para>사용한 커넥터가 입력 레코드와 출력 레코드를 파라미터로 받는
      <methodname>Interaction.execute(..)</methodname> 메서드(즉, 이 메서드는 적절한
      출력 레코드를 반환하지 않고 원하는 출력 레코드를 전달해야 한다.)만 지원한다면 응답을 받을 때
      JCA 커넥터가 작성하는 출력 레코드를 자동으로 생성할 수 있게
      <classname>CciTemplate</classname>의
      <literal>outputRecordCreator</literal> 프로퍼티를 설정할 수 있다. 그러면
      템플릿의 호출자에게 이 레코드를 반환할 것이다.</para>

      <para>위 목적에 맞게 이 프로퍼티에는 <interfacename>RecordCreator</interfacename>
      인터페이스의 구현체가 담겨 있다. <interfacename>RecordCreator</interfacename>
      인터페이스는 <xref linkend="cci-record-creator" />에서 이미 설명했다.
      <literal>outputRecordCreator</literal> 프로퍼티는
      <classname>CciTemplate</classname>에서 직접 지정해야 한다. 애플리케이션 코드에서는
      다음과 같이 작성한다.</para>

      <programlisting language="java">cciTemplate.setOutputRecordCreator(new EciOutputRecordCreator());</programlisting>

      <para>아니면 스프링 설정에서 전용 빈 인스턴스로 <classname>CciTemplate</classname>을
      설정한다.(추천하는 방법)</para>

      <programlisting language="xml">&lt;bean id="eciOutputRecordCreator" class="eci.EciOutputRecordCreator"/&gt;

&lt;bean id="cciTemplate" class="org.springframework.jca.cci.core.CciTemplate"&gt;
  &lt;property name="connectionFactory" ref="eciConnectionFactory"/&gt;
  &lt;property name="outputRecordCreator" ref="eciOutputRecordCreator"/&gt;
&lt;/bean&gt;</programlisting>

      <note>
        <para><classname>CciTemplate</classname> 클래스가 스레드 세이프 하므로 공유하는
        인스턴스로 설정하는 게 일반적이다.</para>
      </note>
    </section>

    <section id="template-summary">
      <title>요약</title>

      <para>다음 표는 <classname>CciTemplate</classname> 클래스의 메커니즘과 CCI
      <interfacename>Interaction</interfacename> 인터페이스에서 호출되는 해당 메서드를
      요약해서 보여주고 있다.<table frame="all" id="cci-interaction-execute-methods">
          <title><interfacename>Interaction</interfacename> execute 메서드의
          사용방법</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry align="center">CciTemplate 메서드 시그니처</entry>

                <entry align="center">CciTemplate outputRecordCreator
                프로퍼티</entry>

                <entry align="center">CCI Interaction에서 호출되는 execute
                메서드</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry align="center">Record execute(InteractionSpec,
                Record)</entry>

                <entry align="center">설정안함</entry>

                <entry align="center">Record execute(InteractionSpec,
                Record)</entry>
              </row>

              <row>
                <entry align="center">Record execute(InteractionSpec,
                Record)</entry>

                <entry align="center">설정함</entry>

                <entry align="center">boolean execute(InteractionSpec, Record,
                Record)</entry>
              </row>

              <row>
                <entry align="center">void execute(InteractionSpec, Record,
                Record)</entry>

                <entry align="center">설정안함</entry>

                <entry align="center">void execute(InteractionSpec, Record,
                Record)</entry>
              </row>

              <row>
                <entry align="center">void execute(InteractionSpec, Record,
                Record)</entry>

                <entry align="center">설정함</entry>

                <entry align="center">void execute(InteractionSpec, Record,
                Record)</entry>
              </row>

              <row>
                <entry align="center">Record execute(InteractionSpec,
                RecordCreator)</entry>

                <entry align="center">설정안함</entry>

                <entry align="center">Record execute(InteractionSpec,
                Record)</entry>
              </row>

              <row>
                <entry align="center">Record execute(InteractionSpec,
                RecordCreator)</entry>

                <entry align="center">설정함</entry>

                <entry align="center">void execute(InteractionSpec, Record,
                Record)</entry>
              </row>

              <row>
                <entry align="center">Record execute(InteractionSpec, Record,
                RecordExtractor)</entry>

                <entry align="center">설정안함</entry>

                <entry align="center">Record execute(InteractionSpec,
                Record)</entry>
              </row>

              <row>
                <entry align="center">Record execute(InteractionSpec, Record,
                RecordExtractor)</entry>

                <entry align="center">설정함</entry>

                <entry align="center">void execute(InteractionSpec, Record,
                Record)</entry>
              </row>

              <row>
                <entry align="center">Record execute(InteractionSpec,
                RecordCreator, RecordExtractor)</entry>

                <entry align="center">설정안함</entry>

                <entry align="center">Record execute(InteractionSpec,
                Record)</entry>
              </row>

              <row>
                <entry align="center">Record execute(InteractionSpec,
                RecordCreator, RecordExtractor)</entry>

                <entry align="center">설정함</entry>

                <entry align="center">void execute(InteractionSpec, Record,
                Record)</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section id="cci-straight">
      <title>CCI <interfacename>Connection</interfacename>와
      <interfacename>Interaction</interfacename>을 직접 사용하기</title>

      <para><classname>CciTemplate</classname>도
      <classname>JdbcTemplate</classname>나 <classname>JmsTemplate</classname>와
      같은 방식으로 직접 CCI 연결과 상호작용을 할 수 있게 지원한다. 이는 CCI 연결이나 상호작용에서
      여러 작업을 수행하고자 할 때 유용하다.</para>

      <para><interfacename>ConnectionCallback</interfacename> 인터페이스는 CCI
      <interfacename>Connection</interfacename>에서 임의의 작업을 할 수 있도록 인자로
      CCI <interfacename>Connection</interfacename>을 제공한다. 아니면
      <interfacename>Connection</interfacename>를 생성한 CCI
      <interfacename>ConnectionFactory</interfacename>을 제공할 수도 있다. 후자의
      경우는 관련 <interfacename>RecordFactory</interfacename> 인스턴스를 가져와서
      색인 된/매핑된 레코드를 생성할 때 유용하게 사용할 수 있다.</para>

      <programlisting language="java">public interface ConnectionCallback {

  Object doInConnection(Connection connection, ConnectionFactory connectionFactory)
      throws ResourceException, SQLException, DataAccessException;
}</programlisting>

      <para><interfacename>InteractionCallback</interfacename> 인터페이스는 CCI
      <interfacename>Interaction</interfacename>에서 임의의 작업을 할 수 있도록 CCI
      <interfacename>Interaction</interfacename>를 제공하고 대응되는 CCI
      <interfacename>ConnectionFactory</interfacename>를 제공할 수도 있다.</para>

      <programlisting language="java">public interface InteractionCallback {

  Object doInInteraction(Interaction interaction, ConnectionFactory connectionFactory)
      throws ResourceException, SQLException, DataAccessException;
}</programlisting>

      <note>
        <para><interfacename>InteractionSpec</interfacename> 객체는 여러 템플릿
        호출 간에 공유할 수도 있고 콜백 메서드마다 내부에서 새로 생성할 수도 있다.
        어떻게 되느냐는 오로지 DAO 구현체에 달려있다.</para>
      </note>
    </section>

    <section id="cci-template-example">
      <title><classname>CciTemplate</classname> 사용 예제</title>

      <para>이번 장의 <classname>CciTemplate</classname> 사용방법은 IBM CICS ECI
      커넥터를 사용해서 ECI 모드로 CICS에 접근하는 방법을 보여준다.</para>

      <para>우선 접근할 CICS 프로그램을 지정하고 CICS 프로그램과 상호작용하는 방법을 지정할 수
      있도록 CCI <interfacename>InteractionSpec</interfacename>의 초기화가
      이뤄져야 한다.</para>

      <programlisting language="java">ECIInteractionSpec interactionSpec = new ECIInteractionSpec();
interactionSpec.setFunctionName("MYPROG");
interactionSpec.setInteractionVerb(ECIInteractionSpec.SYNC_SEND_RECEIVE);</programlisting>

      <para>이 프로그램은 스프링의 템플릿을 사용해서 CCI를 사용할 수 있고 커스텀 객체와
      CCI <literal>Records</literal>간의 매핑을 지정할 수 있다.</para>

      <programlisting language="java">public class MyDaoImpl extends CciDaoSupport implements MyDao {

  public OutputObject getData(InputObject input) {
    ECIInteractionSpec interactionSpec = ...;

    OutputObject output = (ObjectOutput) getCciTemplate().execute(interactionSpec,
        new RecordCreator() {
          public Record createRecord(RecordFactory recordFactory) throws ResourceException {
            return new CommAreaRecord(input.toString().getBytes());
          }
        },
        new RecordExtractor() {
          public Object extractData(Record record) throws ResourceException {
            CommAreaRecord commAreaRecord = (CommAreaRecord)record;
            String str = new String(commAreaRecord.toByteArray());
            String field1 = string.substring(0,6);
            String field2 = string.substring(6,1);
            return new OutputObject(Long.parseLong(field1), field2);
          }
        });

    return output;
  }
}</programlisting>

      <para>앞에서 얘기했듯이 CCI 연결과 상호작용에서 직접 동작하도록 콜백을 사용할 수
      있다.</para>

      <programlisting language="java">public class MyDaoImpl extends CciDaoSupport implements MyDao {

  public OutputObject getData(InputObject input) {
    ObjectOutput output = (ObjectOutput) getCciTemplate().execute(
        new ConnectionCallback() {
          public Object doInConnection(Connection connection, ConnectionFactory factory)
              throws ResourceException {

            <lineannotation>// 여기서 작업을 수행한다...</lineannotation>
          }
        });
    }
    return output;
  }
}</programlisting>

      <note>
        <para><interfacename>ConnectionCallback</interfacename>에서 사용한
        <interfacename>Connection</interfacename>를 관리할 것이고
        <classname>CciTemplate</classname>가
        <interfacename>Connection</interfacename>를 닫을 것이지만 연결에서 생성한
        모든 상호작용을 콜백 구현체에서 관리해야 한다.</para>
      </note>

      <para>더 상세한 콜백이 필요하다면
      <interfacename>InteractionCallback</interfacename>를 구현할 수 있다. 이 경우
      전달한 <interfacename>Interaction</interfacename>를 관리할 것이고
      <classname>CciTemplate</classname>가
      <interfacename>Interaction</interfacename>를 닫을 것이다.</para>

      <programlisting language="java">public class MyDaoImpl extends CciDaoSupport implements MyDao {

  public String getData(String input) {
    ECIInteractionSpec interactionSpec = ...;

    String output = (String) getCciTemplate().execute(interactionSpec,
        new InteractionCallback() {
          public Object doInInteraction(Interaction interaction, ConnectionFactory factory)
              throws ResourceException {
            Record input = new CommAreaRecord(inputString.getBytes());
            Record output = new CommAreaRecord();
            interaction.execute(holder.getInteractionSpec(), input, output);
            return new String(output.toByteArray());
          }
        });

    return output;
  }
}</programlisting>

      <para>위 예제에 포함된 스프링 빈의 해당 설정은 비관리 모드에서는 다음과 같을 것이다.</para>

      <programlisting language="xml">&lt;bean id="managedConnectionFactory" class="com.ibm.connector2.cics.ECIManagedConnectionFactory"&gt;
  &lt;property name="serverName" value="TXSERIES"/&gt;
  &lt;property name="connectionURL" value="local:"/&gt;
  &lt;property name="userName" value="CICSUSER"/&gt;
  &lt;property name="password" value="CICS"/&gt;
&lt;/bean&gt;

&lt;bean id="connectionFactory" class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
  &lt;property name="managedConnectionFactory" ref="managedConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;bean id="component" class="mypackage.MyDaoImpl"&gt;
  &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</programlisting>

      <para>관리모드(즉, Java EE 환경)에서는 설정이 다음과 같을 것이다.</para>

      <programlisting language="xml">&lt;jee:jndi-lookup id="connectionFactory" jndi-name="eis/cicseci"/&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
  &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</programlisting>
    </section>
  </section>

  <section id="cci-object">
    <title>operation 객체로 CCI 접근 모델링하기</title>

    <para><literal>org.springframework.jca.cci.object</literal> 패키지에서는 다른
    방법으로 EIS에 접근할 수 있는 지원 클래스가 있다. 이는 스프링의 JDBC operation 객체(JDBC
    장을 봐라)와 유사한 재사용 가능한 operation 객체를 통해서 이뤄지고 보통 CCI API를 은닉화할
    것이다. 이는 애플리케이션 수준의 입력 객체를 operation 객체에 전달할 것이므로 입력 레코드를
    구성하고 받은 레코드 데이터를 애플리케이션 수준의 출력 객체로 변환해서 반환할 수 있다.</para>

    <para><emphasis>Note</emphasis>: 이 접근방법은 내부적으로
    <classname>CciTemplate</classname> 클래스와
    <interfacename>RecordCreator</interfacename> /
    <interfacename>RecordExtractor</interfacename> 인터페이스에 기반을 두고 있고
    스프링의 핵심 CCI 지원 기능을 재사용한다.</para>

    <section id="cci-object-mapping-record">
      <title><classname>MappingRecordOperation</classname></title>

      <para><classname>MappingRecordOperation</classname>는 본래
      <classname>CciTemplate</classname>와 같은 작업을 하지만 미리 구성한 특정 작업을
      객체로 나타낸다. <classname>MappingRecordOperation</classname>는 입력 객체를
      입력 레코드로 변환하는(레코드 매핑) 방법을 지정하는 두 가지 템플릿 메서드를 제공한다.</para>

      <itemizedlist>
        <listitem>
          <para>입력 객체를 입력 <interfacename>Record</interfacename>로 변환하는
          방법을 지정하는 <literal>createInputRecord(..)</literal></para>
        </listitem>

        <listitem>
          <para>출력 <interfacename>Record</interfacename>에서 출력 객체를
          추출하는 방법을 지정하는 <literal>extractOutputData(..)</literal></para>
        </listitem>
      </itemizedlist>

      <para>이 메서드들의 시그니처는 다음에 나와 있다.</para>

      <programlisting language="java">public abstract class MappingRecordOperation extends EisOperation {
  ...
  protected abstract Record createInputRecord(RecordFactory recordFactory, Object inputObject)
      throws ResourceException, DataAccessException { ... }

  protected abstract Object extractOutputData(Record outputRecord)
      throws ResourceException, SQLException, DataAccessException { ... }
  ...
}</programlisting>

      <para>EIS 작업을 실행하려면 단일 execute 메서드를 사용해야 하고 애플리케이션 수준의
      입력 객체를 전달해서 그 결과로 애플리케이션 수준의 출력 객체를 받는다.</para>

      <programlisting language="java">public abstract class MappingRecordOperation extends EisOperation {
  ...
  public Object execute(Object inputObject) throws DataAccessException {
  ...
}</programlisting>

      <para>여기서 보듯이 <classname>CciTemplate</classname> 클래스와는 반대로
      <methodname>execute(..)</methodname> 메서드는 인자로
      <interfacename>InteractionSpec</interfacename>를 갖지 않는다. 대신에
      <interfacename>InteractionSpec</interfacename>는 작업(operation)에 대해서
      전역적이다. 작업(operation) 객체를 특정
      <interfacename>InteractionSpec</interfacename>로 인스턴스화 하는데
      다음의 생성자를 반드시 사용해야 한다.</para>

      <programlisting language="java">InteractionSpec spec = ...;
MyMappingRecordOperation eisOperation = new MyMappingRecordOperation(getConnectionFactory(), spec);
...</programlisting>
    </section>

    <section id="cci-object-mapping-comm-area">
      <title><classname>MappingCommAreaOperation</classname></title>

      <para>일부 커넥터는 EIS에 전송할 파라미터와 EIS에서 반환받은 데이터를 담고 있는 바이트
      배열을 나타내는 COMMAREA에 기반을 둬서 레코드를 사용한다. 레코드 대신 COMMAREA와 직접
      동작하는 특수한 오퍼레이션 클래스를 스프링이 제공하고 있다.
      <classname>MappingCommAreaOperation</classname> 클래스는 COMMAREA 등을
      지원하기 위해 <classname>MappingRecordOperation</classname> 클래스를 상속받는다.
      <classname>MappingCommAreaOperation</classname>는 암묵적으로 입력과 출력 레코드로
      <classname>CommAreaRecord</classname> 클래스를 사용하고 입력 객체를 입력
      COMMAREA로 변환하고 출력 COMMAREA를 출력 객체로 변환하는 새로운 두 메서드를
      제공한다.</para>

      <programlisting language="java">public abstract class MappingCommAreaOperation extends MappingRecordOperation {
  ...
  protected abstract byte[] objectToBytes(Object inObject)
      throws IOException, DataAccessException;

  protected abstract Object bytesToObject(byte[] bytes)
      throws IOException, DataAccessException;
  ...
}</programlisting>
    </section>

    <section id="cci-automatic-record-gen">
      <title>출력 레코드 자동 생성</title>

      <para>모든 <classname>MappingRecordOperation</classname> 하위클래스가 내부적으로
      CciTemplate에 기반을 두고 있으므로 <classname>CciTemplate</classname>와 같을 방법으로
      출력 레코드를 자동 생성할 수 있다. 각 작업 객체는 이에 대응되는
      <literal>setOutputRecordCreator(..)</literal> 메서드를 제공한다. 더 자세한 내용은
      <xref linkend="automatic-output-generation" />를 참고해라.</para>
    </section>

    <section id="cci-object-summary">
      <title>요약</title>

      <para>작업(operation) 객체 접근방법은 <classname>CciTemplate</classname>
      클래스와 같은 방법으로 레코드를 사용한다.</para>

      <table frame="all" id="cci-interaction-methods">
        <title>Interaction execute 메서드의 사용방법</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry
              align="center"><classname>MappingRecordOperation</classname>
              메서드 시그니처</entry>

              <entry
              align="center"><classname>MappingRecordOperation</classname>
              <literal>outputRecordCreator</literal> 프로퍼티</entry>

              <entry align="center">CCI
              <interfacename>Interaction</interfacename>에서 호출된
              execute 메서드</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry align="center">Object execute(Object)</entry>

              <entry align="center">설정 안함</entry>

              <entry align="center">Record execute(InteractionSpec,
              Record)</entry>
            </row>

            <row>
              <entry align="center">Object execute(Object)</entry>

              <entry align="center">설정함</entry>

              <entry align="center">boolean execute(InteractionSpec, Record,
              Record)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="cci-objects-mappring-record-example">
      <title><classname>MappingRecordOperation</classname> 사용방법의 예시</title>

      <para>이번 장에서는 블랙박스 CCI 커넥터로 데이터베이스에 접근하는
      <classname>MappingRecordOperation</classname>의 사용방법을 볼 것이다.</para>

      <note>
        <para>이 커넥터의 원래 버전은 (Sun의) Java EE SDK (버전 1.3)에서 제공한
        것이다.</para>
      </note>

      <para>우선, 어떤 SQL 요청을 처리할 것인지 정하기 위해 CCI
      <interfacename>InteractionSpec</interfacename>의 일부 초기화 작업이 완료되어야
      한다. 이 예제에서는 요청의 파라미터들을 CCI 레코드로 변환하는 방법과 CCI 결과 레코드를
      <classname>Person</classname> 클래스의 인스턴스로 변환하는 방법을 직접
      정의한다.</para>

      <programlisting language="java">public class PersonMappingOperation extends MappingRecordOperation {

  public PersonMappingOperation(ConnectionFactory connectionFactory) {
    setConnectionFactory(connectionFactory);
    CciInteractionSpec interactionSpec = new CciConnectionSpec();
    interactionSpec.setSql("select * from person where person_id=?");
    setInteractionSpec(interactionSpec);
  }

  protected Record createInputRecord(RecordFactory recordFactory, Object inputObject)
      throws ResourceException {
    Integer id = (Integer) inputObject;
    IndexedRecord input = recordFactory.createIndexedRecord("input");
    input.add(new Integer(id));
    return input;
  }

  protected Object extractOutputData(Record outputRecord)
      throws ResourceException, SQLException {
    ResultSet rs = (ResultSet) outputRecord;
    Person person = null;
    if (rs.next()) {
      Person person = new Person();
      person.setId(rs.getInt("person_id"));
      person.setLastName(rs.getString("person_last_name"));
      person.setFirstName(rs.getString("person_first_name"));
    }
    return person;
  }
}</programlisting>

      <para>그러면 애플리케이션이 인자로 person 식별자를 사용해서 작업 객체를 실행할 수 있다.
      이 작업객체는 스레드 세이프 하므로 공유 인스턴스로 설정할 수도 있다.</para>

      <programlisting language="java">public class MyDaoImpl extends CciDaoSupport implements MyDao {

  public Person getPerson(int id) {
    PersonMappingOperation query = new PersonMappingOperation(getConnectionFactory());
    Person person = (Person) query.execute(new Integer(id));
    return person;
  }
}</programlisting>

      <para>비관리 모드에서 이와 같은 스프링 빈 설정은 다음과 같을 것이다.</para>

      <programlisting language="xml">&lt;bean id="managedConnectionFactory"
    class="com.sun.connector.cciblackbox.CciLocalTxManagedConnectionFactory"&gt;
  &lt;property name="connectionURL" value="jdbc:hsqldb:hsql://localhost:9001"/&gt;
  &lt;property name="driverName" value="org.hsqldb.jdbcDriver"/&gt;
&lt;/bean&gt;

&lt;bean id="targetConnectionFactory"
    class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
  &lt;property name="managedConnectionFactory" ref="managedConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;bean id="connectionFactory"
    class="org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"&gt;
  &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt;
  &lt;property name="connectionSpec"&gt;
    &lt;bean class="com.sun.connector.cciblackbox.CciConnectionSpec"&gt;
      &lt;property name="user" value="sa"/&gt;
      &lt;property name="password" value=""/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
  &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</programlisting>

      <para>관리 모드에서는(즉, Java EE 환경) 설정이 다음과 같을 것이다.</para>

      <programlisting language="xml">&lt;jee:jndi-lookup id="targetConnectionFactory" jndi-name="eis/blackbox"/&gt;

&lt;bean id="connectionFactory"
    class="org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"&gt;
  &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt;
  &lt;property name="connectionSpec"&gt;
    &lt;bean class="com.sun.connector.cciblackbox.CciConnectionSpec"&gt;
      &lt;property name="user" value="sa"/&gt;
      &lt;property name="password" value=""/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
  &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</programlisting>
    </section>

    <section id="cci-objects-mapping-comm-area-example">
      <title><classname>MappingCommAreaOperation</classname> 사용방법의 예시</title>

      <para>이번 장에서는 <classname>MappingCommAreaOperation</classname>을 사용해서
      IBM CICS ECI 커넥터로 ECI 모드에서 CICS에 접근하는 방법을 볼 것이다.</para>

      <para>먼저 어떤 CICS 프로그램에 접근하고 어떻게 상호작용할 것인지 지정하기 위해
      CCI <interfacename>InteractionSpec</interfacename>을 초기화 해야 한다.</para>

      <programlisting language="java">public abstract class EciMappingOperation extends MappingCommAreaOperation {

  public EciMappingOperation(ConnectionFactory connectionFactory, String programName) {
    setConnectionFactory(connectionFactory);
    ECIInteractionSpec interactionSpec = new ECIInteractionSpec(),
    interactionSpec.setFunctionName(programName);
    interactionSpec.setInteractionVerb(ECIInteractionSpec.SYNC_SEND_RECEIVE);
    interactionSpec.setCommareaLength(30);
    setInteractionSpec(interactionSpec);
    setOutputRecordCreator(new EciOutputRecordCreator());
  }

  private static class EciOutputRecordCreator implements RecordCreator {
    public Record createRecord(RecordFactory recordFactory) throws ResourceException {
      return new CommAreaRecord();
    }
  }
}</programlisting>

      <para>초기화하고 나면 커스텀 객체와 <literal>Records</literal>의 매핑을 위해
      추상 <classname>EciMappingOperation</classname> 클래스가 하위 클래스가
      될 수 있다.</para>

      <programlisting language="java">public class MyDaoImpl extends CciDaoSupport implements MyDao {

  public OutputObject getData(Integer id) {
    EciMappingOperation query = new EciMappingOperation(getConnectionFactory(), "MYPROG") {
      protected abstract byte[] objectToBytes(Object inObject) throws IOException {
        Integer id = (Integer) inObject;
        return String.valueOf(id);
      }
      protected abstract Object bytesToObject(byte[] bytes) throws IOException;
        String str = new String(bytes);
        String field1 = str.substring(0,6);
        String field2 = str.substring(6,1);
        String field3 = str.substring(7,1);
        return new OutputObject(field1, field2, field3);
      }
    });

    return (OutputObject) query.execute(new Integer(id));
  }
}</programlisting>

      <para>비관리 모드에서 스프링 빈을 사용한 설정은 다음과 같을 것이다.</para>

      <programlisting language="xml">&lt;bean id="managedConnectionFactory" class="com.ibm.connector2.cics.ECIManagedConnectionFactory"&gt;
  &lt;property name="serverName" value="TXSERIES"/&gt;
  &lt;property name="connectionURL" value="local:"/&gt;
  &lt;property name="userName" value="CICSUSER"/&gt;
  &lt;property name="password" value="CICS"/&gt;
&lt;/bean&gt;

&lt;bean id="connectionFactory" class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
  &lt;property name="managedConnectionFactory" ref="managedConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
  &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</programlisting>

      <para>관리모드에서는(즉, Java EE 환경) 설정이 다음과 같을 것이다.</para>

      <programlisting language="xml">&lt;jee:jndi-lookup id="connectionFactory" jndi-name="eis/cicseci"/&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
  &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</programlisting>
    </section>
  </section>

  <section id="cci-tx">
    <title>트랜잭션</title>

    <para>JCA는 리소스 어댑터의 트랜잭션을 여러 단계로 지원한다. 리소스 어댑터가 지원하는 트랜잭션
    종류는 리소스 어댑터의 <filename>ra.xml</filename> 파일에서 지정한다. 사실상 세 가지
    옵션이 있는데 none(예시: CICS EPI 커넥터), 지역(local) 트랜잭션(예시: CICS ECI 커넥터),
    전역(global) 트랜잭션(예시: IMS 커넥터)이다.</para>

    <programlisting language="xml">&lt;connector&gt;

  &lt;resourceadapter&gt;

    <lineannotation>&lt;!-- &lt;transaction-support&gt;NoTransaction&lt;/transaction-support&gt; --&gt;</lineannotation>
    <lineannotation>&lt;!-- &lt;transaction-support&gt;LocalTransaction&lt;/transaction-support&gt; --&gt;</lineannotation>
    &lt;transaction-support&gt;XATransaction&lt;/transaction-support&gt;

  &lt;resourceadapter&gt;

&lt;connector&gt;</programlisting>

    <para>전역 트랜잭션에서는 트랜잭션의 경계를 정하기 위해
    <classname>JtaTransactionManager</classname>를 백엔드로 사용해서(Java EE
    서버의 분산 트랜잭션 코디네이터에 위임해서) 스프링의 제너릭 트랜잭션을 사용할 수 있다.</para>

    <para>단일 CCI <interfacename>ConnectionFactory</interfacename>상의 지역
    트랜잭션에서는 JDBC의 <classname>DataSourceTransactionManager</classname>와
    유사하게 스프링이 CCI에 대한 구체적인 트랜잭션 관리 전략을 제공한다. CCI API는 지역 트랜잭션
    객체와 해당 지역 트랜잭션 경계 메서드를 정의한다. 스프링의
    <classname>CciLocalTransactionManager</classname>는 이러한 지역 CCI 트랜잭션을
    실행하고 이는 스프링의 제너릭
    <interfacename>PlatformTransactionManager</interfacename> 추상화와
    완전히 호환된다.</para>

    <programlisting language="xml">&lt;jee:jndi-lookup id="eciConnectionFactory" jndi-name="eis/cicseci"/&gt;

&lt;bean id="eciTransactionManager"
    class="org.springframework.jca.cci.connection.CciLocalTransactionManager"&gt;
  &lt;property name="connectionFactory" ref="eciConnectionFactory"/&gt;
&lt;/bean&gt;</programlisting>

    <para>두 트랜잭션 전략 모두 스프링의 어떤 트랜잭션 경계 기능(선언적이거나 프로그래밍적인)과도
    사용할 수 있다. 이는 실제 실행 전략과 트랜잭션 경계를 디커플링한 스프링의 제너릭
    <interfacename>PlatformTransactionManager</interfacename> 추상화 덕이다.
    그래서 트랜잭션 경계는 그대로 둔 채 <classname>JtaTransactionManager</classname>와
    <classname>CciLocalTransactionManager</classname>를 필요한대로 바꿔
    쓸 수 있다.</para>

    <para>스프링의 트랜잭션 기능에 대한 자세한 내용은 <xref linkend="transaction" />장을
    참고해라.</para>
  </section>
</chapter>
