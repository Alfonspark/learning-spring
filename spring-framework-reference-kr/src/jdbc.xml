<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="jdbc">
  <title>JDBC를 사용한 데이터 접근</title>

  <section id="jdbc-introduction">
    <title>스프링 프레임워크 JDBC 소개</title>

    <para>스프링 프레임워크의 JDBC 추상화가 제공하는 가치는 다음 표에 나온 나와있는 일련의 동작에
    가장 잘 나와있다고 할 수 있다. 다음 표는 스프링이 어떤 동작을 처리하고 어플리케이션은
    어떤 동작에 책임을 지는지 보여준다.<!--Is this sequence correct, as far as what developer does and doesn't do? Does it adhere to info in the rest of the chapter?
--><!--How does JDBC know what connection parameters are if a human does not at some point define them?--><!--TR: OK. I have rewritten this as a table indicating who has what responsibility. --></para>

    <table align="left" width="">
      <title>스프링 JDBC - 누가 무엇을 하는가?</title>

      <tgroup cols="3">
        <colspec colnum="1" colwidth="350" />

        <colspec colnum="2" colwidth="40" />

        <colspec colnum="3" colwidth="40" />

        <thead>
          <row>
            <entry align="center">동작</entry>

            <entry align="center">스프링</entry>

            <entry align="center">어플리케이션 개발자</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>연결 파라미터 정의.</entry>

            <entry align="center"><emphasis role="bold"></emphasis></entry>

            <entry align="center">X</entry>
          </row>

          <row>
            <entry>연결 오픈.</entry>

            <entry align="center">X</entry>

            <entry align="center"></entry>
          </row>

          <row>
            <entry>SQL 문 지정.</entry>

            <entry align="center"></entry>

            <entry align="center">X</entry>
          </row>

          <row>
            <entry>파라미터 선언과 파라미터 값 제공</entry>

            <entry align="center"></entry>

            <entry align="center">X</entry>
          </row>

          <row>
            <entry>스테이트먼트(statement) 준비와 실행.</entry>

            <entry align="center">X</entry>

            <entry align="center"></entry>
          </row>

          <row>
            <entry>(존재한다면)결과를 반복하는 루프 설정</entry>

            <entry align="center">X</entry>

            <entry align="center"></entry>
          </row>

          <row>
            <entry>각 이터레이션에 대한 작업 수행.</entry>

            <entry align="center"></entry>

            <entry align="center">X</entry>
          </row>

          <row>
            <entry>모든 예외 처리.</entry>

            <entry align="center">X</entry>

            <entry align="center"></entry>
          </row>

          <row>
            <entry>트랜잭션 제어.</entry>

            <entry align="center">X</entry>

            <entry align="center"></entry>
          </row>

          <row>
            <entry>연결, 스테이트먼트(statement), 리절트셋(resultset) 닫기.</entry>

            <entry align="center">X</entry>

            <entry align="center"></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>개발하기 지루한 JDBC의 API의 모든 저수준 세부사항을 스프링 프레임워크가
    처리한다.</para>

    <section id="jdbc-choose-style">
      <title>JDBC 데이터베이스 접근에 대한 접근법(approach) 선택하기</title>

      <para>JDBC 데이터베이스 접근의 기반을 이루는 여러가지 접근방법 중에서 선택할 수 있다.
      JdbcTemplate의 세가지 좋은 점에 추가적으로 새로운 SimpleJdbcInsert와 SimplejdbcCall
      접근은 데이터베이스 메타데이터를 최적화하고 RDBMS 객체 방식은 JDO 쿼리 디자인과 유사하게 더
      객체지향적인 접근방법을 취한다. 이러한 접근방법 중 하나를 사용해서 시작하고 나서도 다른 접근방법의
      기능을 포함시키기 위해서 섞을 수 있다. 모든 접근방법은 JDBC 2.0 호환 드라이버가 필요하고 몇가지
      고급 기능은 JDBC 3.0 드라이버를 필요로 한다.</para>

      <note>
        <para>스프링 3.0은 제너릭(generic)과 가변인자(varargs)같은 Java 5의 지원으로
        다음의 모든 접근을 업데이트했다.<!--Is there a formal name for varargs? Is this written correctly?I've inserted this note to avoid redundancy below.--></para>
      </note>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">JdbcTemplate</emphasis>은 전형적인 스프링 JDBC
          접근방법이고 가장 인기가 좋다. 이 "최저수준"의 접근방법과 다른 접근방법들은 보이지 않게
          JdbcTemplate를 사용하고 모든 접근방법은 제너릭과 가변인자같은 Java 5의 지원으로
          업데이트되었다.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">NamedParameterJdbcTemplate</emphasis>는
          전통적인 JDBC의 "?" 플레이스홀더 대신에 이름있는(named) 파라미터를 제공하기 위해서
          <code>JdbcTemplate</code>를 감싼다. 이 접근방법은 더 좋은 문서화를 제공하고
          SQL 문에 다중 파라미터가 있을 때 사용하기가 쉽다.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">SimpleJdbcTemplate</emphasis>에는
          JdbcTemplate와 NamedParameterJdbcTemplate에서 가장 빈번하게
          사용하는 작업을 합쳐놨다.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">SimpleJdbcInsert와
          SimpleJdbcCall</emphasis>는 필요한 설정의 양을 제한하려고 데이터베이스의 메타데이터를
          최적화한다. 이 접근방법은 코딩을 간소화해서 테이블이나 프로시저의 이름을 제공하고 컬럼명과
          일치하는 파라미터들의 맵을 제공하기만 하면 된다. <!--Revise preceding to clarify: You *must* use this approach w/ SimpleJdbcTemplate, it is *recommended*, or you *can*?
TR: OK. I removed the sentence since it isn;t entirely accurate. The implementation uses a plain JdbcTemplate internally.-->
          이는 데이터베이스가 충분한 메타데이터를 제공할 때만 동작한다. 데이터베이스가 이러한
          메타데이터를 제공하지 않는다면 파라미터의 명시적인 설정을 제공해야 할 것이다.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">MappingSqlQuery, SqlUpdate,
          StoredProcedure</emphasis>를 포함하는 RDBMS 객체들은 데이터 접근 계층을 초기화하는
          동안 재사용가능하고 쓰레드세이프한 객체의 생성을 필요로 한다. 이 접근방법은 쿼리스프링을
          정의하고, 파라미터를 선언하고 쿼리를 컴파일하는 JDO Query 이후에 만들어진다. 일단 만들고
          나면 실행 메서드는 전달하는 다양한 파라미터 값들로 여러번 호출할 수 있다.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="jdbc-packages">
      <title>패키지 계층<!--I have provided links to main sections that deal with most packages. TR: OK--></title>

      <para>스프링 프레임워크의 JDBC 추상화 프레임워크는 네가지 다른 패키지로 이뤄져 있다. 즉,
      <literal>core</literal>, <literal>datasource</literal>,
      <literal>object</literal>, <literal>support</literal> 이다.</para>

      <para><literal>org.springframework.jdbc.core</literal> 패키지는
      <classname>JdbcTemplate</classname> 클래스와 <classname>JdbcTemplate</classname>의
      다양한 콜백 인터페이스를 포함하고 있고 추가로 여러가지 관련 클래스를 포함하고 있다. 하위 패키지인
      <literal>org.springframework.jdbc.core.simple</literal>는
      <classname>SimpleJdbcTemplate</classname> 클래스, 관련된
      <classname>SimpleJdbcInsert</classname>, <classname>SimpleJdbcCall</classname>
      클래스를 포함하고 있다. 또다른 하위 패키지인
      <literal>org.springframework.jdbc.core.namedparam</literal>는
      <classname>NamedParameterJdbcTemplate</classname> 클래스, 관련된 지원 클래스들을
      포함하고 있다. <xref linkend="jdbc-core" />, <xref linkend="jdbc-advanced-jdbc" />,
      <xref linkend="jdbc-simple-jdbc" />를 참고해라.</para>

      <para><literal>org.springframework.jdbc.datasource</literal> 패키지는
      <interfacename>DataSource</interfacename> 접근을 쉽게 하는 유틸리티 클래스와 Java
      EE 컨테이너 외부의 수정되지 않고 운영되는 JDBC 코드와 테스트에 사용할 수 있는 여러가지 간단한
      <interfacename>DataSource</interfacename> 구현체를 포함하고 있다.
      <literal>org.springfamework.jdbc.datasource.embedded</literal> 하위패키지는
      HSQL나 H2같은 자바 데이터베이스 엔진을 사용해서 인-메모리 데이터베이스 인스턴스의 생성을 지원한다.
      <xref linkend="jdbc-connections" />와
      <xref linkend="jdbc-embedded-database-support" />를 참고해라.</para>

      <para><literal>org.springframework.jdbc.object</literal> 패키지는 RDBMS의
      조회, 갱신, 저장프로시저를 스레드세이프하고 재사용가능한 객체로 나타내는 클래스들을 포함하고
      있다. <xref linkend="jdbc-object" />를 참고해라. 이 접근은 데이터베이스의
      <quote>연결이 끊긴</quote> 쿼리가 반환하는 객체조차도 JDO로 만든다. 이 더 높은 수준의
      JDBC 추상화는 <literal>org.springframework.jdbc.core</literal> 패키지의
      저수준 추상화에 의존한다.</para>

      <para><!--Need x-ref for preceding and next sentences. TR: Revised, please review. Combined to single paragraph about exception translation.-->
      <literal>org.springframework.jdbc.support</literal> 패키지는
      <classname>SQLException</classname> 변환 기능과 약간의 유틸리티 클래스를 제공한다.
      JDBC 처리과정중에 던져진 예외는 <literal>org.springframework.dao</literal> 패키지에
      정의된 예외로 변환된다. 즉 스프링 JDBC 추상화 계층을 사용하는 코드는 JDBC나 RDBMS에 특화된
      오류처리를 구현할 필요가 없다. 변환된 모든 예외는 언체크드이고 이 예외는 복구할 수 있는 예외를
      잡거나 호출자에게 전파할 수 있다. <xref linkend="jdbc-SQLExceptionTranslator" />를
      참고해라.</para>
    </section>
  </section>

  <section id="jdbc-core">
    <title>기본적인 JDBC 처리와 오류 처리에 JDBC 핵심 클래스 사용하기<!--Note: I moved the *DataSource* subsection out of this section because it seems to belong more under *Controlling database connections.*--><!--This section here is about core classes, but datasource is a separate package from core. See *Package hierarchy* section above. TR: OK--></title>

    <section id="jdbc-JdbcTemplate">
      <title><classname>JdbcTemplate</classname></title>

      <para><classname>JdbcTemplate</classname> 클래스는 JDBC core 패키지에서 가장
      중요한 클래스이다. 이 클래스는 리소스의 생성과 해지를 처리해서 연결을 닫는 걸 까먹는 등의
      일반적인 오류를 피하도록 도와준다. 이 클래스는 스테이트먼트(statement)의 생성과 실행같은
      JDBC 핵심 작업흐름의 기본작언 작업을 수행해서 어플리케이션 코드가 SLQ을 제공하고 결과를
      받도록 한다. <classname>JdbcTemplate</classname> 클래스는 SQL 조회, 업데이트문,
      저장 프로시저 호출, <interfacename>ResultSet</interfacename>의 반복 수행, 반환된
      파라미터 값의 추출등을 실행한다.<!--The wording of the preceding sentence does not track. Which is correct: the class *executes* queries, *updated* statements, --><!--and stored procedure calls...OR the class *executes* queries and *updates* statements and stored procedure calls. Second part of--><!--sentence; is this clear? It *imitates* iteration and extraction? TR: Revised, please review. The class executes *SQL queries*,  *update statements* or *stored procedure calls* ...-->
      <classname>JdbcTemplate</classname> 클래스는 JDBC 예외를 잡아서
      <literal>org.springframework.dao</literal> 패키지에 정의되어 있는 일반적이고
      더 많은 정보를 가진 예외계층으로 변환한다.</para>

      <para>코드에서 <classname>JdbcTemplate</classname>를 사용할 때 필요한 작업은
      명확하게 정의된 계약에 따라 콜백 인터페이스를 구현하는 것 뿐이다.
      <interfacename>PreparedStatementCreator</interfacename> 콜백 인터페이스는
      <classname>JdbcTemplate</classname> 클래스가 제공하는
      <interfacename>Connection</interfacename>에 SQL과 필요한 파라미터를 제공해서 미리
      준비된 스테이트먼트를 생성한다. 호출가능한(callable) 스테이트먼트를 생성하는
      <interfacename>CallableStatementCreator</interfacename> 인터페이스도 마찬가지다.
      <interfacename>RowCallbackHandler</interfacename> 인터페이스는
      <interfacename>ResultSet</interfacename>의 각 열에서 값을 추출한다.</para>

      <!--and stored procedure calls? TR: they are handled by the CallableStatement; Queries and update statements are handled by PreparedStatement.-->

      <para><interfacename>DataSource</interfacename> 참조로 직접 인스턴스화 하거나 스프링
      IoC 컨테이너에서 설정하고 DAO를 빈 참조로 제공해서 DAO 구현체내에서
      <classname>JdbcTemplate</classname>를 사용할 수 있다. <note>
          <para><interfacename>DataSource</interfacename>는 언제나 스프링 IoC 컨테이너의
          빈으로 설정해야 한다. 첫번째 경우에 서비스에 빈을 직접 제공한다. 두번째 경우에는 미리
          준비된 템플릿에 빈을 제공한다.<!--I've revised so that it reads better, but please clarify second sentence: Specify what *the first case* is, what--><!--do you mean by *is given* and it's given to *which* service? First mention of a service. Specify what *second--><!-- case* is and what you mean by *is given*. TR: OK.--></para>
        </note></para>

       <para>이 클래스에서 생긴 모든 SQL은 템플릿 인스턴스의 정규화된 클래스명에 대응되는 범주에서
      <literal>DEBUG</literal> 레벨로 로깅된다. (일반적으로는
      <classname>JdbcTemplate</classname>이지만  <classname>JdbcTemplate</classname>
      클래스의 커스텀 하위클래스를 사용한다면 달라질 수 있다.)</para>

      <section id="jdbc-JdbcTemplate-examples">
        <title>JdbcTemplate 클래스의 사용방법 예제</title>

        <para>이번 섹션에서는 <classname>JdbcTemplate</classname> 클래스 사용방법의
        몇가지 예제를 보여준다. 이러한 예제들은 <classname>JdbcTemplate</classname>의
        모든 기능 목록을 모두 다루지는 않는다. <classname>JdbcTemplate</classname>의
        Javadoc을 참고해라.</para>

        <section id="jdbc-JdbcTemplate-examples-query">
          <title>조회 (SELECT)</title>

          <para>다음은 열의 수를 얻어내는 간단한 쿼리가 있다.</para>

          <programlisting language="java">int rowCount = this.jdbcTemplate.queryForInt("select count(*) from t_actor");</programlisting>

          <para>다음은 변수 바인딩을 사용한은 간단한 쿼리이다.</para>

          <programlisting language="java">int countOfActorsNamedJoe = this.jdbcTemplate.queryForInt(
        "select count(*) from t_actor where first_name = ?", "Joe");</programlisting>

          <para>다음은 <classname>String</classname>으로 조회하는 쿼리이다.</para>

          <programlisting language="java">String lastName = this.jdbcTemplate.queryForObject(
        "select last_name from t_actor where id = ?",
        new Object[]{1212L}, String.class);</programlisting>

          <para>다음은 조회해서 <emphasis>하나의</emphasis> 도메인 객체로 받는
          예제이다.</para>

          <programlisting language="java">Actor actor = this.jdbcTemplate.queryForObject(
        "select first_name, last_name from t_actor where id = ?",
        new Object[]{1212L},
        new RowMapper&lt;Actor&gt;() {
            public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {
                Actor actor = new Actor();
                actor.setFirstName(rs.getString("first_name"));
                actor.setLastName(rs.getString("last_name"));
                return actor;
            }
        });
</programlisting>

          <para>다음은 조회해서 다수의 도메인 객체로 받는 예제이다.</para>

          <programlisting language="java">List&lt;Actor&gt; actors = this.jdbcTemplate.query(
        "select first_name, last_name from t_actor",
        new RowMapper&lt;Actor&gt;() {
            public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {
                Actor actor = new Actor();
                actor.setFirstName(rs.getString("first_name"));
                actor.setLastName(rs.getString("last_name"));
                return actor;
            }
        });
</programlisting>

          <para>마지막 두 예제코드가 같은 어플리케이션에 존재한다면 두
          <interfacename>RowMapper</interfacename> 익명 내부 클래스의 중복을 제거하고
          필요에 따라 DAO 메서드로 참조할 수 있는 하나의 클래스(보통 <literal>static</literal>
          내부 클래스)로 추출하는 것이 더 바람직하다. 예를 들어 다음과 같이 마지막 예제코드를 작성하는
          것이 더 나을 것이다.</para>

          <programlisting language="java">public List&lt;Actor&gt; findAllActors() {
    return this.jdbcTemplate.query( "select first_name, last_name from t_actor", new ActorMapper());
}

private static final class ActorMapper implements RowMapper&lt;Actor&gt; {

    public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {
        Actor actor = new Actor();
        actor.setFirstName(rs.getString("first_name"));
        actor.setLastName(rs.getString("last_name"));
        return actor;
    }
}</programlisting>
        </section>

        <section id="jdbc-JdbcTemplate-examples-update">
          <title>jdbcTemplate로 수정하기 (INSERT/UPDATE/DELETE)<!--Provide introductory text as with other examples. TR: OK.--></title>

          <para>추가(insert), 갱신(update), 삭제(delete) 작업을 수행하는데
          <methodname>update(..)</methodname> 메서드를 사용한다. 보통 파라미터 값들은
          가변인자(var args)나 객체의 배열로 제공한다.</para>

          <programlisting language="java">this.jdbcTemplate.update(
        "insert into t_actor (first_name, last_name) values (?, ?)",
        "Leonor", "Watling");</programlisting>

          <programlisting language="java">this.jdbcTemplate.update(
        "update t_actor set = ? where id = ?",
        "Banjo", 5276L);</programlisting>

          <programlisting language="java">this.jdbcTemplate.update(
        "delete from actor where id = ?",
        Long.valueOf(actorId));</programlisting>
        </section>

        <section id="jdbc-JdbcTemplate-examples-other">
          <title>다른 jdbcTemplate 작업들</title>

          <para>임의의 SQL을 실행하는데 <methodname>execute(..)</methodname> 메서드를
          사용할 수 있고 이 메서드는 DDL문에 사용하기도 한다. <methodname>execute(..)</methodname>는
          콜백 인터페이스나 변수 배열의 바인딩 등을 받아들이게 되면 상당히 큰 부하가 생긴다.</para>

          <programlisting language="java">this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");</programlisting>

          <para>다음 예제는 간단힌 저장 프로시저를 호출한다. 좀 더 복잡한 저장 프로시저 지원은
          <link linkend="jdbc-StoredProcedure">뒷부분에서 다룬다</link>.</para>

          <programlisting language="java">this.jdbcTemplate.update(
        "call SUPPORT.REFRESH_ACTORS_SUMMARY(?)",
        Long.valueOf(unionId));</programlisting>
        </section>
      </section>

      <section id="jdbc-JdbcTemplate-idioms">
        <title><classname>JdbcTemplate</classname>의 좋은 사용사례</title>

        <para><classname>JdbcTemplate</classname> 클래스의 인스턴스는 <emphasis>설정되고
        나면 스레드세이프하다</emphasis>. 이는 <classname>JdbcTemplate</classname>의
        하나의 인스턴스를 설정하고 나서 안전하게 이 인스턴스의 <emphasis>공유된</emphasis> 참조를
        여러 DAO(또는 레파지토리)에 주입할 수 있다는 것을 의미하므로 매우 중요하다.
        <classname>JdbcTemplate</classname>는 상태를 가지고(stateful) 있지만(내부에
        <interfacename>DataSource</interfacename>에 대한 참조를 유지하고 있다) 이 상태는
        대화식(conversational)의 상태는 <emphasis>아니다</emphasis>.</para>

        <para><classname>JdbcTemplate</classname> 클래스(그리고 연관된 <link
        linkend="jdbc-SimpleJdbcTemplate"><classname>SimpleJdbcTemplate</classname></link>와
        <link linkend="jdbc-NamedParameterJdbcTemplate"><classname>NamedParameterJdbcTemplate
        </classname></link> 클래스들) 사용시의 일반적인 관행은 스프링 설정파일에서
        <interfacename>DataSource</interfacename>를 설정하고 공유된
        <interfacename>DataSource</interfacename> 빈을 DAO 클래스에 의존성 주입하는 것이다.
        <classname>JdbcTemplate</classname>는 <interfacename>DataSource</interfacename>에
        대한 setter로 생성된다. 이는 다음과 같이 DAO가 된다.</para>

        <programlisting language="java">public class JdbcCorporateEventDao implements CorporateEventDao {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        <emphasis role="bold">this.jdbcTemplate = new JdbcTemplate(dataSource);</emphasis>
    }

    <lineannotation>// <interfacename>CorporateEventDao</interfacename>의 메서드의 JDBC에 기반한 구현들이 이어진다...</lineannotation>
}</programlisting>

        <para>여기에 대응되는 설정은 다음과 같다.</para>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;

    &lt;bean id="corporateEventDao" class="com.example.JdbcCorporateEventDao"&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;

    &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
        &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
        &lt;property name="url" value="${jdbc.url}"/&gt;
        &lt;property name="username" value="${jdbc.username}"/&gt;
        &lt;property name="password" value="${jdbc.password}"/&gt;
    &lt;/bean&gt;

    &lt;context:property-placeholder location="jdbc.properties"/&gt;

&lt;/beans&gt;</programlisting>

        <para>명시적인 설정의 다른 대안은 의존성 주입에 컴포넌트 스캔과 어노테이션 지원을 사용하는 것이다.
        이 경우에 클래스에 <interfacename>@Repository</interfacename> 어노테이션(컴포넌트
        스캔의 후보가 되도록 한다)을 붙히고 <classname>DataSource</classname> setter 메서드에
        <interfacename>@Autowired</interfacename> 어노테이션을 붙힌다.<!--Re preceding sentence, I don't see @Autowired in next two examples. TR: OK AS IS. Made it *bold*--></para>

        <para><programlisting language="java"><emphasis role="bold">@Repository</emphasis>
public class JdbcCorporateEventDao implements CorporateEventDao {

    private JdbcTemplate jdbcTemplate;

    <emphasis role="bold">@Autowired</emphasis>
    public void setDataSource(DataSource dataSource) {
        <emphasis role="bold">this.jdbcTemplate = new JdbcTemplate(dataSource);</emphasis>
    }

    <lineannotation>// <interfacename>CorporateEventDao</interfacename>의 메서드의 JDBC에 기반한 구현들이 이어진다...</lineannotation>
}</programlisting></para>

        <para>여기에 대응되는 XML 설정파일은 <!--*corresponding* to what? TR: to the prvious code-snippet-->
        다음과 같을 것이다.</para>

        <para><programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;

    &lt;!-- Scans within the base package of the application for @Components to configure as beans --&gt;
    &lt;context:component-scan base-package="org.springframework.docs.test" /&gt;

    &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
        &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
        &lt;property name="url" value="${jdbc.url}"/&gt;
        &lt;property name="username" value="${jdbc.username}"/&gt;
        &lt;property name="password" value="${jdbc.password}"/&gt;
    &lt;/bean&gt;

    &lt;context:property-placeholder location="jdbc.properties"/&gt;

&lt;/beans&gt;</programlisting>스프링의 <classname>JdbcDaoSupport</classname> 클래스를
        사용하고 JDBC를 사용하는 여러 DAO 클래스들이 이 클래스를 확장한다면 하위클래스들은
        <classname>JdbcDaoSupport</classname> 클래스에서
        <methodname>setDataSource(..)</methodname> 메서드를 상속받는다. <!--Revise to clarify what you mean by inheriting method *for free*. For free as opposed to what? Also you don't inherit, don't your--><!--subclasses inherit? TR: Revised, please review.-->
        <classname>JdbcDaoSupport</classname> 클래스를 상속받을지 여부를 선택할 수 있다.
        <classname>JdbcDaoSupport</classname> 클래스는 단지 편리함을 위해서 제공될 뿐이다.</para>

        <para>앞의 템플릿 초기화 방식을 사용하는지(또는 사용하지 않든지) 여부에 상관없이 SQL을
        실행하려고 할 때마다 <classname>JdbcTemplate</classname>  클래스의 새로운 인스턴스를
        생성해야 하는 경우는 드물다. 일단 설정하고 나면 <classname>JdbcTemplate</classname>
        인스턴스는 스레드세이프하다. 어플리케이션이 여러가지 <interfacename>DataSources</interfacename>를
        필요로 하는 여러 데이터베이스에 접근하고 다르게 설정된 다수의
        <classname>JdbcTemplates</classname>에 접근한다면 여러가지
        <classname>JdbcTemplate</classname> 인스턴스를 필요로 할 것이다.</para>
      </section>
    </section>

    <section id="jdbc-NamedParameterJdbcTemplate">
      <title><classname>NamedParameterJdbcTemplate</classname></title>

      <para><classname>NamedParameterJdbcTemplate</classname> 클래스는 이름이 있는
      파라미터들을 사용해서 JDBC 문의 프로그래밍을 지원하고 이는 전형적인 플레이스홀더
      (<literal>'?'</literal>) 아규먼트만 사용하는 JBDC 문을 프로그래밍하는 방법과는 정반대가 된다.
      <classname>NamedParameterJdbcTemplate</classname> 클래스는
      <classname>JdbcTemplate</classname>를 감싸고 작업을 수행을 감싸진
      <classname>JdbcTemplate</classname>에 위임한다. 이번 섹션에서는
      <classname>NamedParameterJdbcTemplate</classname> 클래스가
      <classname>JdbcTemplate</classname>와는 다른 부분인 이름있는 파라미터를 사용해서 JDBC문을
      프로그래밍하는 부분만을 설명한다.</para>

      <programlisting language="java"><lineannotation>// some JDBC-backed DAO class...</lineannotation>
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActorsByFirstName(String firstName) {

    String sql = "select count(*) from T_ACTOR where first_name = :first_name";

    SqlParameterSource namedParameters = new MapSqlParameterSource("first_name", firstName);

    return namedParameterJdbcTemplate.queryForInt(sql, namedParameters);
}</programlisting>

      <para><literal>sql</literal> 변수에 값을 할당하는 이름있는 파라미터와
      <literal>namedParameters</literal>
      변수(<classname>MapSqlParameterSource</classname>타입의)에 끼워넣는 대응되는 값의
      사용방법을 유심히 봐라.</para>

      <para>다른 방법으로는 <interfacename>Map</interfacename>에 기반한 형식을 사용해서
      <classname>NamedParameterJdbcTemplate</classname> 인스턴스에 이름있는 파라미터와
      대응되는 값을 전달할 수 있다.<!--Revision ok? Clarify to say *Alternatively* you can pass along OR *In addition* you can pass along, to clarify whether you can do this--><!--instead of doing what sentence before it says to do, or in addition to doing it. This needs to be clear. TR: OK.-->
      <interfacename>NamedParameterJdbcOperations</interfacename>가 노출하고
      <classname>NamedParameterJdbcTemplate</classname> 클래스가 구현한 다른 메서드들은
      유사한 형식을 따르고 있으므로 여기서는 다루지 않는다.</para>

      <para>다음 예제는 <interfacename>Map</interfacename>기반
      방식의 사용방법을 보여준다.<!--Need an intro sentence to the following example. What does it show, what's its purpose? TR: OK.--></para>

      <programlisting language="java"><lineannotation>// JDBC를 사용하는 DAO 클래스...</lineannotation>
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActorsByFirstName(String firstName) {

    String sql = "select count(*) from T_ACTOR where first_name = :first_name";

    Map namedParameters = Collections.singletonMap("first_name", firstName);

    return this.namedParameterJdbcTemplate.queryForInt(sql, namedParameters);
}</programlisting>

      <para><classname>NamedParameterJdbcTemplate</classname>와 관련해서 한가지
      좋은 기능(그리고 같은 자바 패키지에 존재하는)은 <classname>SqlParameterSource</classname>
      인터페이스다. 앞의 코드 예제(<classname>MapSqlParameterSource</classname> 클래스)에서
      <classname>SqlParameterSource</classname> 인터페이스의 구현 예제를 이미 보았다. <!--Revision ok?Why say *another feature*? So far this is the only feature discussed for NamedParameterJDBC template. It's mentioned above.--><!--In next paragraph you do describe another implementation. --><!--TR: Revised, please review.-->
      <interfacename><classname>SqlParameterSource</classname></interfacename>는
      <classname>NamedParameterJdbcTemplate</classname>의 이름있는 파라미터값의 소스이다.
      <classname>MapSqlParameterSource</classname> 클래스는 키가 파라미터 이름이고 값이
      파라미터의 값인 <interfacename>java.util.Map</interfacename>의 아답터 역할을 하는
      아주 간단한 구현체이다. </para>

      <para>또다른 <interfacename>SqlParameterSource</interfacename> 구현체는
      <classname>BeanPropertySqlParameterSource</classname> 클래스이다. 이 클래스는
      임의의 JavaBean(즉, <ulink
      url="http://java.sun.com/products/javabeans/docs/spec.html">JavaBean의
      관례</ulink>를 충실하게 따르는 클래스의 인스턴스)을 감싸고 감싼 JavaBean의 프로퍼티들을 이름있는
      파라미터 값들의 소스로 사용한다.</para>

      <programlisting language="java">public class Actor {

    private Long id;
    private String firstName;
    private String lastName;

    public String getFirstName() {
        return this.firstName;
    }

    public String getLastName() {
        return this.lastName;
    }

    public Long getId() {
        return this.id;
    }

    <lineannotation>// setter는 생략했다...</lineannotation>

}</programlisting>

      <programlisting language="java"><lineannotation>// JDBC를 사용하는 DAO 클래스...</lineannotation>
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActors(Actor exampleActor) {

    <lineannotation>// 이름있는 파라미터들이 어떻게 위의 '<classname>Actor</classname>' 클래스의 프로퍼티에서 일치되는 것을 찾는지 주의깊게 봐라.</lineannotation>
    String sql =
        "select count(*) from T_ACTOR where first_name = :firstName and last_name = :lastName";

    SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(exampleActor);

    return this.namedParameterJdbcTemplate.queryForInt(sql, namedParameters);
}</programlisting>

      <para><classname>NamedParameterJdbcTemplate</classname> 클래스가 전통적인
      <classname>JdbcTemplate</classname> 템플릿을 <emphasis>감싼다는</emphasis>
      것을 기억해라. <classname>JdbcTemplate</classname> 클래스에만 존재하는 기능에 접근하기
      위해 감싸진 <classname>JdbcTemplate</classname> 인스턴스에 접근해야 한다면
      <interfacename>JdbcOperations</interfacename> 인터페이스를 통해 감싸진
      <classname>JdbcTemplate</classname>에 접근하기 위해
      <methodname>getJdbcOperations()</methodname> 메서드를 사용할 수 있다.</para>

      <para>어플리케이션의 컨텍스트에서 <classname>NamedParameterJdbcTemplate</classname>
      클래스를 사용하는 가이드라인에 대해서는 <xref linkend="jdbc-JdbcTemplate-idioms" />도
      참고해라.</para>
    </section>

    <section id="jdbc-SimpleJdbcTemplate">
      <title><classname>SimpleJdbcTemplate</classname></title>

      <para><classname>SimpleJdbcTemplate</classname> 클래스는 전통적인
      <classname>JdbcTemplate</classname>를 감싸고 가변인자와 오토박싱(autoboxing)같은
      자바 5의 기능을 사용한다.</para>

      <note>
        <para>스프링 3.0에서는 <classname>JdbcTemplate</classname>도 제너릭과 가변인자같은
        자바 5의 개선된 문법을 지원한다. 하지만 <classname>SimpleJdbcTemplate</classname>는
        JdbcTemplate가 제공하는 모든 메서드에 접근하지 않아도 될 때 가장 잘 동작하는 더 간단한 API를
        제공한다. 또한 <classname>SimpleJdbcTemplate</classname>가 자바 5에 맞춰서 설계되었기
        때문에 <classname>SimpleJdbcTemplate</classname>는 파라미터를 정렬을 다르게 하는데서
        오는 가변인자의 장점을 취하는 더 많은 메서드를 가진다.</para>
      </note>

      <para>편리한 문법적인 면에서 <classname>SimpleJdbcTemplate</classname> 클래스가 주는
      부가적인 가치는 이전-이후(before-and-after) 예시에서 가장 잘 설명한다. 다은 코드 예제는 전통적인
      <classname>JdbcTemplate</classname>를 사용하는 데이터 접근 코드를 보여주고 그 뒤에 이어진
      코드 예제는 같은 작업을 <classname>SimpleJdbcTemplate</classname>로 구현했다.</para>

      <programlisting language="java"><lineannotation>// 전통적인 <classname>JdbcTemplate</classname> 방식...</lineannotation>
private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
}
<!--How is the code shown below different from the code shown in the next example? It seems like they're the same.-->
public Actor findActor(String specialty, int age) {

    String sql = "select id, first_name, last_name from T_ACTOR" +
            " where specialty = ? and age = ?";

    RowMapper&lt;Actor&gt; mapper = new RowMapper&lt;Actor&gt;() {
        public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {
            Actor actor = new Actor();
            actor.setId(rs.getLong("id"));
            actor.setFirstName(rs.getString("first_name"));
            actor.setLastName(rs.getString("last_name"));
            return actor;
        }
    };


    <lineannotation>// 배열에 아규먼트들을 담은 것을 주의깊게 봐라.</lineannotation>
    return (Actor) jdbcTemplate.queryForObject(sql, new Object[] {specialty, age}, mapper);
}</programlisting>

      <para>다음은 <classname>SimpleJdbcTemplate</classname>로
      작성한 같은 메서드이다.<!--The code shown above is the same as the code shown below. What is the difference?
TR: difference is in the way the parameters are passed in on the last line; no need to use an Objcet[].--></para>

      <programlisting language="java"><lineannotation>// <classname>SimpleJdbcTemplate</classname> 방식...</lineannotation>
private SimpleJdbcTemplate simpleJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
}

public Actor findActor(String specialty, int age) {

    String sql = "select id, first_name, last_name from T_ACTOR" +
            " where specialty = ? and age = ?";
    RowMapper&lt;Actor&gt; mapper = new RowMapper&lt;Actor&gt;() {
        public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {
            Actor actor = new Actor();
            actor.setId(rs.getLong("id"));
            actor.setFirstName(rs.getString("first_name"));
            actor.setLastName(rs.getString("last_name"));
            return actor;
        }
    };

    <lineannotation>// 파라미터의 값들이 RowMapper 파라미터 이후에 오기 때문에
    // 가변인자를 사용하고 있다.</lineannotation>
    return this.simpleJdbcTemplate.queryForObject(sql, mapper, specialty, age);
}</programlisting>

      <para>어플리케이션의 컨텍스트에서 <classname>SimpleJdbcTemplate</classname> 클래스를
      사용하는 방법에 대한 가이드라인은 <xref linkend="jdbc-JdbcTemplate-idioms" />를
      참고해라.</para>

      <note>
        <para><classname>SimpleJdbcTemplate</classname> 클래스는
        <classname>JdbcTemplate</classname> 클래스가 노출하는 메서드의 하위세트만을 제공한다.
        <classname>SimpleJdbcTemplate</classname>에 정의되지 않은
        <classname>JdbcTemplate</classname> 메서드를 사용해야 한다면
        <classname>SimpleJdbcTemplate</classname>에서
        <methodname>getJdbcOperations()</methodname> 메서드를 호출해서 의존하는
        <classname>JdbcTemplate</classname>에 항상 접근해서 원하는 메서드를 호출할 수 있다.
        <interfacename>JdbcOperations</interfacename> 인터페이스의 메서들들은 제너릭이 아니라는
        점이 유일한 장점이므로 캐스팅등의 작업을 해야한다.</para>
      </note>
    </section>

    <section id="jdbc-SQLExceptionTranslator">
      <title><interfacename>SQLExceptionTranslator</interfacename></title>

      <para><interfacename>SQLExceptionTranslator</interfacename>는 데이터 접근
      전략에 관해서는 알 필요없이 <classname>SQLExceptions</classname>와 스프링 자체의
      <classname>org.springframework.dao.DataAccessException</classname>사이의
      변환을 할 수 있는 클래스가 구현하는 인터페이스이다. 구현체들은 제너릭이 되거나(예를 들면 JDBC에
      SQLState 코드를 사용하는) 훨씬 더 정확하게 소유자(proprietary)가 될 수 있다(예를 들면
      Oracle 오류 코드를 사용하는).</para>

      <para><classname>SQLErrorCodeSQLExceptionTranslator</classname>는 기본적으로
      사용하는 <interfacename>SQLExceptionTranslator</interfacename>의 구현체이다. 이
      구현체는 특정 벤더의 코드를 사용하고 이는 <literal>SQLState</literal> 구현체보다 훨씬 더
      정확하다. 오류코드 변환은 <classname>SQLErrorCodes</classname>라는 JavaBean 타입의
      클래스에 있는 코드에 기반한다. 이 클래스는 <classname>SQLErrorCodesFactory</classname>가
      생성하고 유지한다. <classname>SQLErrorCodesFactory</classname>는 이름에서 알 수 있듯이
      <filename class="libraryfile">sql-error-codes.xml</filename>라는 설정 파일의 내용에
      기반해서 <classname>SQLErrorCodes</classname>를 생성하는 팩토리이다.
      <filename class="libraryfile">sql-error-codes.xml</filename> 파일에는 벤더코드가 있고
      <interfacename>DatabaseMetaData</interfacename>에서 가져온
      <code>DatabaseProductName</code>에 기반한다. 실제로 사용하는 데이터베이스에 대한 코드를
      사용하게 된다.<!--what do you mean by *the current* database? --><!--TR: Revised, please review.--></para>

      <para><classname>SQLErrorCodeSQLExceptionTranslator</classname>는
      다음의 순서로 매칭규칙을 적용한다. <!--This reflects sequence in which rules are applied, right? I revised to a numbered list.--><orderedlist
          spacing="compact">
          <note>
            <para>Error 코드와 커스텀 예외 변환을 정의하는데
            <classname>SQLErrorCodesFactory</classname>를 기본적으로 사용한다. 클래스패스의
            <filename>sql-error-codes.xml</filename> 파일에서 검색을 하고 찾아낸
            <classname>SQLErrorCodes</classname> 인스턴스는 사용하는 데이터베이스의 데이터베이스
            메타데이터에서 데이터베이스 이름에 기반해서 위치하고 있다.</para>
          </note>

          <listitem>
            <para>하위클래스가 구현한 모든 커스텀 변환. 보통 제공된
            <classname>SQLErrorCodeSQLExceptionTranslator</classname> 구현을 사용하므로
            이 규칙은 적용되지 않는다. 실제로 제공된 하위클래스 구현체가 있을 때만 적용한다.<!--Pls revise last sentence to clarify. *Which* class is concrete? Why do you first refer to a subclass, then say *this class* is--><!--typically used and thus rule does not apply? This is really confusing.--><!--TR: Revised, please review.--></para>
          </listitem>

          <listitem>
            <para><classname>SQLErrorCodes</classname> 클래스의
            <classname>customSqlExceptionTranslator</classname> 프로퍼티로 제공되는
            <classname>SQLExceptionTranslator</classname> 인터페이스의 모든
            커스텀 구현체.</para>
          </listitem>

          <listitem>
            <para><classname>CustomSQLErrorCodesTranslation</classname> 클래스
            (<classname>SQLErrorCodes</classname> 클래스의
            <classname>customTranslations</classname> 프로퍼티에 제공된)의 인스턴스
            목록은 매칭을 위해서 검색된다.</para>
          </listitem>

          <listitem>
            <para>Error 코드 매칭은 적용된다.<!--Wording of the next sentence does not track. Please revise. --><!--TR: Revised, please review.--></para>
          </listitem>

          <listitem>
            <para>폴백(fallback) 변환기(translator)를 사용해라.
            <classname>SQLExceptionSubclassTranslator</classname>는 기본 폴백
            변환기이다. 이 변환을 사용할 수 없다면 다음 폴백 변환기는
            <classname>SQLStateSQLExceptionTranslator</classname>이다.</para>
          </listitem>
        </orderedlist></para>

      <para><classname>SQLErrorCodeSQLExceptionTranslator</classname>를
      확장할 수 있다.</para>

      <programlisting language="java">public class CustomSQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator {

    protected ㄷDataAccessException customTranslate(String task, String sql, SQLException sqlex) {
        if (sqlex.getErrorCode() == -12345) {
            return new DeadlockLoserDataAccessException(task, sqlex);
        }
        return null;
    }
}</programlisting>

      <para>이 예제에서 지정한 오류코드인 <literal>-12345</literal>는 변환되고 그외 다른
      오류코드들은 기본 변환기 구현체가 변환하도록 내버려둔다. 이 커스텀 변환기를 사용하려면
      <literal>setExceptionTranslator</literal> 메서드로 <classname>JdbcTemplate</classname>에
      커스텀 변환기를 전달해야 하고 이 변환기가 필요한 모든 데이터 접근 처리에 이
      <classname>JdbcTemplate</classname>를 사용해야 한다. 다음은 이 커스텀 변환기를 어떻게
      사용할 수 있는지에 대한 예제이다.</para>

      <programlisting language="java"><lineannotation>private JdbcTemplate jdbcTemoplate;

public void setDataSource(DataSource dataSource) {
    // <classname>JdbcTemplate</classname>를 생성하고 데이터 소스를 설정한다</lineannotation>
    this.jdbcTemplate = new JdbcTemplate();
    this.jdbcTemplate.setDataSource(dataSource);
<lineannotation>    // 커스텀 변환기를 생성하고 기본적으로 변환을 위해 검색되도록 <interfacename>DataSource</interfacename>에 설정한다</lineannotation>
    CustomSQLErrorCodesTranslator tr = new CustomSQLErrorCodesTranslator();
    tr.setDataSource(dataSource);
    this.jdbcTemplate.setExceptionTranslator(tr);
}

<lineannotation>public void updateShippingCharge(long orderId, long pct) {
    // 이 <classname>update</classname>에 <classname>prepared JdbcTemplate</classname>를 사용한다</lineannotation>
    this.jdbcTemplate.update(
        "update orders" +
            " set shipping_charge = shipping_charge * ? / 100" +
            " where id = ?"
        pct, orderId);
}</programlisting>

      <para><literal>sql-error-codes.xml</literal>의 오류 코드를 검색하기 위해 데이터
      소스에 커스텀 변환기를 전달한다.</para>
    </section>

    <section id="jdbc-statements-executing">
      <title>스테이트먼트 실행</title>

      <para>SQL 스테이트먼트를 실행하려면 아주 약간의 코드가 필요하다. <interfacename>DataSource</interfacename>와 편리한 메서드를 가진 <classname>JdbcTemplate</classname>이 필요하다.<!--Does reader know what you mean by *convenience* methods? TR: OK as is. I hope they know what this is.-->
      다은 예제는 새로운 테이블을 생성하는 완전한 기능을 가진 클래스에 최소한으로 무엇을 포함해야
      하는지를 보여준다.</para>

      <programlisting language="java">import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class ExecuteAStatement {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public void doExecute() {
        this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");
    }
}</programlisting>
    </section>

    <section id="jdbc-statements-querying">
      <title>조회 수행</title>

      <para>몇몇 조회 메서드는 단일 값을 반환한다. 하나의 열에서 카운트나 특정 값을 획득하려면
      <methodname>queryForInt(..)</methodname>,
      <methodname>queryForLong(..)</methodname>,
      <methodname>queryForObject(..)</methodname>를 사용해라. 후자의 경우 반환된 JDBC
      <classname>Type</classname>를 아규먼트로 전달한 자바 클래스로 변환한다. 타입 변환이
      유효하지 않다면 <exceptionname>InvalidDataAccessApiUsageException</exceptionname>를
      던진다. 다음은 두 개의 조회 메서드를 가진 예제다. 조회 메서드 중 하나는
      <classname>int</classname>를 조회하고 다른 하나는
      <classname>String</classname>을 조회한다.</para>

      <programlisting language="java">import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class RunAQuery {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public int getCount() {
        return this.jdbcTemplate.queryForInt("select count(*) from mytable");
    }

    public String getName() {
        return (String) this.jdbcTemplate.queryForObject("select name from mytable", String.class);
    }

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}</programlisting>

      <para>하나의 값을 반환하는 조회 메서드에 추가적으로 많은 메서드들은 조회결과의 각 열의 엔트리
      목록을 반환한다. 가장 일반적인 메서드는 <interfacename>List</interfacename>를 반환하는
      <methodname>queryForList(..)</methodname>인다. <interfacename>List</interfacename>의
      각 엔트리는 해당 열의 컬럼값을 맵으로 나타낸 <interfacename>Map</interfacename>이다.
      모든 열의 리스트를 얻기위해 위의 예제에 메서드를 추가하면 다음과 같이 될 것이다.</para>

      <programlisting language="java">
private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
}

public List&lt;Map&lt;String, Object&gt;&gt; getList() {
    return this.jdbcTemplate.queryForList("select * from mytable");
}</programlisting>

      <para>반환된 리스트는 다음과 같은 형태가 될 것이다.</para>

      <programlisting>[{name=Bob, id=1}, {name=Mary, id=2}]</programlisting>
    </section>

    <section id="jdbc-updates">
      <title>데이터베이스 갱신</title>

      <para>다음 예제는 지정한 기본 키(primary key)로 갱신된 컬럼을 보여준다. 이 예제에서 SQL문은
      열(row) 파라미터를 위한 플레이스홀더를 가진다. 파라미터 값은 가변인자나 객체의 배열로 전달할 수 있다.
      그러므로 프리미티브(primitives)는 프리미티브 랩퍼 클래스로 명식적으로 감싸거나 오토박싱을
      사용해야 한다.</para>

      <programlisting language="java">import javax.sql.DataSource;

import org.springframework.jdbc.core.JdbcTemplate;

public class ExecuteAnUpdate {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public void setName(int id, String name) {
        this.jdbcTemplate.update(
                "update mytable set name = ? where id = ?",
                name, id);
    }
}</programlisting>
    </section>

    <section id="jdbc-auto-genereted-keys">
      <title>자동 생성된 키 얻기</title>

      <para>편리한 <methodname>update()</methodname>
      메서드는<!--Give name of this method. Also indicate *what* is acquiring the primary keys. TR: Changed to *retrieval*.
The name of the method is *update*.--> 데이터베이스가 생성한 기본 키의 획득을 지원한다.
      이 지원은 JDBC 3.0 표준의 일부분이다. 자세한 내용은 명세서의 13.6장을 참고해라. 이 메서드는
      첫 인자로 <classname>PreparedStatementCreator</classname>를 받은데 이것이 필수
      insert문을 지정하는 방법이다. 다른 인자는 update가 성공정으로 반환하는 생성된 키를 담고 있는
      <classname>KeyHolder</classname>이다. 적합한 <classname>PreparedStatement</classname>
      (메서드 시그니처가 왜 이렇게 되어 있는지를 설명한다.)를 생성하는 하나의 표준화된 방법은 존재하지
      않는다. 다음 예제는 오라클에서는 동작하지만 다른 플랫폰에서는 동작하지 않는다.</para>

      <programlisting language="java">final String INSERT_SQL = "insert into my_test (name) values(?)";
final String name = "Rob";

KeyHolder keyHolder = new GeneratedKeyHolder();
jdbcTemplate.update(
    new PreparedStatementCreator() {
        public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
            PreparedStatement ps =
                connection.prepareStatement(INSERT_SQL, new String[] {"id"});
            ps.setString(1, name);
            return ps;
        }
    },
    keyHolder);

<lineannotation>// keyHolder.getKey()는 이제 생성된 키를 담고 있다</lineannotation></programlisting>
    </section>
  </section>

  <section id="jdbc-connections">
    <title>데이터베이스 연결 제어</title>

    <section id="jdbc-datasource">
      <title><interfacename>DataSource</interfacename><!--I don't understand why *DataSource* was a subsection of *Using the JDBC classes to control basic JDBC processing and error handling*.--><!--According to *The package hierarchy*section, there is a datasource package, separate from the core package.So I moved it to this section. TR: OK.--></title>

      <para>스프링은 <interfacename>DataSource</interfacename>로 데이터베이스의 연결을
      획득한다. <interfacename>DataSource</interfacename>는 JDBC 명세의 일부분이면서
      일반화된 연결 팩토리이다. 컨테이너나 프레임워크는 <interfacename>DataSource</interfacename>로
      어플리케이션 코드에서 연결 풀링(pooling)과 트랜잭션 관리 이슈를 감출 수 있다. 개발자들은
      데이터베이스에 연결하는 방법에 대해서 자세히 알 필요가 없다. 이는 데이터소스를 설정하는 관리자의
      책임이다. 아마 대부분은 코드를 작성하고 테스트하는 두가지 역할을 다 할 것이지만 프로덕션 데이터
      소스가 어떻게 설정되는 지를 알아야 할 필요는 없다.</para>

      <para>스프링의 JDBC 계층을 사용하는 경우 JNDI에서 데이터 소스를 얻거나 서드파티가 제공하는
      커넥션풀 구현체로 설정한다. 많이 사용하는 구현체는 Apache Jakarta Commons DBCP와
      C3P0이다. 스프링 배포판에 포함된 구현체는 오로지 테스트만을 위해서 제공되는 것이고
      풀링(pooling)은 하지 않는다.</para>

      <para>이번 섹션에서는 스프링의 <classname>DriverManagerDataSource</classname>
      구현체를 사용하고 뒷부분에서 여러가지 부가적인 구현체를 다룬다.</para>

      <para><note>
          <para><classname>DriverManagerDataSource</classname>는 풀링을 지원하지
          않으므로 테스트할 때만 사용해야 하고 연결을 하는 여러 요청이 있을 때는 성능이
          나빠질 것이다.</para>
        </note>일반적으로 JDBC 연결을 얻듯이
      <classname>DriverManagerDataSource</classname>로 연결을 얻는다.
      <classname>DriverManager</classname>가 드라이버 클래스를 로드할 수 있도록 JDBC
      드라이버의 정규화된 클래스명을 지정해라. 그 다음, JDBC 드라이버마다 다른 URL을 제공해라.(정확한
      값은 드라이버의 문서를 참고해라.) 그리고 데이터베이스 연결에 사용자명과 비밀번호를 제공해라. 다음은
      자바코드로 어떻게 <classname>DriverManagerDataSource</classname> 설정하는 지에
      대한 예제이다.</para>

      <programlisting language="java">DriverManagerDataSource dataSource = new DriverManagerDataSource();
dataSource.setDriverClassName("org.hsqldb.jdbcDriver");
dataSource.setUrl("jdbc:hsqldb:hsql://localhost:");
dataSource.setUsername("sa");
dataSource.setPassword("");</programlisting>

      <para>다음은 대응되는 XML 설정이다.</para>

      <programlisting language="java">&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
&lt;/bean&gt;

&lt;context:property-placeholder location="jdbc.properties"/&gt;</programlisting>

      <para>다음 예제는 DBCP와 C3P0의 기본적인 연결과 설정을 보여준다. 풀링 기능을 제어하는
      더 많은 옵션에 대해서 알고 싶다면 각 커넥션 풀링 구현체의 제품 문서를 참고해라.</para>

      <para>DBCP 설정:</para>

      <programlisting language="java">&lt;bean id="dataSource"
        class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
&lt;/bean&gt;

&lt;context:property-placeholder location="jdbc.properties"/&gt;</programlisting>

      <para>C3P0 설정:</para>

      <programlisting language="java">&lt;bean id="dataSource"
        class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"&gt;
    &lt;property name="driverClass" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="jdbcUrl" value="${jdbc.url}"/&gt;
    &lt;property name="user" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
&lt;/bean&gt;

&lt;context:property-placeholder location="jdbc.properties"/&gt;</programlisting>
    </section>

    <section id="jdbc-DataSourceUtils">
      <title><classname>DataSourceUtils</classname></title>

      <para><classname>DataSourceUtils</classname> 클래스는 JNDI에서 연결을 얻고
      필요한 경우 연결을 닫는 <literal>static</literal> 메서드를 제공하는 편리하고 강력한
      헬퍼 클래스이다. 예를 들어 <classname>DataSourceUtils</classname> 클래스는
      <classname>DataSourceTransactionManager</classname>로 스레드에 기반한
      연결을 지원한다.</para>
    </section>

    <section id="jdbc-SmartDataSource">
      <title><interfacename>SmartDataSource</interfacename></title>

      <para><interfacename>SmartDataSource</interfacename> 인터페이스는 관계형
      데이터베이스의 연결을 제공할 수 있는 클래스로 구현되어야 한다.
      <interfacename>SmartDataSource</interfacename>는 클래스가
      <interfacename>SmartDataSource</interfacename> 인터페이스를 사용해서 해당 작업
      후에 연결을 닫아야하는지 물어볼 수 있도록 <interfacename>DataSource</interfacename>를
      확장한다. 이 방법은 연결을 재사용한다는 것을 알고 있을 때 효율적이다.</para>
    </section>

    <section id="jdbc-AbstractDataSource">
      <title><classname>AbstractDataSource</classname></title>

      <para><code><classname>AbstractDataSource</classname></code>는 모든
      <classname>DataSource</classname> 구현체에 공통적인 코드를 구현하는 스프링의
      <interfacename>DataSource</interfacename> 구현체의
      <literal><classname>abstract</classname></literal> 기반 클래스이다.<!--Please revise *takes care of uninteresting glue* to specify what exactly it does. Avoid slang and idomatic language, --><!--especially important with non-native English readers. TR: Revised, please review.-->
      자신만의 <interfacename>DataSource</interfacename> 구현체를 작성한다면
      <classname>AbstractDataSource</classname> 클래스를 확장해라.<!--Preceding revision ok? If not, revise to specify *which* class you extend if you are writing your own DataSource imp. TR: OK.--></para>
    </section>

    <section id="jdbc-SingleConnectionDataSource">
      <title><classname>SingleConnectionDataSource</classname></title>

      <para><classname>SingleConnectionDataSource</classname>는
      <interfacename>SmartDataSource</interfacename> 인터페이스의 구현체로 사용할 때마다
      닫지 <emphasis>않는</emphasis> <emphasis>하나의</emphasis>
      <interfacename>Connection</interfacename>을 감싸고 있다. 명백하게 이는
      멀티쓰레드 기능은 아니다.</para>

      <para>퍼시스턴스 도구를 사용할 때처럼 풀링된 연결에서 <command>close</command>를 호출하는 클라이언트 코드가 있다면 <literal>suppressClose</literal> 프로퍼티를 <literal>true</literal>로 설정해라. <!--Have I revised this correctly? THe client code is calling *close*? If not, revise to clarify. Also WHERE do you set --><!--suppressClose to true? TR: OK. suppressClose is set directly on the SingleConnectionDataSource instance.-->이 설정은 물리적인 연결을 감싸고 있는 닫기차단
      프록시(close-suppressing proxy)를 반환한다. 이를 네이티브 오라클
      <interfacename>Connection</interfacename> 등으로 캐스팅 할 수 있다는
      점에 주의해라.</para>

      <para><classname>SingleConnectionDataSource</classname>는 주로 테스트
      클래스이다. 예를 들어 어플리케이션 서버 외부에서 간단한 JNDI 환경과 결합해서 쉽게 코드를
      테스트할 수 있다. <classname>DriverManagerDataSource</classname>와는 반대로
      <classname>SingleConnectionDataSource</classname>는 물리적인 연결의 과도한
      생성을 피하려고 항상 같은 연력을 재사용한다.</para>
    </section>

    <section id="jdbc-DriverManagerDataSource">
      <title><classname>DriverManagerDataSource</classname></title>

      <para><classname>DriverManagerDataSource</classname> 클래스는 표준
      <interfacename>DataSource</interfacename> 인터페이스의 구현체로 빈(bean)
      프로퍼티로 평범한 JDBC 드라이버를 설정하고 매번 새로운
      <interfacename>Connection</interfacename>를 반환한다.</para>

      <para>이 구현체는 스프링 IoC 컨테이너의 <interfacename>DataSource</interfacename>
      빈이든 간단한 JNDI 환경과 결합해서 사용하든 간에 Java EE 컨테이너 외부의 단독적인 환경이나
      테스트에 유용하다. 풀링을 가정한 <literal>Connection.close()</literal> 호출은 연결을
      그냥 닫아버리므로 <interfacename>DataSource</interfacename>에 의존하는 모든 퍼시스턴스
      코드는 동작할 것이다. 하지만 <code>commons-dbcp</code>같은 JavaBean방식의 커넥션풀의 사용은
      테스트 환경에서조차도 아주 쉽다. 테스트 환경에서는 거의 대부분
      <classname>DriverManagerDataSource</classname>상의 커넥션풀등을 사용하는 것이
      바람직하다.</para>
    </section>

    <section id="jdbc-TransactionAwareDataSourceProxy">
      <title><classname>TransactionAwareDataSourceProxy</classname></title>

      <para><classname>TransactionAwareDataSourceProxy</classname>는 대상
      <interfacename>DataSource</interfacename>의 프록시로 스프링이 관리하는 트랜잭션을
      인식하도록 해당 대상 <interfacename>DataSource</interfacename>를 감싼다. 이런 점에서
      Java EE 서버가 제공하는 트랜잭션이 가능한 JNDI
      <interfacename>DataSource</interfacename>와 유사하다.</para>

      <note>
        <para>이미 존재하는 코드에서 표준 JDBC <interfacename>DataSource</interfacename>
        인터페이스 구현체를 호출하고 전달해야 하는 경우를 제외하고는 이 클래스를 사용할 일은 많지 않을
        것이다. 이러한 경우에도 여전히 이 코드를 사용할 수 있고 동시에 스프링이 관리하는 트랜잭션에 참가한다.
        <!--Clarify preceding sentence. Are you saying, if you use TransactionAwareDataSource Proxy in this case, then what?--><!--I don't get the *usable, but* participating in Spring-managed transactions. TR: Revised, please review. -->
        <classname>JdbcTemplate</classname>나 <classname>DataSourceUtils</classname>같은
        리소스 관리에 더 높은 수준의 추상화를 사용해서 새로운 코드를 작성하는 것이 일반적으로 더 낫다.</para>
      </note>

      <para><emphasis>(더 자세한 내용은
      <classname>TransactionAwareDataSourceProxy</classname> Javadoc을
      참고해라.)</emphasis></para>
    </section>

    <section id="jdbc-DataSourceTransactionManager">
      <title><classname>DataSourceTransactionManager</classname></title>

      <para><classname>DataSourceTransactionManager</classname> 클래스는 단일 JDBC
      데이터소스의 <interfacename>PlatformTransactionManager</interfacename> 구현체이다.
      <classname>DataSourceTransactionManager</classname>는 지정한 데이터 소스의 JDBC
      연결을 현재 실행되고 있는 스레드에 바인딩하고 아마도 데이터 소스마다 하나의 스레드 연결을
      할 것이다.</para>

      <para>Java EE의 표준 <literal>DataSource.getConnection</literal> 대신
      <literal>DataSourceUtils.getConnection(DataSource)</literal>로 JDBC
      연결을 얻으려면 어플리케이션 코드가 필요하다. <!--app code such as what, for example? What do you have to provide? TR: OK as is.-->
      <literal>DataSourceUtils.getConnection(DataSource)</literal>는 체크드
      <exceptionname>SQLExceptions</exceptionname> 대신 언체크드
      <literal>org.springframework.dao</literal> 예외를 던진다.
      <classname>JdbcTemplate</classname>같은 모든 프레임워크 클래스들은 암묵적으로
      이 전략을 사용한다. 이 트랜잭션 관리자를 사용하지 않는다면 검색 전략은 정확하게 공통된 것으로
      수행한다. 그러므로 어떠한 경우에도 사용할 수 있다.</para>

      <para><classname>DataSourceTransactionManager</classname> 클래스는 커스텀
      격리수준과 작절한 JDBC 스테이트먼트 쿼리 만료시간에 적용되는 만료시간(timeout)을 지원한다.
      후자를 지원하려면 어클리케이션 코드가 <classname>JdbcTemplate</classname>를 사용하거나
      스테이크먼트를 생성할 때마다 <literal>DataSourceUtils.applyTransactionTimeout(..)</literal>
      메서드를 호출해야 한다.</para>

      <para>이 구현체를 리소스가 하나인 경우에 <classname>JtaTransactionManager</classname>
      대신 사용할 수 있으므로 JTA를 지원하는 컨테이너가 필요치 않다. 필요로하는 연결 검색패턴을 사용하는
      경우에는 단지 설정만 바꾸면 된다. JTA는 커스텀 격리수준을 지원하지 않는다!</para>
    </section>

    <section id="jdbc-NativeJdbcExtractor">
      <title>NativeJdbcExtractor</title>

      <para>때로는 표준 JDBC API와는 다른 벤더에 특화된 JDBC 메서드에 접근해야 한다. 어플리케이션
      서버를 운영하고 있거나 <classname>Connection</classname>,
      <classname>Statement</classname>, <classname>ResultSet</classname> 객체들을 랩퍼
      객체로 감싸는 <classname>DataSource</classname>를 사용하고 있다면 벤더에 특화된 JDBC
      메서드에 접근하는 것은 문제의 소지가 있다. 네이티브 객체에 접근하려면
      <classname>JdbcTemplate</classname>나 <classname>OracleLobHandler</classname>를
      <classname>NativeJdbcExtractor</classname>로 설정할 수 있다.</para>

      <para><code>NativeJdbcExtractor</code>는 실행환경에 따라 다양하다.</para>

      <itemizedlist>
        <listitem>
          <para>SimpleNativeJdbcExtractor</para>
        </listitem>

        <listitem>
          <para>C3P0NativeJdbcExtractor</para>
        </listitem>

        <listitem>
          <para>CommonsDbcpNativeJdbcExtractor</para>
        </listitem>

        <listitem>
          <para>JBossNativeJdbcExtractor</para>
        </listitem>

        <listitem>
          <para>WebLogicNativeJdbcExtractor</para>
        </listitem>

        <listitem>
          <para>WebSphereNativeJdbcExtractor</para>
        </listitem>

        <listitem>
          <para>XAPoolNativeJdbcExtractor</para>
        </listitem>
      </itemizedlist>

      <para>보통은 대부분의 환경에서 감싸지 않은 <classname>Connection</classname>
      객체에 <classname>SimpleNativeJdbcExtractor</classname>로 충분한다.
      자세한 내용은 Javadoc를 참고해라.</para>
    </section>
  </section>

  <section id="jdbc-advanced-jdbc">
    <title>JDBC 배치 작업</title>

    <para>대부분의 JDBC 드라이버는 같은 프리페어드 스테이트먼트를 여러번 호출하는 배치에 향상된 성능을
    제공한다. 갱신(update)을 배치로 그룹핑해서 데이터베이스에 라운드트립하는 수를 제한한다. 이번 섹션은
    <classname>JdbcTemplate</classname>와 <classname>SimpleJdbcTemplate</classname>를
    둘 다 사용하는 배치 처리를 다룬다.</para>

    <section id="jdbc-batch-classic">
      <title>JdbcTemplate의 기본적인 배치 작업</title>

      <para>전용 인터페이스인 <classname>BatchPreparedStatementSetter</classname>의
      두 메서드를 구현해서 <classname>batchUpdate</classname> 메서드 호출의 두번째 파라미터로
      전달함으로써 <classname>JdbcTemplate</classname> 배치 처리를 한다. 현재 배치의 크기를
      공하려면 <classname>getBatchSize</classname>를 사용해라. 프리페어드 스테이트먼트의
      파라미터에 값을 설정하려면 <classname>setValues</classname> 메서드를 사용해라. 이 메서드는
      <classname>getBatchSize</classname>  호출에서 지정한 횟수만큼 호출될 것이다. 다음 예제는
      리스트로 actor 테이블의 엔트리를 갱신한다. 이 예제에서 전체 리스트는 배치로 사용된다.</para>

      <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public int[] batchUpdate(final List&lt;Actor&gt; actors) {
        int[] updateCounts = jdbcTemplate.batchUpdate(
                "update t_actor set first_name = ?, last_name = ? where id = ?",
                new BatchPreparedStatementSetter() {
                    public void setValues(PreparedStatement ps, int i) throws SQLException {
                        ps.setString(1, actors.get(i).getFirstName());
                        ps.setString(2, actors.get(i).getLastName());
                        ps.setLong(3, actors.get(i).getId().longValue());
                    }

                    public int getBatchSize() {
                        return actors.size();
                    }
                } );
        return updateCounts;
    }

    //  ... 추가적인 메서드
}</programlisting>파일에서 읽거나 갱신한 스트림을 처리한다면 원하는 배치크기가 있을 것이지만 마지막
      배치는 엔트리의 수를 갖지 않을 것이다. 이 경우에 입력소스가 모두 소비되면 배치를 인터럽트할 수
      있게 하는 <classname>InterruptibleBatchPreparedStatementSetter</classname>
      인터페이스를 사용할 수 있다. <classname>isBatchExhausted</classname> 메서드는
      배치 마지막에 신호를 보낼 수 있게 한다.</para>
    </section>

    <section id="jdbc-batch-list">
      <title>객체 리스트의 배치 작업</title>

      <para><classname>JdbcTemplate</classname>와
      <classname>NamedParameterJdbcTemplate</classname> 모두 배치 갱신의 대안책을 제공한다.
      전용 배치 인터페이스를 구현하는 대신에 호출의 모든 파라미터 값을 리스ㅡ로 제공한다. 프레임워크는
      이 값들을 순회하면서 내부의 프리페어드 스테이트먼트의 setter를 사용한다. 이름있는 파라미터를
      사용하는지 여부에 따라 API는 달라진다. 이름있는 파라미터에서는 배치의 각 멤버의 엔트리로
      <classname>SqlParameterSource</classname>의 배열을 제공한다. 이 배열을 생성하는데
      <classname>SqlParameterSource.createBatch</classname> 메서드를 사용할 수 있고
      이 메서드에는 파라미터값을 담고 있는 JavaBean의 배열이나 맵의 배열을 전달한다.</para>

      <para>이 예제는 이름있는 파라미터를 사용한 배치 갱신을 보여준다.</para>

      <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
    private NamedParameterTemplate namedParameterJdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
    }

    public int[] batchUpdate(final List&lt;Actor&gt; actors) {
        SqlParameterSource[] batch = SqlParameterSourceUtils.createBatch(actors.toArray());
        int[] updateCounts = namedParameterJdbcTemplate.batchUpdate(
            "update t_actor set first_name = :firstName, last_name = :lastName where id = :id",
            batch);
        return updateCounts;
    }

    //  ... 추가적인 메서드
}</programlisting>전통적인 "?" 플레이스홀더를 사용하는 SQL에서는 갱신할 값의 객체 배열을 담고 있는
      리스트를 전달한다. 이 객체 배열은 SQL문의 각 플레이스홀더마다 하나의 엔트리를 가져야 하고
      SQL문에 정의된 것과 같은 순서여야 한다.</para>

      <para>전통적인 JDBC "?" 플레이스홀더를 사용하는 같은 예제</para>

      <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public int[] batchUpdate(final List&lt;Actor&gt; actors) {
        List&lt;Object[]&gt; batch = new ArrayList&lt;Object[]&gt;();
        for (Actor actor : actors) {
            Object[] values = new Object[] {
                    actor.getFirstName(),
                    actor.getLastName(),
                    actor.getId()};
            batch.add(values);
        }
        int[] updateCounts = jdbcTemplate.batchUpdate(
                "update t_actor set first_name = ?, last_name = ? where id = ?",
                batch);
        return updateCounts;
    }

    //  ... 추가적인 메서드
}</programlisting>위의 모든 배치 갱신 메서드들은 각 배치에서 업데이트된 열의 수를 담고 있는 배열을
      반환한다. 이 갯수는 JDBC 드라이버가 보고한 숫자이다. 이 갯수가 없다면
      JDBC 드라이버는 -2를 반환한다.</para>
    </section>

    <section id="jdbc-batch-multi">
      <title>여러가지 배치를 가진 배치 작업</title>

      <para>배치 갱신의 마지막 예제는 여러 가지 작은 배치로 분리하기를 원하는 꽤 큰 배치이다. 물론
      <classname>batchUpdate</classname> 메서드를 여러번 호출해서 앞에서 언급한 메서드들로
      처리할 수도 있지만 더 편리한 메서드가 있다. 이 메서드는 SQL문 외에 파라미터를 담고 있는 객체의
      컬렉션, 각 배치가 갱신해야하는 수, 프리페이스 스테이트먼트의 파라미터 값을 설정할
      <classname>ParameterizedPreparedStatementSetter</classname> 받는다. 프레임워크는
      제공받은 값들을 순회하면서 지정한 크기로 갱신 호출을 나눈다.</para>

      <para>다음의 예제는 배치 사이즈 100을 사용하는 배치 업데이트를 보여준다.</para>

      <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public int[][] batchUpdate(final Collection&lt;Actor&gt; actors) {
        Collection&lt;Object[]&gt; batch = new ArrayList&lt;Object[]&gt;();
        for (Actor actor : actors) {
            Object[] values = new Object[] {
                    actor.getFirstName(),
                    actor.getLastName(),
                    actor.getId()};
            batch.add(values);
        }
        int[][] updateCounts = jdbcTemplate.batchUpdate(
                "update t_actor set first_name = ?, last_name = ? where id = ?",
                actors,
                100,
                new ParameterizedPreparedStatementSetter&lt;Actor&gt;() {
                    public void setValues(PreparedStatement ps, Actor argument) throws SQLException {
                        ps.setString(1, argument.getFirstName());
                        ps.setString(2, argument.getLastName());
                        ps.setLong(3, argument.getId().longValue());

                     }
                 } );
        return updateCounts;
    }

    //  ... 추가적인 메서드
}</programlisting>이 호출의 배치 갱신 메서드들은 갱신된 각각의 열의 갯수의 배열을 가진 각 배치의
      배열 엔트리를 담고 있는 int 배열의 배열을 반환한다. 최상위 배열의 길이는 실행된 배치의 수를
      나타내고 두번째 깊이의 배열 길이는 해당 배치가 갱신한 수를 나타낸다. 각 배치에서 갱신된 수는 모든
      배치에 제공된 배치 크기여야 하지만 마지막 배치는 제공한 갱신 객체의 전체 수에 따라 더 적을 수도
      있다. 각 업데이트 스테이트먼트에서 갱신된 수는 JDBC 드라이버가 보고한 수이다. 이 갯수가 없다면
      JDBC 드라이버는 -2를 반환한다.</para>
    </section>
  </section>

  <section id="jdbc-simple-jdbc">
    <title>SimpleJdbc 클래스로 JDBC 작업 간소화하기</title>

    <para><classname>SimpleJdbcInsert</classname>와
    <classname>SimpleJdbcCall</classname> 클래스는 JDBC 드라이버로 얻을 수 있는 데이터베이스
    메타데이터로 설정을 간소화하게 한다. 즉, 코드에서 세세하게 모든것을 제공하기를 좋아한다면 메타데이터
    처리를 끄거나 덮어쓸 수 있다고 하더라도 설정이 더 줄어든다.</para>

    <section id="jdbc-simple-jdbc-insert-1">
      <title>SimpleJdbcInsert를 사용해서 데이터 추가하기</title>

      <para>최소한의 설정 옵션으로 <classname>SimpleJdbcInsert</classname> 클래스를
      살펴보자. 데이터 접근 계층의 초기화 메서드에서 <classname>SimpleJdbcInsert</classname>를
      인스턴스화 해야한다. <!--What do you mean *should be*? Are you saying a human should do it. If so, say *You should instantiate the SimpleJdbcInsert...* Also, is--><!--it correct to say *in* the data access layer's init method? Should it be *with*. Below, what do you mean by *fluid style*?
TR: Revised, please review.-->이 예제에서 초기화 메서드는 <classname>setDataSource</classname>
      메서드이다. <classname>SimpleJdbcInsert</classname> 클래스의 하위클래스를 만들 필요는 없다.
      그냥 새로운 인스턴스를 생성하고 <classname>withTableName</classname> 메서드로 테이블명을 설정해라.
      이 클래스의 설정 메서드는 모든 설정 메서드를 체인으로 연결 할 수 있도록
      <classname>SimpleJdbcInsert</classname>의 인스턴스를 반환하는 "유동성있는(fluid)" 방식을
      따른다. 이 예제는 딱 하나의 설정 메서드를 사용한다. 뒤에서 여러 설정메서드를 사용하는 예제를
      볼 것이다.</para>

      <programlisting language="java">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcTemplate simpleJdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
        this.insertActor =
                new SimpleJdbcInsert(dataSource).withTableName("t_actor");
    }

    public void add(Actor actor) {
        Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(3);
        parameters.put("id", actor.getId());
        parameters.put("first_name", actor.getFirstName());
        parameters.put("last_name", actor.getLastName());
        insertActor.execute(parameters);
    }

    //  ... 추가적인 메서드
}</programlisting>

      <para>여기서 사용할 실행 메서드는 유일한 파라미터로 평범한
      <classname>java.utils.Map</classname>를 받는다. 여기서 중요한 점은 맵에 사용한
      키가 데이터베이스에 정의한 테이블의 컬럼명과 일치해야 한다는 것이다. 이는 실제 insert문을
      생성하려고 메타데이터를 읽기 때문이다.</para>
    </section>

    <section id="jdbc-simple-jdbc-insert-2">
      <title>SimpleJdbcInsert를 사용해서 자동생성된 키 얻기</title>

      <para>이 예제는 앞의 예제와 같은 insert문을 사용하지만 id에 전달하는 하는 대신 자동생성된
      키를 얻어서 새로운 Actor 객체에 설정한다. <classname>SimpleJdbcInsert</classname>를
      생성할 때 테이블명을 지정하는 것 외에 <classname>usingGeneratedKeyColumns</classname>
      메서드로 생성된 키의 컬럼명을 지정한다.</para>

      <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcTemplate simpleJdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
        this.insertActor =
                new SimpleJdbcInsert(dataSource)
                        .withTableName("t_actor")
                        .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(2);
        parameters.put("first_name", actor.getFirstName());
        parameters.put("last_name", actor.getLastName());
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    //  ... 추가적인 메서드
}</programlisting>두번째 접근으로 인서트할 때 가장 큰 차이점은 맵에 id를 추가하지 않고
      <literal>executeReturningKey</literal> 메서드를 호출한다는 점이다. 이는 도메인 클래스에서
      사용하는 숫자타입의 인스턴스를 생성할 수 있는 <literal>java.lang.Number</literal> 객체를
      반환한다. 여기서 특정 자바 클래스를 리턴하도록 모든 데이터베이스에 의존할 수 없다.
      <literal>java.lang.Number</literal>는 의존할 수 있는 기반 클래스이다. 자동생성되는 컬럼이
      다수이거나 생성된 값이 숫자가 아니라면 <literal>executeReturningKeyHolder</literal> 메서드가
      반환하는 <literal>KeyHolder</literal>를 사용할 수 있다.</para>
    </section>

    <section id="jdbc-simple-jdbc-insert-3">
      <title>SimpleJdbcInsert에 컬럼 지정하기</title>

      <para><classname>usingColumns</classname> 메서드에 컬럼명의 리스트를 지정해서
      인서트할 컬럼을 제한할 수 있다.</para>

      <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcTemplate simpleJdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
        this.insertActor =
                new SimpleJdbcInsert(dataSource)
                        .withTableName("t_actor")
                        .usingColumns("first_name", "last_name")
                        .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(2);
        parameters.put("first_name", actor.getFirstName());
        parameters.put("last_name", actor.getLastName());
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    //  ... 추가적인 메서드
}</programlisting>인서트 실행은 사용할 컬럼을 결정하는 메타데이터에 의존하는 것과 같다.</para>
    </section>

    <section id="jdbc-simple-jdbc-parameters">
      <title>파라미터 값 제공에 SqlParameterSource 사용하기</title>

      <para>파라미터 값을 제공하는데 <classname>Map</classname>을 사용해서 잘 동작하지만 <classname>Map</classname>은 사용하기 가장 편리한 클래스는 아니다. 대신 사용할 수 있는 <classname>SqlParameterSource</classname> 인터페이스의 구현체를 스프링이 다수 제공한다.<!--But *what* class (classname?) is not the most convenient? TR: OK as is.-->
      먼저 살펴볼 구현체는 파라미터 값을 담고 있는 JavaBean호환 클래스를 가지고 있다면 아주 편리한
      클래스인 <classname>BeanPropertySqlParameterSource</classname>이다.
      <classname>BeanPropertySqlParameterSource</classname>는 파라미터 값을 추출하는데
      대응되는 getter 메서드를 사용할 것이다. 다음은 그 예제이다.</para>

      <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcTemplate simpleJdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
        this.insertActor =
                new SimpleJdbcInsert(dataSource)
                        .withTableName("t_actor")
                        .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        SqlParameterSource parameters = new BeanPropertySqlParameterSource(actor);
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    //  ... 추가적인 메서드
}</programlisting>또다른 옵션은 Map과 비슷하지만 체인으로 연결할 수 있는 더 편리한
      <classname>addValue</classname> 메서드를 제공하는
      <classname>MapSqlParameterSource</classname>이다.</para>

      <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcTemplate simpleJdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
        this.insertActor =
                new SimpleJdbcInsert(dataSource)
                        .withTableName("t_actor")
                        .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        SqlParameterSource parameters = new MapSqlParameterSource()
                .addValue("first_name", actor.getFirstName())
                .addValue("last_name", actor.getLastName());
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    //  ... 추가적인 메서드
}</programlisting>여기서 보듯이 설정은 동일하다. 실행코드에서 유일하게 달라진 점은
      다른 입력 클래스를 사용한 것뿐이다.</para>
    </section>

    <section id="jdbc-simple-jdbc-call-1">
      <title>SimpleJdbcCall로 저장 프로시저 호출하기</title>

      <para><classname>SimpleJdbcCall</classname> 클래스는 <code>in</code>과
      <code>out</code> 파라미터의 이름을 검색하는데 데이터베이스의 메타데이터를 사용하므로 명시적으로
      파라미터 이름을 지정하지 않아도 된다. 명시적으로 지정하는 것을 더 선호하거나 자바 클래스로 자동매핑되지
      않는 <code>ARRAY</code>나 <code>STRUCT</code>같은 파라미터라면 파라미터를 선언할 수 있다.
      첫 예제는 MySQL 데이터베이스에서 <code>VARCHAR</code>와 <code>DATE</code> 형식의
      스칼라(scalar) 값만을 반환하는 간단한 프로시저를 보여준다. 이 예제의 프로시저는 지정한 액터(actor)
      엔트리를 읽고 <code>out</code> 파라미터의 형식으로 <code>first_name</code>,
      <code>last_name</code>, <code>birth_date</code>컬럼을 반환한다.</para>

      <para><programlisting>CREATE PROCEDURE read_actor (
  IN in_id INTEGER,
  OUT out_first_name VARCHAR(100),
  OUT out_last_name VARCHAR(100),
  OUT out_birth_date DATE)
BEGIN
  SELECT first_name, last_name, birth_date
  INTO out_first_name, out_last_name, out_birth_date
  FROM t_actor where id = in_id;
END;</programlisting><code>in_id</code>파라미터는 검색하는 액터의
      <code>id</code>를 담고 있다. <code>out</code> 파라미터들은 테이블에서
      읽은 데이터를 반환한다.</para>

      <para><classname>SimpleJdbcInsert</classname>과 유사한 방법으로
      <classname>SimpleJdbcCall</classname>를 선언한다. 데이터 접근 계층의 초기화 메서드에서
      <classname>SimpleJdbcCall</classname>를 인스턴스화하고 설정해야 한다. StoredProcedure
      클래스와 비교해서 하위클래스를 만들 필요가 없고 데이터베이스 메타데이터에서 검색할 수 있는 파라미터를
      선언할 필요가 없다. <!--Reword preceding: You need not subclass *what?* and you declare *what* in init method? TR: Revised, pplease review.-->다음은 위의 저장 프로시저를 사용하는
      SimpleJdbcCall 설정의 예제이다. <classname>DataSource</classname>외에 유일한 설정
      옵션은 저장 프로시저의 이름이다.<!--Indicate what the purpose of this example is (what it does) and identify the name of procedure. Also see next query. TR: Revised, please review.--></para>

      <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcTemplate simpleJdbcTemplate;
    private SimpleJdbcCall procReadActor;

    public void setDataSource(DataSource dataSource) {
        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
        this.procReadActor =
                new SimpleJdbcCall(dataSource)
                        .withProcedureName("read_actor");
    }

    public Actor readActor(Long id) {
        SqlParameterSource in = new MapSqlParameterSource()
                .addValue("in_id", id);
        Map out = procReadActor.execute(in);
        Actor actor = new Actor();
        actor.setId(id);
        actor.setFirstName((String) out.get("out_first_name"));
        actor.setLastName((String) out.get("out_last_name"));
        actor.setBirthDate((Date) out.get("out_birth_date"));
        return actor;
    }

    //  ... 추가적인 메서드
}</programlisting>호출을 실행하려고 작성한 코드에서 IN 파라미터를 담고 있는
      <classname>SqlParameterSource</classname>를 생성한다. <!--sentence before this one said *all you need to specify* is name of procedure, but preceding sentence says it involves creating an--><!--SQLParameterSource. Isn't this *in addition* to specifying procedure name? Revise to clarify what a human does in this example. --><!--Reword preceding to clarify whether a human creates the SqlParameterSource.
TR: Revised, please review. Execution is separate from declaration, so we still only need to declare the name of the proc.-->입력 값에 제공한 이름과 저장 프로시저에서 선언한 파라미터 이름이 일치해야 한다는 점이
      중요하다. <!--match *what* to the name of parameter in stored procedure?? And if this is something you're telling a human to do,--><!--reword to say *You must match <what> to the name of the parameter etc* TR: Revised.-->
      데이터베이스 객체가 저장 프로시저에서 어떻게 참조해야 하는지를 메타데이터를 사용해서 결정하므로
      이 경우에는 일치하지 않아도 된다. 저장 프로시저의 소스에 정의한 것은 데이터베이스에 저장되어 있지
      않아도 된다. 몇몇 데이터베이스는 이름을 모두 대분자로 변환하는데 반해 어떤 데이터베이스는 소문자를
      사용하거나 지정한대로 사용한다.</para>

      <para><classname>execute</classname> 메서드는 IN 파라미터를 받고 저장 프로시저가
      지정한 이름을 키로 사용하는 <code>out</code> 파라미터를 담고 있는 Map을 반환한다. 이 예제의
      경우에는 키가 <classname>out_first_name, out_last_name</classname>,
      <classname>out_birth_date</classname>이다.</para>

      <para><classname>execute</classname> 메서드의 마지막 부분은 받은 데이터를 반환하려고
      사용하는 Actor 인스턴스를 생성한다. 다시 얘기하지만 저장 프로시저에 선언한 것과 같은
      <code>out</code> 파라미터의 이름을 사용한 것이 중요하다. <!--*match* them how? What are you matching to what? I see three different out parameters (first name, last name, birth date). Revise. TR: Revised.-->또한,
      결과로 받은 맵에 저장된 <code>out</code> 파라미터의 이름은 데이터베이스(데이터베이스는 다양할 수
      있다)의 <code>out</code> 파라미터 이름과 일치해야 한다. <!--Preceding sentence, are you saying the case will match, or it *should*? Next sentence, state why you are doing what you are told to do. TR: Revised.-->
      코드가 더 이식성이 있게 하려면 대소문자를 구별하지 않는 검색을 하거나 스프링이 Jakarta Commons
      프로젝트의 <classname>CaseInsensitiveMap</classname> 를 사용하도록 해야한다. 후자를 사용하려면
      자신만의 <classname>JdbcTemplate</classname>를 생성하고
      <classname>setResultsMapCaseInsensitive</classname> 프로퍼티를 <classname>true</classname>로
      설정해라. 그 다음 이 커스터마이징한 <classname>JdbcTemplate</classname> 인스턴스를
      <classname>SimpleJdbcCall</classname>의 생성자에 전달해라. 제대로 동작하려면 클래스패스에
      <classname>commons-collections.jar</classname>를 포함해야 한다. 다음은 이 설정에
      대한 예제이다.</para>

      <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcCall procReadActor;

    public void setDataSource(DataSource dataSource) {
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.procReadActor =
                new SimpleJdbcCall(jdbcTemplate)
                        .withProcedureName("read_actor");
    }


    //  ... 추가적인 메서드
}</programlisting>이번 섹션을 통해서 반환된 <code>out</code> 파라미터의 이름을 사용하는
      경우의 충돌을 피할 수 있다.</para>
    </section>

    <section id="jdbc-simple-jdbc-call-2">
      <title>SimpleJdbcCall에 사용할 파라미터 명시적으로 선언하기</title>

      <para>파라미터가 메타데이터에 기반해서 어떻게 추론되는지 보았지만 원하다면 명시적으로 선언할 수
      있다. 입력으로 다수의 <classname>SqlParameter</classname> 객체들을 받는
      <classname>declareParameters</classname> 메서드를 가진
      <classname>SimpleJdbcCall</classname>를 생성하고 선언해서 명시적으로 선언할 수 있다.
      <classname>SqlParameter</classname>를 정의하는 방법은 다음 섹션에서 자세히 살펴본다.<!--Moved following info from end of section and made it a note. Important to know this up front. TR: OK.--></para>

      <para><note>
          <para>사용하는 데이터베이스를 스프링이 지원하지 않을 때 명시적인 선언이 필요하다. 현재
          스프링은 다음 데이터베이스들에서 저장 프로시저 호출의 메타데이터 검색을 지원한다. Apache
          Derby, DB2, MySQL, Microsoft SQL Server, Oracle, Sybase. MySQL,
          Microsoft SQL Server, Oracle에서는 저장 함수(stored function)의 메타데이터
          검색도 지원한다.</para>
        </note></para>

      <para>하나의 파라미너나 몇몇 파라미터 혹은 파라미터 전부를 명시적으로 선언할 수 있다.
      파라미터를 명시적으로 선언하지 않은 곳에서는 여전히 파라미터 메타데이터를
      사용한다. <!--Is my rewording of preceding sentence ok? (See next sentence.)-->
      잠재적인 파라미터에 대한 메타데이터 검색과정을 모두 건너뛰고 선언된 파라미터만 사용하려면 선언의
      일부분으로 <classname>withoutProcedureColumnMetaDataAccess</classname> 메서드를
      호출해라. 데이터베이스 함수에 선언된 두가지 이상의 다른 시그니처를 호출할 것이다. 이 경우에는 주어진
      시그니처에 포함하도록 IN 파라미터 이름의 목록을 지정하는
      <classname>useInParameterNames</classname>를 호출한다.</para>

      <para>다음 예제는 앞의 예제의 정보를 사용하는 완전히 선언된 프로시저 호출을 보여준다.</para>

      <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcCall procReadActor;

    public void setDataSource(DataSource dataSource) {
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.procReadActor =
                new SimpleJdbcCall(jdbcTemplate)
                        .withProcedureName("read_actor")
                        .withoutProcedureColumnMetaDataAccess()
                        .useInParameterNames("in_id")
                        .declareParameters(
                                new SqlParameter("in_id", Types.NUMERIC),
                                new SqlOutParameter("out_first_name", Types.VARCHAR),
                                new SqlOutParameter("out_last_name", Types.VARCHAR),
                                new SqlOutParameter("out_birth_date", Types.DATE)
                        );
    }


    //  ... 추가적인 메서드
}</programlisting>두 예제의 실행과 최종 결과는 동일하다. 이 예제는 메타데이터에 의존하지 않고
      모든 것을 명시적으로 지정했다.</para>
    </section>

    <section id="jdbc-params">
      <title>SqlParameters를 지정하는 방법</title>

      <para><xref linkend="jdbc-object" />에서 다뤘던 SimpleJdbc 클래스와 RDBMS
      작업(operation) 클래스에 파라미터를 정의하려면
      <!--Deleted *described in following section* because RDBMS not mentioned in next section (5.8). Revise to give link to section you mean.-->
      <classname>SqlParameter</classname>나 <classname>SqlParameter</classname>의
      하위클래스를 사용해라. 일반적으로 생성자에 파라미터 명과 SQL 유형(type)를 지정한다. SQL 유형는
      <classname>java.sql.Types</classname> 상수로 지정한다. 이미 다음과 같은 선언문을
      보았다.</para>

      <para><programlisting language="java">   new SqlParameter("in_id", Types.NUMERIC),
   new SqlOutParameter("out_first_name", Types.VARCHAR),</programlisting></para>

      <para><classname>SqlParameter</classname>의 첫 라인은 IN 파라미터를 선언한다.
      IN 파라미터는 저장 프로시저 호출과 <classname>SqlQuery</classname>를 사용하는 쿼리에
      모두 사용할 수 있다. <classname>SqlQuery</classname>의 하위 클래스는
      다음 섹션에서 다룬다.</para>

      <para><classname>SqlOutParameter</classname>가 있는 두번째 라인은 저장 프로시저
      호출에 사용하는 <code>out</code> 파라미터를 선언한다. 프로시저에 <code>IN</code> 값을
      제공하고 값을 반환하는 <code>InOut</code> 파라미터에 대한
      <classname>SqlInOutParameter</classname> 도 있다.</para>

      <note>
        <para><classname>SqlParameter</classname>와
        <classname>SqlInOutParameter</classname>처럼 유일하게 선언된 파라미터는 입력값을
        제공하는데 사용한다. 이 부분이 <classname>StoredProcedure</classname> 클래스와
        다른 점이다. 하위 호환성때문에 <classname>SqlOutParameter</classname>로 선언한
        파라미터에 제공하는 입력값을 허용한다.</para>
      </note>

      <para>IN 파라미터에 이름과 SQL 유형외에 숫자 데이터의 진법(scale)나 커스텀 데이터베이스
      유형의 이름을 지정할 수 있다. <code>out</code> 파라미터에 <code>REF</code> 커서가
      반환한 열(row)의 매핑을 다루는 <classname>RowMapper</classname>를 제공할 수 있다.
      또 다른 옵션은 반환값을 조작을 커스터마이징할 수 있는 <classname>SqlReturnType</classname>를
      지정하는 것이다.</para>
    </section>

    <section id="jdbc-simple-jdbc-call-3">
      <title>SimpleJdbcCall를 사용해서 저장 함수(stored function) 호출하기</title>

      <para>저장 프로시저 이름 대신에 함수 이름을 제공한다는 점을 제외하고는 저장 프로시저를 호출한
      것과 거의 같은 방법으로 저장 함수를 호출한다. 호출하고자 하는 함수를 나타내는 설정의 일부로
      <classname>withFunctionName</classname> 메서드를 사용하고 함수 호출에 대응하는 문자열이
      생성된다. 전문화된 실행 호출인 <classname>executeFunction,</classname>를 함수를 호출하는데
      사용하고 <classname>executeFunction,</classname>는 지정한 타입의 객체로 값을 반환하는
      함수를 반환하므로 리절트맵에서 반환값을 획득하지 않다도 된다. <!--Are you saying you use withFunctionName, *then* use executeFunction? OR do you use one *or* the other? revise to clarify. Second --><!--snippet below uses both. TR: Revised.-->
      비슷하게 편리한 메서드인 <classname>executeObject</classname>도 하나의 <code>out</code>
      파라미터만 가진 저장 프로시저에 사용할 수 있다. 다음 예제는 액터의 전체이름을 반환하는
      <classname>get_actor_name</classname>이라는 저장 함수에 기반하고 있다.
      다음은 이 함수의 MySQL 버전이다.</para>

      <para><programlisting>CREATE FUNCTION get_actor_name (in_id INTEGER)
RETURNS VARCHAR(200) READS SQL DATA
BEGIN
  DECLARE out_name VARCHAR(200);
  SELECT concat(first_name, ' ', last_name)
    INTO out_name
    FROM t_actor where id = in_id;
  RETURN out_name;
END;</programlisting></para>

      <para>이 함수를 호출하려면 초기화 메서드에서 다시
      <classname>SimpleJdbcCall</classname>를 생성해야 한다.</para>

      <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcTemplate simpleJdbcTemplate;
    private SimpleJdbcCall funcGetActorName;

    public void setDataSource(DataSource dataSource) {
        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.funcGetActorName =
                new SimpleJdbcCall(jdbcTemplate)
                        .withFunctionName("get_actor_name");
    }

    public String getActorName(Long id) {
        SqlParameterSource in = new MapSqlParameterSource()
                .addValue("in_id", id);
        String name = funcGetActorName.executeFunction(String.class, in);
        return name;
    }

    //  ... 추가적인 메서드
}</programlisting>사용한 실행 메서드는 <!--In paragraph before first example it refers to executeFunction; is this what you mean by execute method? TR: Yes.-->함수
      호출의 반환값을 담고 있는 <classname>String</classname>을 반환한다.</para>
    </section>

    <section id="jdbc-simple-jdbc-call-4">
      <title>SimpleJdbcCall에서 ResultSet/REF 커서 반환하기</title>

      <para>리절트셋을 반환하는 저장 프로시저나 저장 함수의 호출은 약간 복잡하다. 다른 데이터베이스들이
      특정 타입의 <code>out</code> 파라미터를 명시적으로 등록해야 해야하는 반면 JDBC가 결과를
      처리하는 동안 몇몇 데이터베이스는 리절트 셋을 반환한다. 두 접근은 모두 리절트 셋을 순회하고 반환된
      열을 처리하기 위해 추가적인 처리과정을 필요로 한다. <classname>SimpleJdbcCall</classname>에서
      <classname>returningResultSet</classname> 메서드를 사용하고 특정 파라미터에 사용할
      <classname>RowMapper</classname> 구현체를 선언한다. 결과 처리과정 중 반환하는 리절트 맵의
      경우 이름이 정의되어 있지 않으므로 반환된 결과는 <classname>RowMapper</classname> 구현체에
      선언한 순서와 일치해야 한다. 실행 스테이트먼트가 반환한 리절트 맵에서 처리된 결과 목록을 저장하려고
      지정한 이름을 계속 사용한다.</para>

      <para>다음 예제는 IN 파리미터를 받지 않고 t_actor 테이블의 모든 열을 반환하는
      저장 프로시저를 사용한다. 다음은 이 프로시저의 MySQL 버전이다.</para>

      <para><programlisting>CREATE PROCEDURE read_all_actors()
BEGIN
 SELECT a.id, a.first_name, a.last_name, a.birth_date FROM t_actor a;
END;</programlisting>이 프로시저를 호출하기 위해 <classname>RowMapper</classname>를
      선언한다. 매핑할 클래스가 JavaBean 규칙을 따르므로 <classname>newInstance</classname>
      메서드에 매핑해야 하는 클래스에 전달함으로써 생성하는
      <classname>ParameterizedBeanPropertyRowMapper</classname>를 사용할 수 있다.</para>

      <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcTemplate simpleJdbcTemplate;
    private SimpleJdbcCall procReadAllActors;

    public void setDataSource(DataSource dataSource) {
        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.procReadAllActors =
                new SimpleJdbcCall(jdbcTemplate)
                        .withProcedureName("read_all_actors")
                        .returningResultSet("actors",
                                ParameterizedBeanPropertyRowMapper.newInstance(Actor.class));
    }

    public List getActorsList() {
        Map m = procReadAllActors.execute(new HashMap&lt;String, Object&gt;(0));
        return (List) m.get("actors");
    }

    //  ... 추가적인 메서드
}</programlisting>이 호출은 어떤 파라미터도 받지 않으므로 비어있는 Map에 실행호출을 전달한다.
      리절트맵에서 Actor의 목록을 얻어서 호출자(caller)에게 반환한다.</para>
    </section>
  </section>

  <section id="jdbc-object">
    <title>자바객체처럼 JDBC 작업 모델링하기</title>

    <para><literal>org.springframework.jdbc.object</literal> 패키지는 좀 더
    객체지향적인 방법으로 데이터베이스에 접근하도록 하는 클래스들을 포함하고 있다. 예제처럼 쿼리를
    실행하고 관계형 컬럼 데이터가 비즈니스 객체의 프로퍼티로 매핑된 비즈니스 객체의 리스트를 결과로
    받을 수 있다. 저장 프로시저뿐만 아니라 update, delete, insert문을 실행할 수 있다.</para>

    <note>
      <para>수많은 스프링 개발자들은 아래에 나열한 여러가지 RDBMS 작업 클래스들(<link
      linkend="jdbc-StoredProcedure"><classname>StoredProcedure</classname></link>의
      예외와 함께)을 직접 <classname>JdbcTemplate</classname>을 호출해서 대체할 수 있다고 생각한다.
      (완전한 클래스로 쿼리를 은닉화하는 것과는 반대로)직접 <classname>JdbcTemplate</classname>의
      메서드를 호출하는 DAO 메서드를 작성하는 것이 때로는 더 간단하다.<!--I don't know how the second sentence in the note is supposed to read, and whether it suggests something different--><!--from what the Spring developers suggest, or is it the same thing? Clarify. TR: Revised.--></para>

      <para>하지만 RDBMS 작업 클래스를 사용해서 예측할 수 있는 값을 얻어온다면 계속해서
      이러한 클래스들을 사용해라.</para>
    </note>

    <section id="jdbc-SqlQuery">
      <title><classname>SqlQuery</classname></title>

      <para><classname>SqlQuery</classname>는 재사용가능하고 스레드세이프한 클래스로 SQL
      쿼리를 은릭화한다. 하위클래스들은 쿼리를 수행하면서 생성된 <interfacename>ResultSet</interfacename>을
      순회해서 얻은 열마다 하나의 객체를 생성할 수 있는 <interfacename>RowMapper</interfacename>
      인스턴스를 제공하는 <methodname>newRowMapper(..)</methodname> 메서드를 구현해야 한다.
      <classname>MappingSqlQuery</classname> 하위클래스가 자바 클래스에 열(row)을 매핑하기에
      훨씬 더 편리한 구현체이므로 <classname>SqlQuery</classname>를 직접 사용하는 경우는 흔치않다.
      <classname>SqlQuery</classname>를 확장하는 다른 구현체들은
      <classname>MappingSqlQueryWithParameters</classname>와
      <classname>UpdatableSqlQuery</classname>이다.</para>
    </section>

    <section id="jdbc-MappingSqlQuery">
      <title><classname>MappingSqlQuery</classname></title>

      <para><classname>MappingSqlQuery</classname>는 제공받은
      <interfacename>ResultSet</interfacename>의 각 열을 지정한 타입의 객체로 변환하는
      추상 <methodname>mapRow(..)</methodname> 메서드를 구현해야하는 하위클래스의 재사용할
      수 있는 쿼리이다. 다음 예제는 <code>t_actor</code>의 데이터를
      <classname>Actor</classname> 클래스의 인스턴스로 매핑하는 커스텀 쿼리를 보여준다.</para>

      <programlisting language="java">public class ActorMappingQuery extends MappingSqlQuery&lt;Actor&gt; {

    public ActorMappingQuery(DataSource ds) {
        super(ds, "select id, first_name, last_name from t_actor where id = ?");
        super.declareParameter(new SqlParameter("id", Types.INTEGER));
        compile();
    }

    @Override
    protected Actor mapRow(ResultSet rs, int rowNumber) throws SQLException {
        Actor actor = new Actor();
        actor.setId(rs.getLong("id"));
        actor.setFirstName(rs.getString("first_name"));
        actor.setLastName(rs.getString("last_name"));
        return actor;
    }

}</programlisting>

      <para>이 클래스는 <classname>Actor</classname> 타입을 파라미터로 가진
      <classname>MappingSqlQuery</classname>를 확장한다. 이 커스텀 쿼리의 생성자는 유일한
      파라미터로 <interfacename>DataSource</interfacename>를 받는다. 이 생성자에서
      <interfacename>DataSource</interfacename>와 이 쿼리로 데이터를 조회하기위해 실행되어야
      하는 SQL로 수퍼클래스의 생성자를 호출한다. <interfacename>PreparedStatement</interfacename>를
      생성하는데 이 SQL을 사용할 것이므로 실행중에 전달되는 파라미터에 대한 플레이스홀더를 포함할
      것이다.<!--Identify *it*. PreparedStatement? TR: It's a common Java JDBC class.-->
      <classname>SqlParameter</classname>에 전달되는 <literal>declareParameter</literal>
      메서드를 사용해서 각 파라미터를 선언해야 한다. <!--Rewording ok? Whenever you say that X *must* happen, it usually involves human interaction to make X happen or do something to --><!--make X happen. TR: Revised.-->
      <classname>SqlParameter</classname>는 이름과 <classname>java.sql.Types</classname>로
      정의된 JDBC 타입을 받는다. 모든 파라미터를 정의했으면 <literal>compile()</literal> 메서드를
      호출해서 스테이트먼트를 준비하고 나중에 실행될 수 있게 한다. 이 클래스는 컴파일된 후에는 스레드세이프하므로
      DAO가 초기화되었을 때 이러한 인스턴스들이 생성되는 한<!--beginning of sentence says *this class*, then it says *these classes*. Are you talking about one class or multiple classes. Revise. TR: Revised.-->
      인스턴스 변수들은 유지가 되고 재사용될 수 있다.</para>

      <programlisting language="java">private ActorMappingQuery actorMappingQuery;

@Autowired
public void setDataSource(DataSource dataSource) {
    this.actorMappingQuery = new ActorMappingQuery(dataSource);
}

public Customer getCustomer(Long id) {
    return actorMappingQuery.findObject(id);
}</programlisting>

      <para>이 예제의 메서드는 유일한 파라미터로 전달된 고객의 id를 얻는다. 하나의 객체만 얻기
      원하므로 편리한 메서드인 <code>findObject</code>를 id 파라미터와 함께 호출한다. 대신
      객체의 리스트를 반환하는 쿼리가 있고 추가적인 메서드를 받는다면 가변인자로 파라미터 값의 배열을
      받는 실행 메서드 중의 하나를 사용할 것이다.</para>

      <programlisting language="java">public List&lt;Actor&gt; searchForActors(int age, String namePattern) {
    List&lt;Actor&gt; actors = actorSearchMappingQuery.execute(age, namePattern);
    return actors;
}</programlisting>
    </section>

    <section id="jdbc-SqlUpdate">
      <title><classname>SqlUpdate</classname></title>

      <para><classname>SqlUpdate</classname> 클래스는 SQL update를 감춤다. 쿼리처럼
      update 객체는 재사용할 수 있고 모든 <classname>RdbmsOperation</classname> 클래스들처럼
      update도 파라미터를 가질 수 있고 SQL에 정의될 수 있다. 이 클래스는 query 객체의
      <methodname>execute(..)</methodname>와 유사한 다수의
      <methodname>update(..)</methodname> 메서드를 재공한다.
      <classname>SQLUpdate</classname> 클래스는 구체화된(concrete) 클래스이다. 예를 들어
      단순히 <classname>execute</classname>를 호출하는 다음의 예제처럼
      <classname>SQLUpdate</classname> 클래스는 커스텀 업데이트 메서드를 추가하는
      하위클래스가 될 수 있다. <!--I have broken the preceding line and next line into two sentences, but they still don't read right. What do you mean by *where we call it--><!--execute*? That doesn't make sense. Also, avoid *we*, say *you*. TR: revised.-->
      하지만 SQL을 설정하고 파라미터를 선언해서 쉽게 파라미터화할 수 있으므로
      <classname>SqlUpdate</classname> 클래스를 하위클래스로 가지고 있지 않다.<!--Revise *parameterized*; this is not a word. And, what is the point being made? Rewrite this sentence and the one before it. TR: OK.--></para>

      <programlisting language="java">import java.sql.Types;

import javax.sql.DataSource;

import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.object.SqlUpdate;

public class UpdateCreditRating extends SqlUpdate {

    public UpdateCreditRating(DataSource ds) {
        setDataSource(ds);
        setSql("update customer set credit_rating = ? where id = ?");
        declareParameter(new SqlParameter("creditRating", Types.NUMERIC));
        declareParameter(new SqlParameter("id", Types.NUMERIC));
        compile();
    }

    /**
     * @param 업데이트할 Customer의 id
     * @param 신용등급의 새로운 값
     * @return 업데이트된 열의 수
     */
    public int execute(int id, int rating) {
        return update(rating, id);
    }
}</programlisting>
    </section>

    <section id="jdbc-StoredProcedure">
      <title><classname>StoredProcedure</classname></title>

      <para><classname>StoredProcedure</classname>는 RDBMS 저장 프로시저의 객체 추상화에
      대한 수퍼클래스이다. 이 클래스는 <literal>abstract</literal>이고
      <classname>StoredProcedure</classname>의 다양한 <literal>execute(..)</literal>
      메서드는 <literal>protected</literal> 접근권한을 가져서 더 제한적인 타입을 제공하는
      하위클래스외에는 사용할 수 없게 한다.</para>

      <para>상속받은 <literal>sql</literal> 프로퍼티는 RDBMS의 저장 프로시저의
      이름이 될 것이다.</para>

      <para><classname>StoredProcedure</classname> 클래스에 파라미터를 정의하려면
      <classname>SqlParameter</classname>나 <classname>SqlParameter</classname>의
      하위클래스중 하나를 사용해라. 다음 예제 코드처럼 생성자에 파라미터명과 SQL 유형을 지정해야 한다.
      SQL 유형은 <classname>java.sql.Types</classname> 상수를 사용해서 지정한다.<!--The following example shows what, what is its purpose? TR: Revised.--></para>

      <para><programlisting language="java">   new SqlParameter("in_id", Types.NUMERIC),
   new SqlOutParameter("out_first_name", Types.VARCHAR),</programlisting></para>

      <para><classname>SqlParameter</classname>를 사용한 첫 라인은 IN 파라미터를
      선언한다. IN 파라미터는 다음 섹션에서 다룰 <classname>SqlQuery</classname>와
      <classname>SqlQuery</classname>의 하위클래스를 사용한 쿼리와 저장 프로시저 호출
      모두에 사용할 수 있다.</para>

      <para><classname>SqlOutParameter</classname>가 있는 두번째 라인은 저장 프로시저
      호출에 사용하는 <code>out</code> 파라미터를 선언한다. 프로시저의 <code>in</code> 값을
      제공하고 프로시저가 반환하는 값도 담고 있는 <code>I</code><code>nOut</code> 파라미터에
      대한 <classname>SqlInOutParameter</classname>도 존재한다.</para>

      <para><code>i</code><code>n</code> 파라미터에서는 이름과 SQL 유형외에도 숫자 데이터의
      진법(scale)나 커스텀 데이터베이스 유형의 이름을 지정할 수 있다. <code>out</code>에서는
      REF 커서가 반환하는 열의 매핑을 다루는 <classname>RowMapper</classname>를 제공할 수 있다.
      또 다른 옵션으로 반환값의 조작을 커스터마이징할 수 있는
      <classname>SqlReturnType</classname>를 지정할 수 있다.</para>

      <para>다음은 오라클 데이터베이스에서 <literal>sysdate()</literal> 함수를 호출하는
      <classname>StoredProcedure</classname>를 사용하는 간단한 DAO 예제다. 저장 프로시저의
      모든 기능을 사용하려면 <classname>StoredProcedure</classname>를 확장한 클래스를 생성해야
      한다. 이 예제에서는 <classname>StoredProcedure</classname> 클래스가 내부 클래스이지만
      <classname>StoredProcedure</classname>를 재사용해야하면 최상위 클래스로 정의하면 된다.
      이 예제에는 입력 파라미터가 없지만 출력 파라미터는 <classname>SqlOutParameter</classname>
      클래스를 사용해서 날짜 타입으로 선언했다. <literal>execute()</literal> 메서드는 프로시저를
      실행하고 받은 <classname>Map</classname>이 반환한 데이터를 추출한다. 실행해서 얻은
      <classname>Map</classname>은 키로 파라미터의 이름을 사용하고 선언된 각 출력 파라미터에
      대한 엔트리를 가진다.(이 경우에는 딱 하나만 있다.)</para>

      <programlisting language="java">import java.sql.Types;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.object.StoredProcedure;

public class StoredProcedureDao {

    private GetSysdateProcedure getSysdate;

    @Autowired
    public void init(DataSource dataSource) {
        this.getSysdate = new GetSysdateProcedure(dataSource);
    }

    public Date getSysdate() {
        return getSysdate.execute();
    }

    private class GetSysdateProcedure extends StoredProcedure {

        private static final String SQL = "sysdate";

        public GetSysdateProcedure(DataSource dataSource) {
            setDataSource(dataSource);
            setFunction(true);
            setSql(SQL);
            declareParameter(new SqlOutParameter("date", Types.DATE));
            compile();
        }

        public Date execute() {
            // 'sysdate' 저장 프로시저에 입력 파라미터가 없으므로 비어있는 Map을 제공한다...
            Map&lt;String, Object&gt; results = execute(new HashMap&lt;String, Object&gt;());
            Date sysdate = (Date) results.get("date");
            return sysdate;
        }
    }

}</programlisting>

      <para>다음 예제의 <classname>StoredProcedure</classname>는 2개의 출력
      파라미터를 가진다.(이 경우에는 Oracle REF 커서)</para>

      <programlisting language="java">import oracle.jdbc.OracleTypes;
import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.object.StoredProcedure;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

public class TitlesAndGenresStoredProcedure extends StoredProcedure {

    private static final String SPROC_NAME = "AllTitlesAndGenres";

    public TitlesAndGenresStoredProcedure(DataSource dataSource) {
        super(dataSource, SPROC_NAME);
        declareParameter(new SqlOutParameter("titles", OracleTypes.CURSOR, new TitleMapper()));
        declareParameter(new SqlOutParameter("genres", OracleTypes.CURSOR, new GenreMapper()));
        compile();
    }

    public Map&lt;String, Object&gt; execute() {
        // 다시 말하지만 이 저장 프로시저에 입력 파라미터가 없으므로 비어있는 Map을 제공한다
        return super.execute(new HashMap&lt;String, Object&gt;());
    }
}</programlisting>

      <para><classname>TitlesAndGenresStoredProcedure</classname> 생성자에서
      사용되고 있는 <literal>declareParameter(..)</literal> 메서드를 오버라이드한 여러
      메서드들이 어떻게 <interfacename>RowMapper</interfacename> 구현 인스턴스를 전달하는지
      봐라. 이는 이미 존재하는 기능을 재사용하는 아주 편리하고 강력한 방법이다.
      <interfacename>RowMapper</interfacename>의 두 구현체의 코드는 아래에 나와있다.</para>

      <para><classname>TitleMapper</classname> 클래스는
      <interfacename>ResultSet</interfacename>의 각 열을
      <classname>Title</classname> 도메인객체에 매핑한다.</para>

      <programlisting language="java">import org.springframework.jdbc.core.RowMapper;

import java.sql.ResultSet;
import java.sql.SQLException;

import com.foo.domain.Title;

public final class TitleMapper implements RowMapper&lt;Title&gt; {

    public Title mapRow(ResultSet rs, int rowNum) throws SQLException {
        Title title = new Title();
        title.setId(rs.getLong("id"));
        title.setName(rs.getString("name"));
        return title;
    }
}</programlisting>

      <para><classname>GenreMapper</classname> 클래스는
      <interfacename>ResultSet</interfacename>의 각 열을
      <classname>Genre</classname> 도메인객체에 매핑한다.</para>

      <programlisting language="java">import org.springframework.jdbc.core.RowMapper;

import java.sql.ResultSet;
import java.sql.SQLException;

import com.foo.domain.Genre;

public final class GenreMapper implements RowMapper&lt;Genre&gt; {

    public Genre mapRow(ResultSet rs, int rowNum) throws SQLException {
        return new Genre(rs.getString("name"));
    }
}</programlisting>

      <para>RDBMS의 정의에서 하나이상의 입력 파라미터를 가진 저장 프로시저에 파라미터를 전달하기 위해
      수퍼클래스의 타입이 없는 <literal>execute(Map parameters)</literal> 메서드
      (<literal>protected</literal> 접근권한을 가진다)에 위임하는 강타입의
      <literal>execute(..)</literal> 메서드를 작성할 수 있다. <!--Wording of preceding line is very awkward and doesn't track well at all. Please revise. Don't overuse parentheses. TR: Revised.-->
      예를 들면 다음과 같다.</para>

      <programlisting language="java">import oracle.jdbc.OracleTypes;
import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.object.StoredProcedure;

import javax.sql.DataSource;

import java.sql.Types;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

public class TitlesAfterDateStoredProcedure extends StoredProcedure {

    private static final String SPROC_NAME = "TitlesAfterDate";
    private static final String CUTOFF_DATE_PARAM = "cutoffDate";

    public TitlesAfterDateStoredProcedure(DataSource dataSource) {
        super(dataSource, SPROC_NAME);
        declareParameter(new SqlParameter(CUTOFF_DATE_PARAM, Types.DATE);
        declareParameter(new SqlOutParameter("titles", OracleTypes.CURSOR, new TitleMapper()));
        compile();
    }

    public Map&lt;String, Object&gt; execute(Date cutoffDate) {
        Map&lt;String, Object&gt; inputs = new HashMap&lt;String, Object&gt;();
        inputs.put(CUTOFF_DATE_PARAM, cutoffDate);
        return super.execute(inputs);
    }
}</programlisting>
    </section>
  </section>

  <section id="jdbc-parameter-handling">
    <title>파라미터와 데이터 값 조작과 관련된 일반적인 문제들</title>

    <para>스프링 프레임워크 JDBC의 다른 접근들 사이에서 파라미터와 데이터의 값과 관련한
    일반적인 문제들이 존재한다.</para>

    <section id="jdbc-type-information">
      <title>파라미터에 SQL 유형에 관한 정보 제공하기</title>

      <para>스프링은 보통 전달된 파라미터의 타입에 기반해서 파라미터의 SQL 유형을 결정한다. 파라미터
      값을 설정할 때 사용하는 SQL 유형을 명시적으로 제공할 수 있다. 종종 NULL 값을 제대로
      설정해야할 때 필요하다.</para>

      <para>여러 가지 방법으로 SQL 유형의 정보를 제공할 수 있다.</para>

      <itemizedlist>
        <listitem>
          <para><classname>JdbcTemplate</classname>의 많은 update와 query 메서드들은
          <code>int </code>배열의 형식으로 추가적인 파라미터를 받는다. 이 배열은
          <classname>java.sql.Types</classname> 클래스의 상수값을 사용해서 대응되는
          파라미터의 SQL 타입을 가리키는데 사용한다. <!--Reword to say *what* is using constant values from the java.sql.Types class to do *what*. Phrases that being with *using* are --><!--often unclear as to what uses what to do what.-->각 파라미터마다
          하나의 엔트리를 제공한다.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>이와 같은 부가적인 정보가 필요한 파라미터 값을 감싸는
          <classname>SqlParameterValue</classname> 클래스를 사용할 수 있다.
          <!--I revised another unclear case of *using*. If it's not correct, revise to say what is using the SqlParameterValue class to do what. TR: OK.-->
          각 값마다 새로운 인스턴스를 생성하고 생성자에서 SQL 유형과 파라미터 값을 전달한다. 숫자값의
          진법(scale) 파라미터를 제공할 수도 있다.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>이름있는 파라미터로 동작하는 메서드에서는
          <classname>SqlParameterSource</classname>계열의
          <classname>BeanPropertySqlParameterSource</classname>,
          <classname>MapSqlParameterSource</classname>를 사용해라. 둘 다 이름있는 파라미터
          값에 SQL 유형을 등록하는 메서드를 가진다.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="jdbc-lob">
      <title>BLOB과 CLOB 객체 다루기</title>

      <para>이미지나 다른 바이너리 객체들, 대량의 문자를 저장할 수 있다. 이처럼 큰 객체가 바이너리
      데이터이면 BLOB이라고 하고 문자 데이터이면 CLOB이라고 부른다. 스프링에서 JdbcTemplate을
      직접 사용하거나 RDBMS 객체와 <code>SimpleJdbc</code> 클래스의 더 높은 추상화를 사용하는
      경우에 이와 같은 큰 객체들을 다룰 수 있다. 이러한 모든 접근방법들은 LOB 데이터의 실제 관리에
      <classname>LobHandler</classname> 인터페이스의 구현체를 사용한다.
      <classname>LobHandler</classname>는 <classname>getLobCreator</classname>
      메서드로 추가할 새로운 LOB 객체를 생성하는데 사용하는 <classname>LobCreator</classname>
      클래스에 접근한다.</para>

      <para><classname>LobCreator/LobHandler</classname>는 LOB 입력과 출력에
      다음과 같은 지원을 제공한다.</para>

      <para><itemizedlist>
          <listitem>
            <para>BLOB</para>

            <itemizedlist>
              <listitem>
                <para>byte[] – getBlobAsBytes와 setBlobAsBytes</para>
              </listitem>

              <listitem>
                <para>InputStream – getBlobAsBinaryStream와
                setBlobAsBinaryStream</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist><itemizedlist>
          <listitem>
            <para>CLOB</para>

            <itemizedlist>
              <listitem>
                <para>String – getClobAsString와 setClobAsString</para>
              </listitem>

              <listitem>
                <para>InputStream – getClobAsAsciiStream와
                setClobAsAsciiStream</para>
              </listitem>

              <listitem>
                <para>Reader – getClobAsCharacterStream와
                setClobAsCharacterStream</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist></para>

      <para>다음 예제는 BLOB를 생성하고 삽입하는 방법을 보여준다. 뒤에서 데이터베이스에서 BLOB을
      다시 읽어들이는 방법을 살펴볼 것이다.</para>

      <para>이 예제는 <code>JdbcTemplate</code>와
      <code>AbstractLobCreatingPreparedStatementCallbac</code><code>k</code>의
      구현체를 사용한다. 이 예제는 <code>setValues</code> 메서드를 구현했고
      <code>setValues</code> 메서드는 SQL 인서트문에서 LOB 컬럼에 값을 설정하는데 사용하는
      <code>LobCreator</code>를 제공한다.</para>

      <para>이 예제에서는 이미 <classname>DefaultLobHandler</classname> 인스턴스에 설정된
      <code>lobHandle</code><code>r</code> 변수가 존재한다고 가정한다. 보통은 의존성 주입으로
      이 값을 설정한다.<!--Rewording ok? (What does what through dependency injection?) TR: Revised.--></para>

      <programlistingco>
        <areaspec>
          <area coords="8" id="jdbc.lobhandler.variableref" />

          <area coords="12" id="jdbc.lobhandler.setClob" />

          <area coords="13" id="jdbc.lobhandler.setBlob" />
        </areaspec>

        <programlisting language="java">final File blobIn = new File("spring2004.jpg");
final InputStream blobIs = new FileInputStream(blobIn);
final File clobIn = new File("large.txt");
final InputStream clobIs = new FileInputStream(clobIn);
final InputStreamReader clobReader = new InputStreamReader(clobIs);
jdbcTemplate.execute(
  "INSERT INTO lob_table (id, a_clob, a_blob) VALUES (?, ?, ?)",
  new AbstractLobCreatingPreparedStatementCallback(lobHandler) {
      protected void setValues(PreparedStatement ps, LobCreator lobCreator)
          throws SQLException {
        ps.setLong(1, 1L);
        lobCreator.setClobAsCharacterStream(ps, 2, clobReader, (int)clobIn.length());
        lobCreator.setBlobAsBinaryStream(ps, 3, blobIs, (int)blobIn.length());
      }
  }
);
blobIs.close();
clobReader.close();</programlisting>

        <calloutlist>
          <callout arearefs="jdbc.lobhandler.variableref">
            <para>이 예제에서는 평범한 <classname>DefaultLobHandler</classname>인
            lobHandler에 전달한다.<!--*Here* where?(deleted *Here we*) I don't see this in example.Use the lobHandler to do what? TR: Revised.--></para>
          </callout>

          <callout arearefs="jdbc.lobhandler.setClob">
            <para><classname>setClobAsCharacterStream</classname> 메서드를
            사용해서 CLOB의 내용에 전달한다.</para>
          </callout>

          <callout arearefs="jdbc.lobhandler.setBlob">
            <para><classname>setBlobAsBinaryStream</classname> 메서드를 사용해서
            BLOB의 내용에 전달한다.</para>
          </callout>
        </calloutlist>
      </programlistingco>

      <para>이제 데이터베이스에서 LOB 데이터를 읽을 차례다. 다시 얘기하지만 같은 인스턴스
      변수 <code>l</code><code>obHandler </code>와
      <classname>DefaultLobHandler</classname>에 대한 참조를 가진
      <code>JdbcTemplate</code>를 사용한다.</para>

      <para><programlistingco>
          <areaspec>
            <area coords="5" id="jdbc.lobhandler.getClob" />

            <area coords="7" id="jdbc.lobhandler.getBlob" />
          </areaspec>

          <programlisting language="java">List&lt;Map&lt;String, Object&gt;&gt; l = jdbcTemplate.query("select id, a_clob, a_blob from lob_table",
        new RowMapper&lt;Map&lt;String, Object&gt;&gt;() {
          public Map&lt;String, Object&gt; mapRow(ResultSet rs, int i) throws SQLException {
            Map&lt;String, Object&gt; results = new HashMap&lt;String, Object&gt;();
            String clobText = lobHandler.getClobAsString(rs, "a_clob");
            results.put("CLOB", clobText);
            byte[] blobBytes = lobHandler.getBlobAsBytes(rs, "a_blob");
            results.put("BLOB", blobBytes);
            return results;
          }
        });
</programlisting>

          <calloutlist>
            <callout arearefs="jdbc.lobhandler.setClob">
              <para><classname>getClobAsString</classname> 메서드를
              사용해서 CLOB의 내용을 얻는다.</para>
            </callout>

            <callout arearefs="jdbc.lobhandler.setBlob">
              <para><classname>getBlobAsBytes</classname> 메서드를
              사용해서 BLOB의 내용을 얻는다.<!--MISSING THE NUMBER 2 IN SNIPPET ABOVE. ADD WHERE APPROPRIATE. TR: ?; OK AS IS.--></para>
            </callout>
          </calloutlist>
        </programlistingco></para>
    </section>

    <section id="jdbc-in-clause">
      <title>IN절에 값 리스트 전달하기</title>

      <para>SQL 표준에서는 변경될 수 있는 값의 목록을 포함하는 표현식에 기반해서 조회할 수 있다.
      대표적인 예제는 <code>select * from T_ACTOR where id in (1, 2, 3)</code>이다.
      JDBC 표준의 프리페어드 스테이트먼트는 이 변경가능한 목록을 직접 지원하지 않는다. 달라질 수 있는
      수의 플레이스홀더를 선언할 수 없다. 필요한 수의 플레이스홀더를 알고 있다면 원하는 수의 플레이스홀더로
      다수를 준비하거나 SQL 문자열을 동적으로 만들어야 한다.
      <classname>NamedParameterJdbcTemplate</classname>와
      <classname>SimpleJdbcTemplate</classname>가 지원하는 이름있는 파라미터는 후자의 접근을
      취한다. 프리미티브 객체의 <classname>java.util.List</classname>로 값들을 전달해라.
      이 리스트는 필요한 플레이스홀더를 추가하는데 사용할 것이고 스테이트먼트 실행하면서 값을 전달할
      것이다.</para>

      <note>
        <para>많은 값을 전달할때는 조심해라. JDBC 표준은 <code>in</code> 표현식에 100개
        이상의 값을 사용하는 것을 보장하지 않는다. 다수의 데이터베이스가 이 값이상을 지원하지만
        보통 허용하는 제한값이 존재한다. 오라클은 1000개로 제한한다.</para>
      </note>

      <para>값의 리스트에서 프리미티브 값과 관련해서 추가적으로 객체 배열의
      <classname>java.util.List</classname>를 생성할 수 있다. 이 리스트는
      <code>select * from T_ACTOR where (id, last_name) in ((1, 'Johnson'), (2,
      'Harrop'))</code>같은 <code>in</code>절에 정의한 여러 표현식을 지원한다. 물론 이는
      데이터베이스가 이 문법을 지원해야 한다.</para>
    </section>

    <section id="jdbc-complex-types">
      <title>저장 프로시저 호출에서 복잡한 타입 다루기</title>

      <para>저장 프로시저를 호출할 때 때로는 데이터베이스 특유의 복잡한 타입을 사용할 수 있다.
      이러한 타입을 지원하려고 스프링은 저장 프로시저가 반환한 타입을 다루는
      <classname>SqlReturnType</classname>와 저장 프로시저에 파리미터로 전달하기 위한
      <classname>SqlTypeValue</classname>를 제공한다.</para>

      <para>다음은 사용자 정의 타입인 <code>ITEM_TYPE</code>의 오라클
      <code>STRUCT</code> 객체 값을 반환하는 예제이다. <classname>SqlReturnType</classname>
      인터페이스는 반드시 구현해야하는 <classname>getTypeValue</classname>라는 하나의
      메서드를 가진다. 이 인터페이스를 <classname>SqlOutParameter</classname>
      선언의 일부로 사용한다.</para>

      <para><programlisting language="java">final TestItem - new TestItem(123L, "A test item",
        new SimpleDateFormat("yyyy-M-d").parse("2010-12-31"););

declareParameter(new SqlOutParameter("item", OracleTypes.STRUCT, "ITEM_TYPE",
    new SqlReturnType() {
      public Object getTypeValue(CallableStatement cs, int colIndx, int sqlType, String typeName)
          throws SQLException {
        STRUCT struct = (STRUCT)cs.getObject(colIndx);
        Object[] attr = struct.getAttributes();
        TestItem item = new TestItem();
        item.setId(((Number) attr[0]).longValue());
        item.setDescription((String)attr[1]);
        item.setExpirationDate((java.util.Date)attr[2]);
        return item;
      }
    }));</programlisting>저장 프로시저에 <classname>TestItem</classname>같은 자바
      객체의 값을 전달할 때 <classname>SqlTypeValue</classname>를 사용한다. <!--Revise preceding as necessary. What do you mean by *go[ing] from Java to the database*? Is that the right way to say it? TR: Revised.-->
      <classname>SqlTypeValue</classname> 인터페이스는 반드시 구현해야 하는
      <classname>createTypeValue</classname>라는 하나의 메서드를 가진다. 이 메서드에
      활성화된 연결을 전달하고 다음 예제에 나오는 <classname>StructDescriptor</classname>나
      <classname>ArrayDescriptor</classname>같은 데이터베이스에 특화된 객체를 생성할 때
      사용할 수 있다.<!--Rewording of preceding ok? The example is showing human participation, I assume. ;-) TR: Yes :), OK.--></para>

      <para><programlisting language="java">final TestItem - new TestItem(123L, "A test item",
        new SimpleDateFormat("yyyy-M-d").parse("2010-12-31"););

SqlTypeValue value = new AbstractSqlTypeValue() {
  protected Object createTypeValue(Connection conn, int sqlType, String typeName) throws SQLException {
    StructDescriptor itemDescriptor = new StructDescriptor(typeName, conn);
    Struct item = new STRUCT(itemDescriptor, conn,
        new Object[] {
            testItem.getId(),
            testItem.getDescription(),
            new java.sql.Date(testItem.getExpirationDate().getTime())
        });
    return item;
  }
};</programlisting>이제 이 <classname>SqlTypeValue</classname>를 저장 프로시저를
      호출을 실행하는 입력 파라미터를 담고 있는 Map에 추가할 수 있다.</para>

      <para><classname>SqlTypeValue</classname>의 또 다른 사용방법은 오라클 저장 프로시저에
      값의 배열을 전달하는 것이다. 오라클은 이러한 경우에 사용해야하는 내부 <classname>ARRAY</classname>
      클래스를 가지고 있고 오라클 <classname>ARRAY</classname> 인스턴스를 생성하는데
      <classname>SqlTypeValue</classname>를 사용할 수 있고 자바 <code>ARRAY</code>의
      값을 가진다.</para>

      <programlisting language="java">final Long[] ids = new Long[] {1L, 2L};

SqlTypeValue value = new AbstractSqlTypeValue() {
  protected Object createTypeValue(Connection conn, int sqlType, String typeName) throws SQLException {
    ArrayDescriptor arrayDescriptor = new ArrayDescriptor(typeName, conn);
    ARRAY idArray = new ARRAY(arrayDescriptor, conn, ids);
    return idArray;
  }
};</programlisting>
    </section>
  </section>

  <section id="jdbc-embedded-database-support">
    <title>내장 데이터베이스 지원</title>

    <para><literal>org.springframework.jdbc.datasource.embedded</literal> 패키지는
    자바의 내장 데이터베이스 엔진을 지원한다.<ulink url="http://www.hsqldb.org">HSQL</ulink>,
    <ulink url="http://www.h2database.com">H2</ulink>, <ulink
    url="http://db.apache.org/derby">Derby</ulink>를 네이티브하게 지원한다. 새로운 내장
    데이터베이스 유형과 <classname>DataSource</classname> 구현체에 추가하는 확장가능한
    API를 사용할 수도 있다.</para>

    <section id="jdbc-why-embedded-database">
      <title>왜 내장 데이터베이스를 사용하는가?</title>

      <para>내장 데이터베이스가 가볍다는(lightweight) 특성때문에 프로젝트의 개발단계에서 내장
      데이터베이스는 유용한다. 설정이 쉽고 빠르게 시작할 수 있고 테스트가능하며 개발중에 SQL을
      빠르게 발전시킬 수 있다는 장점이 있다.</para>
    </section>

    <section id="jdbc-embedded-database-xml">
      <title>스프링 XML을 사용하는 내장 데이터베이스의 인스턴스 생성하기</title>

      <para>스프링 ApplicationContext의 빈처럼 내장 데이터베이스 인스턴스를 노출하고자
      하면 spring-jdbc 네임스페이스에 embedded-database 태그를
      사용해라. <programlisting language="xml">    &lt;jdbc:embedded-database id="dataSource"&gt;
        &lt;jdbc:script location="classpath:schema.sql"/&gt;
        &lt;jdbc:script location="classpath:test-data.sql"/&gt;
    &lt;/jdbc:embedded-database&gt;
</programlisting></para>

      <para>앞의 설정은 클래스패스의 schema.sql와 testdata.sql 리소스의 SQL로 내장 HSQL
      데이터베이스를 생성한다. 데이터베이스 인스턴스는
      <classname>javax.sql.DataSource</classname>타입의 빈으로 스프링 컨테이너에서 사용할
      수 있다. 이 빈을 필요할 때 데이터접근 객체에 주입할 수 있다.</para>
    </section>

    <section id="jdbc-embedded-database-java">
      <title>프로그래밍적으로 내장 데이터베이스 인스턴스 생성하기</title>

      <para><classname>EmbeddedDatabaseBuilder</classname> 클래스는 프로그래밍적으로
      내장 데이터베이스를 생성하는 유연한 API를 제공한다. 데이터접근 객체 유닛테스트같은 독립적인
      환경에서 내장 데이터베이스 인스턴스를 생성해야할 때 이 API를 사용해라.
      <programlisting language="java">    EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder();
    EmbeddedDatabase db = builder.setType(H2).addScript("my-schema.sql").addScript("my-test-data.sql").build();
    // 디비에 대한 작업을 수행한다 (EmbeddedDatabase는 javax.sql.DataSource를 확장한다)
    db.shutdown()
</programlisting></para>
    </section>

    <section id="jdbc-embedded-database-extension">
      <title>내장 데이터베이스 지원 확장하기</title>

      <para>스프링 JDBC 내장 데이터베이스지원은 두가지 방법으로 확장할 수 있다.
      <orderedlist>
          <listitem>
            <para>Apache Derby같은 새로운 내장 데이터베이스 유형을 지원하려면
            <classname>EmbeddedDatabaseConfigurer</classname>를 구현해라.</para>
          </listitem>

          <listitem>
            <para>내장 데이터베이스 연결을 관리하는 커넥션풀같은 새로운 DataSource 구현체를
            지원하려면 <classname>DataSourceFactory</classname>를 구현해라.</para>
          </listitem>
        </orderedlist></para>

      <para><ulink url="jira.springframework.org">jira.springframework.org</ulink>에서
      스프링 커뮤니티에 확장한 부분을 공헌해 주길 바란다.</para>
    </section>

    <section id="jdbc-embedded-database-using-HSQL">
      <title>HSQL의 사용</title>

      <para>스프링은 HSQL 1.8.0 이상의 버전을 지원한다. 명시적으로 유형을 지정하지 않으면 HSQL이
      기본 내장 데이터베이스다. HSQL을 명시적으로 지정하려면 <literal>embedded-database</literal>
      태그의 <literal>type</literal> 속성을 <literal>HSQL</literal>로 설정해라. 빌더 API를
      사용한다면 <literal>EmbeddedDatabaseType.HSQL</literal>로
      <literal>setType(EmbeddedDatabaseType)</literal> 메서드를 호출해라.</para>
    </section>

    <section id="jdbc-embedded-database-using-H2">
      <title>H2의 사용</title>

      <para>스프링은 H2도 잘 지원한다. H2를 활성화 하려면 <literal>embedded-database</literal>
      태그의 <literal>type</literal> 속성을 <literal>H2</literal>로 설정해라.
      빌더 API를 사용한다면 <literal>EmbeddedDatabaseType.H2</literal>로
      <literal>setType(EmbeddedDatabaseType)</literal> 메서드를 호출해라.</para>
    </section>

    <section id="jdbc-embedded-database-using-Derby">
      <title>Derby의 사용</title>

      <para>스프링은 Apache Derby 10.5 이상의 버전도 지원한다. Derby를 활성화하려면
      <literal>embedded-database</literal> 태그의 <literal>type</literal> 속성을
      <literal>Derby</literal>로 설정해라. 빌더 API를 사용한다면
      <literal>EmbeddedDatabaseType.Derby</literal>로
      <literal>setType(EmbeddedDatabaseType)</literal> 메서드를 호출해라.</para>
    </section>

    <section id="jdbc-embedded-database-dao-testing">
      <title>내장 데이터베이스로 데이터접근 로직 테스트하기</title>

      <para>내장 데이터베이스는 데이터접근 코드를 테스트하는 쉬운 방법을 제공한다. 다음은 내장
      데이터베이스를 사용하는 데이터접근 유닛 테스트의 템플릿이다.</para>

      <programlisting language="java">
public class DataAccessUnitTestTemplate {
    private EmbeddedDatabase db;

    @Before
    public void setUp() {
        // 기본 스크립트인 classpath:schema.sql와 classpath:test-data.sql로 HSQL 인메모리(in-memory) 디비를 생성한다
        db = new EmbeddedDatabaseBuilder().addDefaultScripts().build();
    }

    @Test
    public void testDataAccess() {
        JdbcTemplate template = new JdbcTemplate(db);
        template.query(...);
    }

    @After
    public void tearDown() {
        db.shutdown();
    }
}
</programlisting>
    </section>
  </section>

  <section>
    <title>DataSource 초기화</title>

    <para><literal>org.springframework.jdbc.datasource.init</literal> 패키지는
    존재하는 <classname>DataSource</classname> 초기화를 지원한다. 내장 데이터베이스 지원은
    어플리케이션의 <classname>DataSource</classname>의 생성과 초기화에 대한 한가지 선택사항을
    제공하지만 때로는 동작하는 서버 어디선가 인스턴스를 초기화해야할 필요가 있다.</para>

    <section>
      <title>스프링 XML을 사용해서 데이터베이스 인스턴스 초기화하기</title>

      <para>데이터베이스를 초기화하고자 하고 DataSource 빈에 대한 참조를 제공할 수
      있다면 <literal>spring-jdbc</literal> 네임스페이스의
      <literal>initialize-database</literal> 태그를 사용해라.</para>

      <programlisting>&lt;jdbc:initialize-database data-source="dataSource"&gt;
  &lt;jdbc:script location="classpath:com/foo/sql/db-schema.sql"/&gt;
  &lt;jdbc:script location="classpath:com/foo/sql/db-test-data.sql"/&gt;
&lt;/jdbc:initialize-database&gt;</programlisting>

      <para>위의 예제는 데이터베이스에 지정한 두 스크립트를 실행한다. 첫 스크립트는 스키마를
      생성하고 두번째 스크립트는 테스트 데이터를 추가한다. 스크립트의 위치도 스프링에서 리소스에
      사용하는 일반적인 ant 방식으로 와일드카드 패턴을 사용할 수 있다.(예시:
      <code>classpath*:/com/foo/**/sql/*-data.sql</code>) 패턴을 사용한다면
      URL이나 파일명의 사전순으로 스크립트를 실행한다.</para>

      <para>데이터베이스 초기자(initializer)의 기본 동작은 제공된 스크립트를 무조건 실행하는 것이다.
      이 동작이 항상 우리가 원하는 동작은 아닌데 예를 들어 이미 테스트 데이터가 있고 동작하고 있는
      데이터베이스가 있는 경우에는 실행할 필요가 없다. 테이블을 먼저 생성하고 데이터를 넣는 가장 일반적인
      패턴(위에 보여줬듯이)으로 의도치않게 데이터를 삭제할 가능성을 줄일 수 있다. 테이블이 이미 존재한다면
      테이블을 생성하는 첫번째 과정이 실패할 것이다.</para>

      <para>하지만 존재하는 데이터의 생성과 삭제를 더 세밀하게 제어하려면 XML 네임스페이스에서
      다수의 옵션을 제공한다. 첫 플래그는 초기화를 키고 끌 수 있다. 이 옵션은 환경에 따라서 다르게
      설정할 수 있다.(예시. 시스템 프로퍼티나 환경 빈에서 값을 가져온다) 예시. <programlisting>&lt;jdbc:initialize-database data-source="dataSource"
    <emphasis role="bold">enabled="#{systemProperties.INITIALIZE_DATABASE}"</emphasis>&gt;
  &lt;jdbc:script location="..."/&gt;
&lt;/jdbc:initialize-database&gt;</programlisting></para>

      <para>데이터가 존재하고 있을때의 동작을 제어하는 두번째 옵션은 좀 더 장애를 허용한다(tolerant
      of failures). 이 옵션으로 스크립트를 실행할 때 특정 SQL 오류를 무시하도록 초기자(initializer)의
      기능을 제어할 수 있다. 다음은 그 예시이다.</para>

      <para><programlisting>&lt;jdbc:initialize-database data-source="dataSource" <emphasis
            role="bold">ignore-failures="DROPS"</emphasis>&gt;
  &lt;jdbc:script location="..."/&gt;
&lt;/jdbc:initialize-database&gt;</programlisting>이 예제에서는 비어있는 데이터베이스에
      스크립트를 실행하고 스크립트에 DROP문이 있다면 실패할 것이다. 그래서 SQL <code>DROP</code>문의
      실패는 무시하지만 다른 실패는 예외를 발생시킬 것이다. 이는 사용하는 SQL 방언이
      <code>DROP ... IF EXISTS</code>(또는 비슷한)을 지원하지 않지만 테스트데이터를 다시 생성하기
      전에 무조건 모두 삭제하길 원하는 경우 유용하다. 이러한 경우에 첫 스크립트는 보통 drop에 관한 것이고
      이어서 <code>CREATE</code>문들이 온다.</para>

      <para><code>ignore-failures</code> 옵션을 <code>NONE</code> (기본값),
      <code>DROPS</code> (실패한 drop은 무시한다), <code>ALL</code>(모든 실패를
      무시한다)으로 설정할 수 있다.</para>

      <para>XML 네임스페이스로 설정하는 것보다 더 정밀하게 제어해야 한다면
      <classname>DataSourceInitializer</classname>를 어플리케이션의 컴포넌트로
      정의해서 직접 사용할 수 있다.</para>

      <section>
        <title>데이터베이스에 기반한 다른 컴포넌트들의 초기화</title>

        <para>어플리케이션에서 커다란 클래스는 더 이상 복잡해지지 않게 데이터베이스 초기화를 사용할
        수 있다. 이러한 클래스들은 스프링 컨텍스트가 시작될 때까지 데이터베이스를 사용하지 않는다.
        자신의 어플리케이션이 이러한 경우가 아니라면 이 섹션의 나머지 부분을 읽어야 할 것이다.</para>

        <para>데이터베이스 초기화는 데이터 소스 인스턴스에 의존하고 초기화 콜백에서 제공된 스크립트를
        실행한다. (XML 빈 정의의 <code>init-method</code>나 <code>InitializingBean</code>를
        참고해라.) 다른 빈들이 같은 데이터 소스에 의존하고 초기화 콜백에서 데이터소스를 사용하고 있다면
        데이터가 아직 초기화되지 않았기 때문에 문제가 될 수 있다. 이 문제의 일반적인 예시가 어플리케이션
        시작시에 데이터베이스의 데이터를 초기화하고 로딩하는 캐시이다.</para>

        <para>이 문제를 다루려면 두가지 선택사항이 있다. 캐시 초기화 전략을 나중의 단계로 바꾸거나
        데이터베이스 초기자가 먼저 초기된다는 것을 보장해라.</para>

        <para>어플리케이션을 제어하고 있다면 첫번째 방법이 쉽고 그렇지 않다면 어렵다. 이것을 구현하는
        몇 가지 방법이 있다.<itemizedlist>
            <listitem>
              <para>최소 사용시 캐시 초기화가 지연되도록 한다.(어플리케이션 구동시간이
              길어진다.)</para>
            </listitem>

            <listitem>
              <para>캐시나 캐시를 초기화하는 분리된 컴포넌트가 <code>Lifecycle</code>나
              <code>SmartLifecycle</code>를 구현한다. 어플리케이션 컨텍스트가 시작할 때
              <code>SmartLifecycle</code>의 <code>autoStartup</code> 플래그가 설정되어
              있다면 <code>SmartLifecycle</code>을 자동적으로 시작할 것이고 감싸진 컨텍스트에서
              <code>ConfigurableApplicationContext.start()</code>를 호출해서 수동으로
              <code>Lifecycle</code>를 시작할 수 있다.</para>
            </listitem>

            <listitem>
              <para>스프링 <code>ApplicationEvent</code>나 유사하게 캐시 초기화를 일으키는
              커스텀 옵저버 메카니즘을 사용해라. <code>ContextRefreshedEvent</code>는 사용할
              준비가 되었을 때(모든 빈이 초기화 된 후에) 컨텍스트가 항상 발행하므로 종종 유용한 훅(hook)이
              된다.(이것이 기본적으로 <code>SmartLifecycle</code>이 동작하는 방법이다.)</para>
            </listitem>
          </itemizedlist></para>

        <para>두번째 방법도 쉬울 수 있다. 두번째 방법을 구현하는 몇가지 방법들이 있다.<itemizedlist>
            <listitem>
              <para>등록순서로 빈을 초기화하는 스프링 BeanFactory 기본동작에 의존한다. 어플리케이션
              모듈의 순서인 &lt;import/&gt; 요소들의 일반적인 사용방법으로 데이터베이스와 데이터베이스
              초기화가 목록에서 먼저나오도록 함으로써 쉽게 배치할 수 있다.</para>
            </listitem>

            <listitem>
              <para>데이터소스와 데이터소스를 사용하는 비즈니스 컴포넌트들을 분리하고 이 둘을 분리된
              어플리케이션 인스턴스에 두고 시작 순서를 제어해라. (예시. 부모가 데이터소스를 가지고 있고
              자식이 비즈니스 컴포넌트를 가진다.) 이 구조는 스프링 웹어플리케이션에서는 일반적이지만
              더 범용적으로 적용할 수 있다.</para>
            </listitem>

            <listitem>
              <para>SpringSource dm Server처럼 모듈화된 런타임을 사용하고 데이터소스와
              데이터소스에 의존하는 컴포넌트들을 분리해라. 예를 들면 데이터소스 -&gt; 초기자 -&gt;
              비즈니스 컴포넌트와 같은 시작순서로 지정해라.</para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>
  </section>
</chapter>
